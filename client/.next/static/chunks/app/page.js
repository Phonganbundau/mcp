/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CAsus%5C%5CDownloads%5C%5Cmcp%5C%5Cclient%5C%5Csrc%5C%5Capp%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!**************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CAsus%5C%5CDownloads%5C%5Cmcp%5C%5Cclient%5C%5Csrc%5C%5Capp%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \**************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/page.tsx */ \"(app-pages-browser)/./src/app/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDQXN1cyU1QyU1Q0Rvd25sb2FkcyU1QyU1Q21jcCU1QyU1Q2NsaWVudCU1QyU1Q3NyYyU1QyU1Q2FwcCU1QyU1Q3BhZ2UudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsOEpBQWdHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/ZWE4YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkM6XFxcXFVzZXJzXFxcXEFzdXNcXFxcRG93bmxvYWRzXFxcXG1jcFxcXFxjbGllbnRcXFxcc3JjXFxcXGFwcFxcXFxwYWdlLnRzeFwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CAsus%5C%5CDownloads%5C%5Cmcp%5C%5Cclient%5C%5Csrc%5C%5Capp%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/page.tsx":
/*!**************************!*\
  !*** ./src/app/page.tsx ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _mcp_ui_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @mcp-ui/client */ \"(app-pages-browser)/./node_modules/@mcp-ui/client/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/../../../node_modules/process/browser.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nvar _process_env_NEXT_PUBLIC_MCP_WS_URL;\nconst DEFAULT_WS = (_process_env_NEXT_PUBLIC_MCP_WS_URL = process.env.NEXT_PUBLIC_MCP_WS_URL) !== null && _process_env_NEXT_PUBLIC_MCP_WS_URL !== void 0 ? _process_env_NEXT_PUBLIC_MCP_WS_URL : \"ws://localhost:8080/mcp\";\nconst asRenderableResource = (payload)=>{\n    if (!payload || typeof payload !== \"object\") {\n        return null;\n    }\n    const maybeResource = payload.type === \"resource\" && payload.resource ? payload.resource : payload;\n    if (!maybeResource || typeof maybeResource !== \"object\" || typeof maybeResource.mimeType !== \"string\") {\n        return null;\n    }\n    if (\"text\" in maybeResource && typeof maybeResource.text === \"string\") {\n        return maybeResource;\n    }\n    if (\"blob\" in maybeResource && typeof maybeResource.blob === \"string\") {\n        return maybeResource;\n    }\n    return null;\n};\nfunction Home() {\n    _s();\n    const [wsStatus, setWsStatus] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"connecting\");\n    const [todos, setTodos] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n    const [lastPayload, setLastPayload] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [info, setInfo] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [uiResource, setUiResource] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [uiVersion, setUiVersion] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(0);\n    const wsRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    const callbacks = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(new Map());\n    const requestId = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(0);\n    const pendingRequests = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)([]);\n    const connectionLabel = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(()=>{\n        switch(wsStatus){\n            case \"open\":\n                return \"Connected\";\n            case \"closed\":\n                return \"Disconnected\";\n            default:\n                return \"Connecting\";\n        }\n    }, [\n        wsStatus\n    ]);\n    const sendJsonRpc = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)((socket, method, params, handler)=>{\n        const id = ++requestId.current;\n        if (handler) {\n            callbacks.current.set(id, handler);\n        }\n        const payload = {\n            jsonrpc: \"2.0\",\n            id,\n            method,\n            params\n        };\n        socket.send(JSON.stringify(payload));\n    }, [\n        callbacks,\n        requestId\n    ]);\n    const flushPending = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(()=>{\n        const socket = wsRef.current;\n        if (!socket || socket.readyState !== WebSocket.OPEN) {\n            return;\n        }\n        while(pendingRequests.current.length > 0){\n            const next = pendingRequests.current.shift();\n            if (!next) {\n                continue;\n            }\n            sendJsonRpc(socket, next.method, next.params, next.handler);\n        }\n    }, [\n        sendJsonRpc\n    ]);\n    const sendRequest = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)((method, params, handler)=>{\n        const socket = wsRef.current;\n        if (!socket || socket.readyState !== WebSocket.OPEN) {\n            pendingRequests.current.push({\n                method,\n                params,\n                handler\n            });\n            setError(\"WebSocket is not connected yet.\");\n            return;\n        }\n        sendJsonRpc(socket, method, params, handler);\n    }, [\n        sendJsonRpc\n    ]);\n    const callTool = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(function(name) {\n        let args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, handler = arguments.length > 2 ? arguments[2] : void 0;\n        sendRequest(\"tools/call\", {\n            name,\n            arguments: args\n        }, handler);\n    }, [\n        sendRequest\n    ]);\n    const initialize = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(()=>{\n        sendRequest(\"initialize\", {}, ()=>{\n            sendRequest(\"tools/list\", {}, (payload)=>{\n                setLastPayload(JSON.stringify(payload, null, 2));\n            });\n        });\n    }, [\n        sendRequest\n    ]);\n    const applyUiResource = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)((maybeResource)=>{\n        const next = asRenderableResource(maybeResource);\n        if (next) {\n            setUiResource(next);\n            setUiVersion((prev)=>prev + 1);\n        }\n    }, []);\n    const listTodos = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(()=>{\n        callTool(\"todo_list\", {}, (payload)=>{\n            var _payload_todos;\n            setTodos((_payload_todos = payload.todos) !== null && _payload_todos !== void 0 ? _payload_todos : []);\n            applyUiResource(payload.ui);\n        });\n    }, [\n        callTool,\n        applyUiResource\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        const socket = new WebSocket(DEFAULT_WS);\n        wsRef.current = socket;\n        socket.onopen = ()=>{\n            setWsStatus(\"open\");\n            setError(null);\n            flushPending();\n            initialize();\n            setTimeout(()=>listTodos(), 200);\n        };\n        socket.onmessage = (event)=>{\n            try {\n                var _data_result, _data_result1, _data_result2, _data_result3, _data_result4;\n                const data = JSON.parse(event.data);\n                setLastPayload(JSON.stringify(data, null, 2));\n                if (typeof data.id === \"number\" && callbacks.current.has(data.id)) {\n                    const cb = callbacks.current.get(data.id);\n                    callbacks.current.delete(data.id);\n                    if (data.error) {\n                        var _data_error_message;\n                        setError((_data_error_message = data.error.message) !== null && _data_error_message !== void 0 ? _data_error_message : \"Unknown MCP error\");\n                    } else if (cb) {\n                        cb(data.result);\n                    }\n                } else if (data.error) {\n                    var _data_error_message1;\n                    setError((_data_error_message1 = data.error.message) !== null && _data_error_message1 !== void 0 ? _data_error_message1 : \"Unknown MCP error\");\n                }\n                if ((_data_result = data.result) === null || _data_result === void 0 ? void 0 : _data_result.todos) {\n                    setTodos(data.result.todos);\n                }\n                if ((_data_result1 = data.result) === null || _data_result1 === void 0 ? void 0 : _data_result1.todo) {\n                    setTodos((current)=>{\n                        const filtered = current.filter((t)=>t.id !== data.result.todo.id);\n                        return [\n                            ...filtered,\n                            data.result.todo\n                        ];\n                    });\n                }\n                if (((_data_result2 = data.result) === null || _data_result2 === void 0 ? void 0 : _data_result2.deleted) && ((_data_result3 = data.result) === null || _data_result3 === void 0 ? void 0 : _data_result3.id)) {\n                    setTodos((current)=>current.filter((t)=>t.id !== data.result.id));\n                }\n                if ((_data_result4 = data.result) === null || _data_result4 === void 0 ? void 0 : _data_result4.ui) {\n                    applyUiResource(data.result.ui);\n                }\n            } catch (err) {\n                console.error(\"Unable to parse MCP payload\", err);\n            }\n        };\n        socket.onerror = ()=>setError(\"WebSocket error\");\n        socket.onclose = ()=>{\n            setWsStatus(\"closed\");\n        };\n        return ()=>{\n            socket.close();\n            callbacks.current.clear();\n        };\n    }, [\n        initialize,\n        listTodos,\n        flushPending\n    ]);\n    const handleUIAction = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(async (action)=>{\n        switch(action.type){\n            case \"tool\":\n                await new Promise((resolve)=>{\n                    var _action_payload_params;\n                    callTool(action.payload.toolName, (_action_payload_params = action.payload.params) !== null && _action_payload_params !== void 0 ? _action_payload_params : {}, ()=>{\n                        setInfo(\"Executed \".concat(action.payload.toolName));\n                        listTodos();\n                        resolve();\n                    });\n                });\n                return;\n            case \"notify\":\n                setInfo(action.payload.message);\n                return;\n            default:\n                setInfo(\"Unhandled MCP-UI action: \".concat(action.type));\n        }\n    }, [\n        callTool,\n        listTodos\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        style: styles.main,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n            style: styles.panel,\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n                    style: styles.header,\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                    style: {\n                                        margin: 0\n                                    },\n                                    children: \"MCP Todo Console\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                                    lineNumber: 239,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    style: {\n                                        margin: 0,\n                                        color: \"#6b7280\"\n                                    },\n                                    children: [\n                                        \"WebSocket: \",\n                                        connectionLabel\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                                    lineNumber: 240,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                            lineNumber: 238,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            style: styles.secondaryButton,\n                            onClick: listTodos,\n                            children: \"Refresh\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                            lineNumber: 244,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                    lineNumber: 237,\n                    columnNumber: 9\n                }, this),\n                error && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    style: styles.error,\n                    children: error\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                    lineNumber: 249,\n                    columnNumber: 19\n                }, this),\n                info && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    style: styles.info,\n                    children: info\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                    lineNumber: 250,\n                    columnNumber: 18\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                    style: styles.uiSection,\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                            children: \"MCP-UI Resource\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                            lineNumber: 253,\n                            columnNumber: 11\n                        }, this),\n                        uiResource ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: styles.uiFrame,\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mcp_ui_client__WEBPACK_IMPORTED_MODULE_1__.UIResourceRenderer, {\n                                resource: uiResource,\n                                onUIAction: handleUIAction,\n                                supportedContentTypes: [\n                                    \"rawHtml\",\n                                    \"externalUrl\"\n                                ],\n                                htmlProps: {\n                                    style: {\n                                        border: \"none\",\n                                        width: \"100%\",\n                                        minHeight: 520\n                                    },\n                                    autoResizeIframe: {\n                                        height: true\n                                    },\n                                    sandboxPermissions: \"allow-scripts allow-forms\"\n                                }\n                            }, uiVersion, false, {\n                                fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                                lineNumber: 256,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                            lineNumber: 255,\n                            columnNumber: 13\n                        }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            style: {\n                                color: \"#6b7280\"\n                            },\n                            children: \"Call any todo tool to load the MCP-UI dashboard from the server.\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                            lineNumber: 269,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                    lineNumber: 252,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        marginTop: \"2rem\"\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                            children: \"Todos\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                            lineNumber: 276,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: styles.todoList,\n                            children: [\n                                todos.length === 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    children: \"No todos yet.\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                                    lineNumber: 278,\n                                    columnNumber: 36\n                                }, this),\n                                todos.map((todo)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"article\", {\n                                        style: styles.todoItem,\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                        style: {\n                                                            margin: 0,\n                                                            fontWeight: 600\n                                                        },\n                                                        children: todo.title\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                                                        lineNumber: 282,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                        style: {\n                                                            margin: 0,\n                                                            color: \"#6b7280\",\n                                                            fontSize: 12\n                                                        },\n                                                        children: todo.id\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                                                        lineNumber: 283,\n                                                        columnNumber: 19\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                                                lineNumber: 281,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                style: {\n                                                    color: todo.completed ? \"#16a34a\" : \"#ef4444\"\n                                                },\n                                                children: todo.completed ? \"Done\" : \"Open\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                                                lineNumber: 285,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, todo.id, true, {\n                                        fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                                        lineNumber: 280,\n                                        columnNumber: 15\n                                    }, this))\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                            lineNumber: 277,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                    lineNumber: 275,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        marginTop: \"2rem\"\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                            children: \"Last MCP Payload\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                            lineNumber: 294,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"pre\", {\n                            style: styles.pre,\n                            children: lastPayload || \"Waiting for messages...\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                            lineNumber: 295,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n                    lineNumber: 293,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n            lineNumber: 236,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Asus\\\\Downloads\\\\mcp\\\\client\\\\src\\\\app\\\\page.tsx\",\n        lineNumber: 235,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"uVvLffUtf671CoY9awribXzQHA4=\");\n_c = Home;\nconst styles = {\n    main: {\n        minHeight: \"100vh\",\n        padding: \"2rem\",\n        display: \"flex\",\n        justifyContent: \"center\"\n    },\n    panel: {\n        width: \"min(960px, 100%)\",\n        background: \"white\",\n        borderRadius: 12,\n        padding: \"2rem\",\n        boxShadow: \"0 20px 45px rgba(15,23,42,0.1)\"\n    },\n    header: {\n        display: \"flex\",\n        justifyContent: \"space-between\",\n        alignItems: \"center\",\n        marginBottom: \"1.5rem\"\n    },\n    secondaryButton: {\n        background: \"transparent\",\n        border: \"1px solid #111827\",\n        borderRadius: 8,\n        padding: \"0.5rem 1.5rem\",\n        fontWeight: 600\n    },\n    uiSection: {\n        marginTop: \"1.5rem\"\n    },\n    uiFrame: {\n        marginTop: \"0.75rem\",\n        borderRadius: 12,\n        overflow: \"hidden\",\n        border: \"1px solid #e5e7eb\",\n        minHeight: 520\n    },\n    todoList: {\n        display: \"flex\",\n        flexDirection: \"column\",\n        gap: \"0.75rem\"\n    },\n    todoItem: {\n        display: \"flex\",\n        justifyContent: \"space-between\",\n        alignItems: \"center\",\n        padding: \"0.75rem 1rem\",\n        border: \"1px solid #e5e7eb\",\n        borderRadius: 10\n    },\n    pre: {\n        background: \"#0f172a\",\n        color: \"#f8fafc\",\n        padding: \"1rem\",\n        borderRadius: 10,\n        maxHeight: 260,\n        overflow: \"auto\"\n    },\n    error: {\n        color: \"#b91c1c\",\n        fontWeight: 600\n    },\n    info: {\n        color: \"#0f172a\",\n        fontWeight: 500\n    }\n};\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNkO0lBQ0FyRyxNQUFNO1FBQ0pnRixPQUFPO1FBQ1BxQixZQUFZO0lBQ2Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL3BhZ2UudHN4P2Y2OGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IFVJUmVzb3VyY2VSZW5kZXJlciwgdHlwZSBVSUFjdGlvblJlc3VsdCB9IGZyb20gXCJAbWNwLXVpL2NsaWVudFwiO1xuaW1wb3J0IHR5cGUge1xuICBCbG9iUmVzb3VyY2VDb250ZW50cyxcbiAgRW1iZWRkZWRSZXNvdXJjZSxcbiAgVGV4dFJlc291cmNlQ29udGVudHMsXG59IGZyb20gXCJAbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3R5cGVzLmpzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5cbmNvbnN0IERFRkFVTFRfV1MgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19NQ1BfV1NfVVJMID8/IFwid3M6Ly9sb2NhbGhvc3Q6ODA4MC9tY3BcIjtcblxudHlwZSBUb2RvID0ge1xuICBpZDogc3RyaW5nO1xuICB0aXRsZTogc3RyaW5nO1xuICBjb21wbGV0ZWQ6IGJvb2xlYW47XG59O1xuXG50eXBlIE1jcFJlc3VsdEhhbmRsZXIgPSAocGF5bG9hZDogYW55KSA9PiB2b2lkO1xudHlwZSBQZW5kaW5nUmVxdWVzdCA9IHtcbiAgbWV0aG9kOiBzdHJpbmc7XG4gIHBhcmFtczogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIGhhbmRsZXI/OiBNY3BSZXN1bHRIYW5kbGVyO1xufTtcblxudHlwZSBSZW5kZXJhYmxlUmVzb3VyY2UgPSBUZXh0UmVzb3VyY2VDb250ZW50cyB8IEJsb2JSZXNvdXJjZUNvbnRlbnRzO1xuXG5jb25zdCBhc1JlbmRlcmFibGVSZXNvdXJjZSA9IChwYXlsb2FkOiB1bmtub3duKTogUmVuZGVyYWJsZVJlc291cmNlIHwgbnVsbCA9PiB7XG4gIGlmICghcGF5bG9hZCB8fCB0eXBlb2YgcGF5bG9hZCAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IG1heWJlUmVzb3VyY2UgPVxuICAgIChwYXlsb2FkIGFzIEVtYmVkZGVkUmVzb3VyY2UpLnR5cGUgPT09IFwicmVzb3VyY2VcIiAmJiAocGF5bG9hZCBhcyBFbWJlZGRlZFJlc291cmNlKS5yZXNvdXJjZVxuICAgICAgPyAocGF5bG9hZCBhcyBFbWJlZGRlZFJlc291cmNlKS5yZXNvdXJjZVxuICAgICAgOiAocGF5bG9hZCBhcyBUZXh0UmVzb3VyY2VDb250ZW50cyk7XG4gIGlmIChcbiAgICAhbWF5YmVSZXNvdXJjZSB8fFxuICAgIHR5cGVvZiBtYXliZVJlc291cmNlICE9PSBcIm9iamVjdFwiIHx8XG4gICAgdHlwZW9mIG1heWJlUmVzb3VyY2UubWltZVR5cGUgIT09IFwic3RyaW5nXCJcbiAgKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKFwidGV4dFwiIGluIG1heWJlUmVzb3VyY2UgJiYgdHlwZW9mIG1heWJlUmVzb3VyY2UudGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBtYXliZVJlc291cmNlIGFzIFRleHRSZXNvdXJjZUNvbnRlbnRzO1xuICB9XG4gIGlmIChcImJsb2JcIiBpbiBtYXliZVJlc291cmNlICYmIHR5cGVvZiAobWF5YmVSZXNvdXJjZSBhcyBCbG9iUmVzb3VyY2VDb250ZW50cykuYmxvYiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBtYXliZVJlc291cmNlIGFzIEJsb2JSZXNvdXJjZUNvbnRlbnRzO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSG9tZSgpIHtcbiAgY29uc3QgW3dzU3RhdHVzLCBzZXRXc1N0YXR1c10gPSB1c2VTdGF0ZTxcImNvbm5lY3RpbmdcIiB8IFwib3BlblwiIHwgXCJjbG9zZWRcIj4oXCJjb25uZWN0aW5nXCIpO1xuICBjb25zdCBbdG9kb3MsIHNldFRvZG9zXSA9IHVzZVN0YXRlPFRvZG9bXT4oW10pO1xuICBjb25zdCBbbGFzdFBheWxvYWQsIHNldExhc3RQYXlsb2FkXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJcIik7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtpbmZvLCBzZXRJbmZvXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbdWlSZXNvdXJjZSwgc2V0VWlSZXNvdXJjZV0gPSB1c2VTdGF0ZTxSZW5kZXJhYmxlUmVzb3VyY2UgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3VpVmVyc2lvbiwgc2V0VWlWZXJzaW9uXSA9IHVzZVN0YXRlKDApO1xuXG4gIGNvbnN0IHdzUmVmID0gdXNlUmVmPFdlYlNvY2tldCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBjYWxsYmFja3MgPSB1c2VSZWY8TWFwPG51bWJlciwgTWNwUmVzdWx0SGFuZGxlcj4+KG5ldyBNYXAoKSk7XG4gIGNvbnN0IHJlcXVlc3RJZCA9IHVzZVJlZigwKTtcbiAgY29uc3QgcGVuZGluZ1JlcXVlc3RzID0gdXNlUmVmPFBlbmRpbmdSZXF1ZXN0W10+KFtdKTtcblxuICBjb25zdCBjb25uZWN0aW9uTGFiZWwgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBzd2l0Y2ggKHdzU3RhdHVzKSB7XG4gICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICByZXR1cm4gXCJDb25uZWN0ZWRcIjtcbiAgICAgIGNhc2UgXCJjbG9zZWRcIjpcbiAgICAgICAgcmV0dXJuIFwiRGlzY29ubmVjdGVkXCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJDb25uZWN0aW5nXCI7XG4gICAgfVxuICB9LCBbd3NTdGF0dXNdKTtcblxuICBjb25zdCBzZW5kSnNvblJwYyA9IHVzZUNhbGxiYWNrKFxuICAgIChzb2NrZXQ6IFdlYlNvY2tldCwgbWV0aG9kOiBzdHJpbmcsIHBhcmFtczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIGhhbmRsZXI/OiBNY3BSZXN1bHRIYW5kbGVyKSA9PiB7XG4gICAgICBjb25zdCBpZCA9ICsrcmVxdWVzdElkLmN1cnJlbnQ7XG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICBjYWxsYmFja3MuY3VycmVudC5zZXQoaWQsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgaWQsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgfTtcbiAgICAgIHNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICB9LFxuICAgIFtjYWxsYmFja3MsIHJlcXVlc3RJZF1cbiAgKTtcblxuICBjb25zdCBmbHVzaFBlbmRpbmcgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3Qgc29ja2V0ID0gd3NSZWYuY3VycmVudDtcbiAgICBpZiAoIXNvY2tldCB8fCBzb2NrZXQucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2hpbGUgKHBlbmRpbmdSZXF1ZXN0cy5jdXJyZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG5leHQgPSBwZW5kaW5nUmVxdWVzdHMuY3VycmVudC5zaGlmdCgpO1xuICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc2VuZEpzb25ScGMoc29ja2V0LCBuZXh0Lm1ldGhvZCwgbmV4dC5wYXJhbXMsIG5leHQuaGFuZGxlcik7XG4gICAgfVxuICB9LCBbc2VuZEpzb25ScGNdKTtcblxuICBjb25zdCBzZW5kUmVxdWVzdCA9IHVzZUNhbGxiYWNrKFxuICAgIChtZXRob2Q6IHN0cmluZywgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiwgaGFuZGxlcj86IE1jcFJlc3VsdEhhbmRsZXIpID0+IHtcbiAgICAgIGNvbnN0IHNvY2tldCA9IHdzUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIXNvY2tldCB8fCBzb2NrZXQucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgICAgcGVuZGluZ1JlcXVlc3RzLmN1cnJlbnQucHVzaCh7IG1ldGhvZCwgcGFyYW1zLCBoYW5kbGVyIH0pO1xuICAgICAgICBzZXRFcnJvcihcIldlYlNvY2tldCBpcyBub3QgY29ubmVjdGVkIHlldC5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlbmRKc29uUnBjKHNvY2tldCwgbWV0aG9kLCBwYXJhbXMsIGhhbmRsZXIpO1xuICAgIH0sXG4gICAgW3NlbmRKc29uUnBjXVxuICApO1xuXG4gIGNvbnN0IGNhbGxUb29sID0gdXNlQ2FsbGJhY2soXG4gICAgKG5hbWU6IHN0cmluZywgYXJnczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fSwgaGFuZGxlcj86IE1jcFJlc3VsdEhhbmRsZXIpID0+IHtcbiAgICAgIHNlbmRSZXF1ZXN0KFxuICAgICAgICBcInRvb2xzL2NhbGxcIixcbiAgICAgICAge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgYXJndW1lbnRzOiBhcmdzLFxuICAgICAgICB9LFxuICAgICAgICBoYW5kbGVyXG4gICAgICApO1xuICAgIH0sXG4gICAgW3NlbmRSZXF1ZXN0XVxuICApO1xuXG4gIGNvbnN0IGluaXRpYWxpemUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2VuZFJlcXVlc3QoXCJpbml0aWFsaXplXCIsIHt9LCAoKSA9PiB7XG4gICAgICBzZW5kUmVxdWVzdChcInRvb2xzL2xpc3RcIiwge30sIChwYXlsb2FkKSA9PiB7XG4gICAgICAgIHNldExhc3RQYXlsb2FkKEpTT04uc3RyaW5naWZ5KHBheWxvYWQsIG51bGwsIDIpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCBbc2VuZFJlcXVlc3RdKTtcblxuICBjb25zdCBhcHBseVVpUmVzb3VyY2UgPSB1c2VDYWxsYmFjaygobWF5YmVSZXNvdXJjZTogdW5rbm93bikgPT4ge1xuICAgIGNvbnN0IG5leHQgPSBhc1JlbmRlcmFibGVSZXNvdXJjZShtYXliZVJlc291cmNlKTtcbiAgICBpZiAobmV4dCkge1xuICAgICAgc2V0VWlSZXNvdXJjZShuZXh0KTtcbiAgICAgIHNldFVpVmVyc2lvbigocHJldikgPT4gcHJldiArIDEpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIGNvbnN0IGxpc3RUb2RvcyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjYWxsVG9vbChcInRvZG9fbGlzdFwiLCB7fSwgKHBheWxvYWQpID0+IHtcbiAgICAgIHNldFRvZG9zKHBheWxvYWQudG9kb3MgPz8gW10pO1xuICAgICAgYXBwbHlVaVJlc291cmNlKHBheWxvYWQudWkpO1xuICAgIH0pO1xuICB9LCBbY2FsbFRvb2wsIGFwcGx5VWlSZXNvdXJjZV0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgc29ja2V0ID0gbmV3IFdlYlNvY2tldChERUZBVUxUX1dTKTtcbiAgICB3c1JlZi5jdXJyZW50ID0gc29ja2V0O1xuICAgIHNvY2tldC5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICBzZXRXc1N0YXR1cyhcIm9wZW5cIik7XG4gICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgIGZsdXNoUGVuZGluZygpO1xuICAgICAgaW5pdGlhbGl6ZSgpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBsaXN0VG9kb3MoKSwgMjAwKTtcbiAgICB9O1xuICAgIHNvY2tldC5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICBzZXRMYXN0UGF5bG9hZChKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKSk7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YS5pZCA9PT0gXCJudW1iZXJcIiAmJiBjYWxsYmFja3MuY3VycmVudC5oYXMoZGF0YS5pZCkpIHtcbiAgICAgICAgICBjb25zdCBjYiA9IGNhbGxiYWNrcy5jdXJyZW50LmdldChkYXRhLmlkKTtcbiAgICAgICAgICBjYWxsYmFja3MuY3VycmVudC5kZWxldGUoZGF0YS5pZCk7XG4gICAgICAgICAgaWYgKGRhdGEuZXJyb3IpIHtcbiAgICAgICAgICAgIHNldEVycm9yKGRhdGEuZXJyb3IubWVzc2FnZSA/PyBcIlVua25vd24gTUNQIGVycm9yXCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgICAgICAgIGNiKGRhdGEucmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5lcnJvcikge1xuICAgICAgICAgIHNldEVycm9yKGRhdGEuZXJyb3IubWVzc2FnZSA/PyBcIlVua25vd24gTUNQIGVycm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnJlc3VsdD8udG9kb3MpIHtcbiAgICAgICAgICBzZXRUb2RvcyhkYXRhLnJlc3VsdC50b2RvcyBhcyBUb2RvW10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnJlc3VsdD8udG9kbykge1xuICAgICAgICAgIHNldFRvZG9zKChjdXJyZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IGN1cnJlbnQuZmlsdGVyKCh0KSA9PiB0LmlkICE9PSBkYXRhLnJlc3VsdC50b2RvLmlkKTtcbiAgICAgICAgICAgIHJldHVybiBbLi4uZmlsdGVyZWQsIGRhdGEucmVzdWx0LnRvZG8gYXMgVG9kb107XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEucmVzdWx0Py5kZWxldGVkICYmIGRhdGEucmVzdWx0Py5pZCkge1xuICAgICAgICAgIHNldFRvZG9zKChjdXJyZW50KSA9PiBjdXJyZW50LmZpbHRlcigodCkgPT4gdC5pZCAhPT0gZGF0YS5yZXN1bHQuaWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5yZXN1bHQ/LnVpKSB7XG4gICAgICAgICAgYXBwbHlVaVJlc291cmNlKGRhdGEucmVzdWx0LnVpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gcGFyc2UgTUNQIHBheWxvYWRcIiwgZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHNvY2tldC5vbmVycm9yID0gKCkgPT4gc2V0RXJyb3IoXCJXZWJTb2NrZXQgZXJyb3JcIik7XG4gICAgc29ja2V0Lm9uY2xvc2UgPSAoKSA9PiB7XG4gICAgICBzZXRXc1N0YXR1cyhcImNsb3NlZFwiKTtcbiAgICB9O1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgIGNhbGxiYWNrcy5jdXJyZW50LmNsZWFyKCk7XG4gICAgfTtcbiAgfSwgW2luaXRpYWxpemUsIGxpc3RUb2RvcywgZmx1c2hQZW5kaW5nXSk7XG5cbiAgY29uc3QgaGFuZGxlVUlBY3Rpb24gPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAoYWN0aW9uOiBVSUFjdGlvblJlc3VsdCkgPT4ge1xuICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlIFwidG9vbFwiOlxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBjYWxsVG9vbChhY3Rpb24ucGF5bG9hZC50b29sTmFtZSwgYWN0aW9uLnBheWxvYWQucGFyYW1zID8/IHt9LCAoKSA9PiB7XG4gICAgICAgICAgICAgIHNldEluZm8oYEV4ZWN1dGVkICR7YWN0aW9uLnBheWxvYWQudG9vbE5hbWV9YCk7XG4gICAgICAgICAgICAgIGxpc3RUb2RvcygpO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJub3RpZnlcIjpcbiAgICAgICAgICBzZXRJbmZvKGFjdGlvbi5wYXlsb2FkLm1lc3NhZ2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzZXRJbmZvKGBVbmhhbmRsZWQgTUNQLVVJIGFjdGlvbjogJHthY3Rpb24udHlwZX1gKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtjYWxsVG9vbCwgbGlzdFRvZG9zXVxuICApO1xuXG4gIHJldHVybiAoXG4gICAgPG1haW4gc3R5bGU9e3N0eWxlcy5tYWlufT5cbiAgICAgIDxzZWN0aW9uIHN0eWxlPXtzdHlsZXMucGFuZWx9PlxuICAgICAgICA8aGVhZGVyIHN0eWxlPXtzdHlsZXMuaGVhZGVyfT5cbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgPGgxIHN0eWxlPXt7IG1hcmdpbjogMCB9fT5NQ1AgVG9kbyBDb25zb2xlPC9oMT5cbiAgICAgICAgICAgIDxwIHN0eWxlPXt7IG1hcmdpbjogMCwgY29sb3I6IFwiIzZiNzI4MFwiIH19PlxuICAgICAgICAgICAgICBXZWJTb2NrZXQ6IHtjb25uZWN0aW9uTGFiZWx9XG4gICAgICAgICAgICA8L3A+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGJ1dHRvbiBzdHlsZT17c3R5bGVzLnNlY29uZGFyeUJ1dHRvbn0gb25DbGljaz17bGlzdFRvZG9zfT5cbiAgICAgICAgICAgIFJlZnJlc2hcbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9oZWFkZXI+XG5cbiAgICAgICAge2Vycm9yICYmIDxwIHN0eWxlPXtzdHlsZXMuZXJyb3J9PntlcnJvcn08L3A+fVxuICAgICAgICB7aW5mbyAmJiA8cCBzdHlsZT17c3R5bGVzLmluZm99PntpbmZvfTwvcD59XG5cbiAgICAgICAgPHNlY3Rpb24gc3R5bGU9e3N0eWxlcy51aVNlY3Rpb259PlxuICAgICAgICAgIDxoMj5NQ1AtVUkgUmVzb3VyY2U8L2gyPlxuICAgICAgICAgIHt1aVJlc291cmNlID8gKFxuICAgICAgICAgICAgPGRpdiBzdHlsZT17c3R5bGVzLnVpRnJhbWV9PlxuICAgICAgICAgICAgICA8VUlSZXNvdXJjZVJlbmRlcmVyXG4gICAgICAgICAgICAgICAga2V5PXt1aVZlcnNpb259XG4gICAgICAgICAgICAgICAgcmVzb3VyY2U9e3VpUmVzb3VyY2V9XG4gICAgICAgICAgICAgICAgb25VSUFjdGlvbj17aGFuZGxlVUlBY3Rpb259XG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkQ29udGVudFR5cGVzPXtbXCJyYXdIdG1sXCIsIFwiZXh0ZXJuYWxVcmxcIl19XG4gICAgICAgICAgICAgICAgaHRtbFByb3BzPXt7XG4gICAgICAgICAgICAgICAgICBzdHlsZTogeyBib3JkZXI6IFwibm9uZVwiLCB3aWR0aDogXCIxMDAlXCIsIG1pbkhlaWdodDogNTIwIH0sXG4gICAgICAgICAgICAgICAgICBhdXRvUmVzaXplSWZyYW1lOiB7IGhlaWdodDogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgICAgc2FuZGJveFBlcm1pc3Npb25zOiBcImFsbG93LXNjcmlwdHMgYWxsb3ctZm9ybXNcIixcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKSA6IChcbiAgICAgICAgICAgIDxwIHN0eWxlPXt7IGNvbG9yOiBcIiM2YjcyODBcIiB9fT5cbiAgICAgICAgICAgICAgQ2FsbCBhbnkgdG9kbyB0b29sIHRvIGxvYWQgdGhlIE1DUC1VSSBkYXNoYm9hcmQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICl9XG4gICAgICAgIDwvc2VjdGlvbj5cblxuICAgICAgICA8ZGl2IHN0eWxlPXt7IG1hcmdpblRvcDogXCIycmVtXCIgfX0+XG4gICAgICAgICAgPGgyPlRvZG9zPC9oMj5cbiAgICAgICAgICA8ZGl2IHN0eWxlPXtzdHlsZXMudG9kb0xpc3R9PlxuICAgICAgICAgICAge3RvZG9zLmxlbmd0aCA9PT0gMCAmJiA8cD5ObyB0b2RvcyB5ZXQuPC9wPn1cbiAgICAgICAgICAgIHt0b2Rvcy5tYXAoKHRvZG8pID0+IChcbiAgICAgICAgICAgICAgPGFydGljbGUga2V5PXt0b2RvLmlkfSBzdHlsZT17c3R5bGVzLnRvZG9JdGVtfT5cbiAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgPHAgc3R5bGU9e3sgbWFyZ2luOiAwLCBmb250V2VpZ2h0OiA2MDAgfX0+e3RvZG8udGl0bGV9PC9wPlxuICAgICAgICAgICAgICAgICAgPHAgc3R5bGU9e3sgbWFyZ2luOiAwLCBjb2xvcjogXCIjNmI3MjgwXCIsIGZvbnRTaXplOiAxMiB9fT57dG9kby5pZH08L3A+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9e3sgY29sb3I6IHRvZG8uY29tcGxldGVkID8gXCIjMTZhMzRhXCIgOiBcIiNlZjQ0NDRcIiB9fT5cbiAgICAgICAgICAgICAgICAgIHt0b2RvLmNvbXBsZXRlZCA/IFwiRG9uZVwiIDogXCJPcGVuXCJ9XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICA8L2FydGljbGU+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBzdHlsZT17eyBtYXJnaW5Ub3A6IFwiMnJlbVwiIH19PlxuICAgICAgICAgIDxoMj5MYXN0IE1DUCBQYXlsb2FkPC9oMj5cbiAgICAgICAgICA8cHJlIHN0eWxlPXtzdHlsZXMucHJlfT57bGFzdFBheWxvYWQgfHwgXCJXYWl0aW5nIGZvciBtZXNzYWdlcy4uLlwifTwvcHJlPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvc2VjdGlvbj5cbiAgICA8L21haW4+XG4gICk7XG59XG5cbmNvbnN0IHN0eWxlczogUmVjb3JkPHN0cmluZywgUmVhY3QuQ1NTUHJvcGVydGllcz4gPSB7XG4gIG1haW46IHtcbiAgICBtaW5IZWlnaHQ6IFwiMTAwdmhcIixcbiAgICBwYWRkaW5nOiBcIjJyZW1cIixcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgfSxcbiAgcGFuZWw6IHtcbiAgICB3aWR0aDogXCJtaW4oOTYwcHgsIDEwMCUpXCIsXG4gICAgYmFja2dyb3VuZDogXCJ3aGl0ZVwiLFxuICAgIGJvcmRlclJhZGl1czogMTIsXG4gICAgcGFkZGluZzogXCIycmVtXCIsXG4gICAgYm94U2hhZG93OiBcIjAgMjBweCA0NXB4IHJnYmEoMTUsMjMsNDIsMC4xKVwiLFxuICB9LFxuICBoZWFkZXI6IHtcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBqdXN0aWZ5Q29udGVudDogXCJzcGFjZS1iZXR3ZWVuXCIsXG4gICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICBtYXJnaW5Cb3R0b206IFwiMS41cmVtXCIsXG4gIH0sXG4gIHNlY29uZGFyeUJ1dHRvbjoge1xuICAgIGJhY2tncm91bmQ6IFwidHJhbnNwYXJlbnRcIixcbiAgICBib3JkZXI6IFwiMXB4IHNvbGlkICMxMTE4MjdcIixcbiAgICBib3JkZXJSYWRpdXM6IDgsXG4gICAgcGFkZGluZzogXCIwLjVyZW0gMS41cmVtXCIsXG4gICAgZm9udFdlaWdodDogNjAwLFxuICB9LFxuICB1aVNlY3Rpb246IHtcbiAgICBtYXJnaW5Ub3A6IFwiMS41cmVtXCIsXG4gIH0sXG4gIHVpRnJhbWU6IHtcbiAgICBtYXJnaW5Ub3A6IFwiMC43NXJlbVwiLFxuICAgIGJvcmRlclJhZGl1czogMTIsXG4gICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjZTVlN2ViXCIsXG4gICAgbWluSGVpZ2h0OiA1MjAsXG4gIH0sXG4gIHRvZG9MaXN0OiB7XG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICBnYXA6IFwiMC43NXJlbVwiLFxuICB9LFxuICB0b2RvSXRlbToge1xuICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgIGp1c3RpZnlDb250ZW50OiBcInNwYWNlLWJldHdlZW5cIixcbiAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgIHBhZGRpbmc6IFwiMC43NXJlbSAxcmVtXCIsXG4gICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjZTVlN2ViXCIsXG4gICAgYm9yZGVyUmFkaXVzOiAxMCxcbiAgfSxcbiAgcHJlOiB7XG4gICAgYmFja2dyb3VuZDogXCIjMGYxNzJhXCIsXG4gICAgY29sb3I6IFwiI2Y4ZmFmY1wiLFxuICAgIHBhZGRpbmc6IFwiMXJlbVwiLFxuICAgIGJvcmRlclJhZGl1czogMTAsXG4gICAgbWF4SGVpZ2h0OiAyNjAsXG4gICAgb3ZlcmZsb3c6IFwiYXV0b1wiLFxuICB9LFxuICBlcnJvcjoge1xuICAgIGNvbG9yOiBcIiNiOTFjMWNcIixcbiAgICBmb250V2VpZ2h0OiA2MDAsXG4gIH0sXG4gIGluZm86IHtcbiAgICBjb2xvcjogXCIjMGYxNzJhXCIsXG4gICAgZm9udFdlaWdodDogNTAwLFxuICB9LFxufTtcbiJdLCJuYW1lcyI6WyJVSVJlc291cmNlUmVuZGVyZXIiLCJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInByb2Nlc3MiLCJERUZBVUxUX1dTIiwiZW52IiwiTkVYVF9QVUJMSUNfTUNQX1dTX1VSTCIsImFzUmVuZGVyYWJsZVJlc291cmNlIiwicGF5bG9hZCIsIm1heWJlUmVzb3VyY2UiLCJ0eXBlIiwicmVzb3VyY2UiLCJtaW1lVHlwZSIsInRleHQiLCJibG9iIiwiSG9tZSIsIndzU3RhdHVzIiwic2V0V3NTdGF0dXMiLCJ0b2RvcyIsInNldFRvZG9zIiwibGFzdFBheWxvYWQiLCJzZXRMYXN0UGF5bG9hZCIsImVycm9yIiwic2V0RXJyb3IiLCJpbmZvIiwic2V0SW5mbyIsInVpUmVzb3VyY2UiLCJzZXRVaVJlc291cmNlIiwidWlWZXJzaW9uIiwic2V0VWlWZXJzaW9uIiwid3NSZWYiLCJjYWxsYmFja3MiLCJNYXAiLCJyZXF1ZXN0SWQiLCJwZW5kaW5nUmVxdWVzdHMiLCJjb25uZWN0aW9uTGFiZWwiLCJzZW5kSnNvblJwYyIsInNvY2tldCIsIm1ldGhvZCIsInBhcmFtcyIsImhhbmRsZXIiLCJpZCIsImN1cnJlbnQiLCJzZXQiLCJqc29ucnBjIiwic2VuZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJmbHVzaFBlbmRpbmciLCJyZWFkeVN0YXRlIiwiV2ViU29ja2V0IiwiT1BFTiIsImxlbmd0aCIsIm5leHQiLCJzaGlmdCIsInNlbmRSZXF1ZXN0IiwicHVzaCIsImNhbGxUb29sIiwibmFtZSIsImFyZ3MiLCJhcmd1bWVudHMiLCJpbml0aWFsaXplIiwiYXBwbHlVaVJlc291cmNlIiwicHJldiIsImxpc3RUb2RvcyIsInVpIiwib25vcGVuIiwic2V0VGltZW91dCIsIm9ubWVzc2FnZSIsImV2ZW50IiwiZGF0YSIsInBhcnNlIiwiaGFzIiwiY2IiLCJnZXQiLCJkZWxldGUiLCJtZXNzYWdlIiwicmVzdWx0IiwidG9kbyIsImZpbHRlcmVkIiwiZmlsdGVyIiwidCIsImRlbGV0ZWQiLCJlcnIiLCJjb25zb2xlIiwib25lcnJvciIsIm9uY2xvc2UiLCJjbG9zZSIsImNsZWFyIiwiaGFuZGxlVUlBY3Rpb24iLCJhY3Rpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInRvb2xOYW1lIiwibWFpbiIsInN0eWxlIiwic3R5bGVzIiwic2VjdGlvbiIsInBhbmVsIiwiaGVhZGVyIiwiZGl2IiwiaDEiLCJtYXJnaW4iLCJwIiwiY29sb3IiLCJidXR0b24iLCJzZWNvbmRhcnlCdXR0b24iLCJvbkNsaWNrIiwidWlTZWN0aW9uIiwiaDIiLCJ1aUZyYW1lIiwib25VSUFjdGlvbiIsInN1cHBvcnRlZENvbnRlbnRUeXBlcyIsImh0bWxQcm9wcyIsImJvcmRlciIsIndpZHRoIiwibWluSGVpZ2h0IiwiYXV0b1Jlc2l6ZUlmcmFtZSIsImhlaWdodCIsInNhbmRib3hQZXJtaXNzaW9ucyIsIm1hcmdpblRvcCIsInRvZG9MaXN0IiwibWFwIiwiYXJ0aWNsZSIsInRvZG9JdGVtIiwiZm9udFdlaWdodCIsInRpdGxlIiwiZm9udFNpemUiLCJzcGFuIiwiY29tcGxldGVkIiwicHJlIiwicGFkZGluZyIsImRpc3BsYXkiLCJqdXN0aWZ5Q29udGVudCIsImJhY2tncm91bmQiLCJib3JkZXJSYWRpdXMiLCJib3hTaGFkb3ciLCJhbGlnbkl0ZW1zIiwibWFyZ2luQm90dG9tIiwib3ZlcmZsb3ciLCJmbGV4RGlyZWN0aW9uIiwiZ2FwIiwibWF4SGVpZ2h0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz9hMzYwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/M2IxZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../node_modules/process/browser.js":
/*!************************************************!*\
  !*** ../../../node_modules/process/browser.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2JjZmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../node_modules/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@mcp-ui/client/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@mcp-ui/client/dist/index.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UIResourceRenderer: function() { return /* binding */ Ut; },\n/* harmony export */   basicComponentLibrary: function() { return /* binding */ We; },\n/* harmony export */   getResourceMetadata: function() { return /* binding */ rt; },\n/* harmony export */   getUIResourceMetadata: function() { return /* binding */ nt; },\n/* harmony export */   isUIResource: function() { return /* binding */ jt; },\n/* harmony export */   remoteButtonDefinition: function() { return /* binding */ Yt; },\n/* harmony export */   remoteCardDefinition: function() { return /* binding */ Ft; },\n/* harmony export */   remoteImageDefinition: function() { return /* binding */ Wt; },\n/* harmony export */   remoteStackDefinition: function() { return /* binding */ Vt; },\n/* harmony export */   remoteTextDefinition: function() { return /* binding */ Gt; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar Be = Object.defineProperty;\nvar pe = (r) => {\n  throw TypeError(r);\n};\nvar $e = (r, e, t) => e in r ? Be(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;\nvar L = (r, e, t) => $e(r, typeof e != \"symbol\" ? e + \"\" : e, t), oe = (r, e, t) => e.has(r) || pe(\"Cannot \" + t);\nvar b = (r, e, t) => (oe(r, e, \"read from private field\"), t ? t.call(r) : e.get(r)), S = (r, e, t) => e.has(r) ? pe(\"Cannot add the same private member more than once\") : e instanceof WeakSet ? e.add(r) : e.set(r, t), Z = (r, e, t, n) => (oe(r, e, \"write to private field\"), n ? n.call(r, t) : e.set(r, t), t), y = (r, e, t) => (oe(r, e, \"access private method\"), t);\n\n\nconst fe = {\n  PREFERRED_FRAME_SIZE: \"preferred-frame-size\",\n  INITIAL_RENDER_DATA: \"initial-render-data\"\n}, he = \"mcpui.dev/ui-\";\nfunction Qe(r) {\n  let e;\n  try {\n    e = new URL(r);\n  } catch (t) {\n    return console.error(\"Error parsing URL:\", t), !1;\n  }\n  return e.protocol === \"http:\" || e.protocol === \"https:\";\n}\nfunction et(r, e) {\n  if (r.mimeType !== \"text/html\" && r.mimeType !== \"text/uri-list\")\n    return {\n      error: \"Resource must be of type text/html (for HTML content) or text/uri-list (for URL content).\"\n    };\n  if (r.mimeType === \"text/uri-list\") {\n    let t = \"\";\n    if (typeof r.text == \"string\" && r.text.trim() !== \"\")\n      t = r.text;\n    else if (typeof r.blob == \"string\")\n      try {\n        t = new TextDecoder().decode(\n          Uint8Array.from(atob(r.blob), (o) => o.charCodeAt(0))\n        );\n      } catch (o) {\n        return console.error(\"Error decoding base64 blob for URL content:\", o), {\n          error: \"Error decoding URL from blob.\"\n        };\n      }\n    else\n      return {\n        error: \"URL resource expects a non-empty text or blob field containing the URL.\"\n      };\n    if (t.trim() === \"\")\n      return {\n        error: \"URL content is empty.\"\n      };\n    const n = t.split(`\n`).map((o) => o.trim()).filter((o) => o && !o.startsWith(\"#\") && Qe(o));\n    if (n.length === 0)\n      return {\n        error: \"No valid URLs found in uri-list content.\"\n      };\n    n.length > 1 && console.warn(\n      `Multiple URLs found in uri-list content. Using the first URL: \"${n[0]}\". Other URLs ignored:`,\n      n.slice(1)\n    );\n    const s = n[0];\n    if (e && e.trim() !== \"\")\n      try {\n        const o = new URL(e);\n        if (typeof window < \"u\" && o.host === window.location.host)\n          console.error(\n            \"For security, the proxy origin must not be the same as the host origin. Using original URL instead.\"\n          );\n        else\n          return o.searchParams.set(\"url\", s), {\n            iframeSrc: o.toString(),\n            iframeRenderMode: \"src\"\n          };\n      } catch (o) {\n        console.error(\n          `Invalid proxy URL provided: \"${e}\". Falling back to direct URL.`,\n          o instanceof Error ? o.message : String(o)\n        );\n      }\n    return {\n      iframeSrc: s,\n      iframeRenderMode: \"src\"\n    };\n  } else if (r.mimeType === \"text/html\") {\n    let t = \"\";\n    if (typeof r.text == \"string\")\n      t = r.text;\n    else if (typeof r.blob == \"string\")\n      try {\n        t = new TextDecoder().decode(\n          Uint8Array.from(atob(r.blob), (n) => n.charCodeAt(0))\n        );\n      } catch (n) {\n        return console.error(\"Error decoding base64 blob for HTML content:\", n), {\n          error: \"Error decoding HTML content from blob.\"\n        };\n      }\n    else\n      return {\n        error: \"HTML resource requires text or blob content.\"\n      };\n    if (e && e.trim() !== \"\")\n      try {\n        const n = new URL(e);\n        if (typeof window < \"u\" && n.host === window.location.host)\n          console.error(\n            \"For security, the proxy origin must not be the same as the host origin. Using srcDoc rendering instead.\"\n          );\n        else\n          return n.searchParams.set(\"contentType\", \"rawhtml\"), {\n            iframeSrc: n.toString(),\n            iframeRenderMode: \"src\",\n            htmlString: t\n            // Pass HTML so it can be sent to the proxy via postMessage\n          };\n      } catch (n) {\n        console.error(\n          `Invalid proxy URL provided: \"${e}\". Falling back to srcDoc rendering.`,\n          n instanceof Error ? n.message : String(n)\n        );\n      }\n    return {\n      htmlString: t,\n      iframeRenderMode: \"srcDoc\"\n    };\n  } else\n    return {\n      error: \"Unsupported mimeType. Expected text/html or text/uri-list.\"\n    };\n}\nfunction tt(r) {\n  if (typeof r.text == \"string\" && r.text.trim() !== \"\")\n    return {\n      code: r.text\n    };\n  if (typeof r.blob == \"string\")\n    try {\n      return {\n        code: new TextDecoder().decode(\n          Uint8Array.from(atob(r.blob), (t) => t.charCodeAt(0))\n        )\n      };\n    } catch (e) {\n      return console.error(\"Error decoding base64 blob for remote DOM content:\", e), {\n        error: \"Error decoding remote DOM content from blob.\"\n      };\n    }\n  return {\n    error: \"Remote DOM resource requires non-empty text or blob content.\"\n  };\n}\nfunction rt(r) {\n  return r._meta ?? {};\n}\nfunction nt(r) {\n  const e = rt(r), t = {};\n  return Object.entries(e).forEach(([n, s]) => {\n    n.startsWith(he) && (t[n.slice(he.length)] = s);\n  }), t;\n}\nconst N = {\n  UI_MESSAGE_RECEIVED: \"ui-message-received\",\n  UI_MESSAGE_RESPONSE: \"ui-message-response\",\n  UI_SIZE_CHANGE: \"ui-size-change\",\n  UI_LIFECYCLE_IFRAME_READY: \"ui-lifecycle-iframe-ready\",\n  UI_LIFECYCLE_IFRAME_RENDER_DATA: \"ui-lifecycle-iframe-render-data\",\n  UI_REQUEST_RENDER_DATA: \"ui-request-render-data\",\n  // Proxy-only lifecycle for outer iframe (distinct from widget readiness)\n  UI_PROXY_IFRAME_READY: \"ui-proxy-iframe-ready\",\n  // Content transport for raw HTML when using proxy\n  UI_HTML_CONTENT: \"ui-html-content\"\n}, ot = {\n  WAIT_FOR_RENDER_DATA: \"waitForRenderData\"\n}, Ne = ({\n  resource: r,\n  onUIAction: e,\n  style: t,\n  proxy: n,\n  iframeRenderData: s,\n  autoResizeIframe: o,\n  sandboxPermissions: a,\n  iframeProps: u\n}) => {\n  const l = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(u == null ? void 0 : u.ref, () => l.current);\n  const { error: f, iframeSrc: i, iframeRenderMode: m, htmlString: d } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(\n    () => et(r, n),\n    [r, n]\n  ), c = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => nt(r), [r]), p = c[fe.PREFERRED_FRAME_SIZE] ?? [\"100%\", \"100%\"], h = c[fe.INITIAL_RENDER_DATA] ?? void 0, E = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    if (!(!s && !h))\n      return {\n        ...h,\n        ...s\n      };\n  }, [s, h]), _ = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    if (i && E) {\n      const T = new URL(i);\n      return T.searchParams.set(ot.WAIT_FOR_RENDER_DATA, \"true\"), T.toString();\n    }\n    return i;\n  }, [i, E]), R = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (T) => {\n      var j;\n      if (E) {\n        const I = T.currentTarget.contentWindow, P = _ ? new URL(_).origin : \"*\";\n        U(\n          N.UI_LIFECYCLE_IFRAME_RENDER_DATA,\n          I,\n          P,\n          void 0,\n          {\n            renderData: E\n          }\n        );\n      }\n      (j = u == null ? void 0 : u.onLoad) == null || j.call(u, T);\n    },\n    [E, _, u == null ? void 0 : u.onLoad]\n  ), A = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => m === \"srcDoc\" ? _e(a ?? \"\", \"allow-scripts\") : _e(a ?? \"\", \"allow-scripts allow-same-origin\"), [a, m]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    async function T(j) {\n      const { source: I, origin: P, data: g } = j;\n      if (l.current && I === l.current.contentWindow) {\n        if ((g == null ? void 0 : g.type) === N.UI_PROXY_IFRAME_READY) {\n          m === \"src\" && d && (_ != null && _.includes(\"contentType=rawhtml\")) && U(\n            N.UI_HTML_CONTENT,\n            I,\n            P,\n            void 0,\n            {\n              html: d,\n              sandbox: A\n            }\n          );\n          return;\n        }\n        if ((g == null ? void 0 : g.type) === N.UI_LIFECYCLE_IFRAME_READY) {\n          E && U(\n            N.UI_LIFECYCLE_IFRAME_RENDER_DATA,\n            I,\n            P,\n            void 0,\n            {\n              renderData: E\n            }\n          );\n          return;\n        }\n        if ((g == null ? void 0 : g.type) === N.UI_REQUEST_RENDER_DATA) {\n          U(\n            N.UI_LIFECYCLE_IFRAME_RENDER_DATA,\n            I,\n            P,\n            g.messageId,\n            {\n              renderData: E\n            }\n          );\n          return;\n        }\n        if ((g == null ? void 0 : g.type) === N.UI_SIZE_CHANGE) {\n          const { width: F, height: C } = g.payload;\n          if (o && l.current) {\n            const He = (typeof o == \"boolean\" || o.height) && C, qe = (typeof o == \"boolean\" || o.width) && F;\n            He && (l.current.style.height = `${C}px`), qe && (l.current.style.width = `${F}px`);\n          }\n          return;\n        }\n        const ne = g;\n        if (!ne)\n          return;\n        if (e) {\n          const F = ne.messageId;\n          U(N.UI_MESSAGE_RECEIVED, I, P, F);\n          try {\n            const C = await e(ne);\n            U(N.UI_MESSAGE_RESPONSE, I, P, F, {\n              response: C\n            });\n          } catch (C) {\n            console.error(\"Error handling UI action result in HTMLResourceRenderer:\", C), U(N.UI_MESSAGE_RESPONSE, I, P, F, {\n              error: C\n            });\n          }\n        }\n      }\n    }\n    return window.addEventListener(\"message\", T), () => window.removeEventListener(\"message\", T);\n  }, [e, E, m, d, _, A]), f ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", { className: \"text-red-500\", children: f }) : m === \"srcDoc\" ? d == null ? f ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", { className: \"text-orange-500\", children: \"No HTML content to display.\" }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    \"iframe\",\n    {\n      srcDoc: d,\n      sandbox: A,\n      style: { width: p[0], height: p[1], ...t },\n      title: \"MCP HTML Resource (Embedded Content)\",\n      ...u,\n      ref: l,\n      onLoad: R\n    }\n  ) : m === \"src\" ? _ == null ? f ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", { className: \"text-orange-500\", children: \"No URL provided for HTML resource.\" }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    \"iframe\",\n    {\n      src: _,\n      sandbox: A,\n      style: { width: p[0], height: p[1], ...t },\n      title: \"MCP HTML Resource (URL)\",\n      ...u,\n      ref: l,\n      onLoad: R\n    }\n  ) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", { className: \"text-gray-500\", children: \"Initializing HTML resource display...\" });\n};\nNe.displayName = \"HTMLResourceRenderer\";\nfunction U(r, e, t, n, s) {\n  const o = t && t !== \"null\" ? t : \"*\";\n  e == null || e.postMessage(\n    {\n      type: r,\n      messageId: n ?? void 0,\n      payload: s\n    },\n    o\n  );\n}\nfunction _e(r, e) {\n  return [.../* @__PURE__ */ new Set([...r.split(\" \"), ...e.split(\" \")])].filter(Boolean).map((t) => t.trim()).join(\" \");\n}\nconst Ie = 1, Pe = 3, Oe = 8, it = 9, st = 0, at = 1, lt = 2, ct = 3, $ = 1, de = 2, ue = 3, q = \"~\";\nfunction De({\n  call: r,\n  insertChild: e,\n  removeChild: t,\n  updateText: n,\n  updateProperty: s\n}) {\n  const o = {\n    [st]: e,\n    [at]: t,\n    [lt]: n,\n    [ct]: s\n  };\n  return {\n    call: r,\n    mutate(a) {\n      for (const [u, ...l] of a)\n        o[u](...l);\n    }\n  };\n}\nclass dt {\n  constructor({\n    retain: e,\n    release: t,\n    methods: n\n  } = {}) {\n    /**\n     * Represents the root node of the remote tree. This node is always defined,\n     * and you will likely be most interested in its `children` property, which\n     * contains the top-level elements of the remote tree.\n     */\n    L(this, \"root\", {\n      id: q,\n      type: it,\n      children: [],\n      version: 0,\n      properties: {},\n      attributes: {},\n      eventListeners: {}\n    });\n    /**\n     * An object that can synchronize a tree of elements between two JavaScript\n     * environments. This object acts as a thin waist, allowing for efficient\n     * communication of changes between a remote environment (usually, a JavaScript\n     * sandbox, such as an `iframe` or Web Worker) and a host environment\n     * (usually, a top-level browser page).\n     */\n    L(this, \"attached\", /* @__PURE__ */ new Map([[q, this.root]]));\n    L(this, \"subscribers\", /* @__PURE__ */ new Map());\n    L(this, \"parents\", /* @__PURE__ */ new Map());\n    L(this, \"implementations\", /* @__PURE__ */ new Map());\n    const {\n      attached: s,\n      parents: o,\n      subscribers: a\n    } = this;\n    this.connection = De({\n      call: (i, m, ...d) => {\n        const c = this.implementations.get(i), p = c == null ? void 0 : c[m];\n        if (typeof p != \"function\")\n          throw new Error(`Node ${i} does not implement the ${m}() method`);\n        return p(...d);\n      },\n      insertChild: (i, m, d) => {\n        const c = s.get(i), {\n          children: p\n        } = c, h = l(m, c);\n        d === p.length ? p.push(h) : p.splice(d, 0, h), c.version += 1, this.parents.set(m.id, c.id), u(c);\n      },\n      removeChild: (i, m) => {\n        const d = s.get(i), {\n          children: c\n        } = d, [p] = c.splice(m, 1);\n        p && (d.version += 1, u(d), f(p));\n      },\n      updateProperty: (i, m, d, c = $) => {\n        const p = s.get(i);\n        e == null || e(d);\n        let h;\n        switch (c) {\n          case $:\n            h = p.properties;\n            break;\n          case de:\n            h = p.attributes;\n            break;\n          case ue:\n            h = p.eventListeners;\n            break;\n        }\n        const E = h[m];\n        h[m] = d, p.version += 1;\n        let _;\n        if (m === \"slot\") {\n          const R = this.parents.get(i);\n          _ = R == null ? R : s.get(R), _ && (_.version += 1);\n        }\n        u(p), _ && u(_), t == null || t(E);\n      },\n      updateText: (i, m) => {\n        const d = s.get(i);\n        d.data = m, d.version += 1, u(d);\n      }\n    }), n && this.implement(this.root, n);\n    function u(i) {\n      const m = a.get(i.id);\n      if (m)\n        for (const d of m)\n          d(i);\n    }\n    function l(i, m) {\n      let d;\n      switch (i.type) {\n        case Pe:\n        case Oe: {\n          const {\n            id: c,\n            type: p,\n            data: h\n          } = i;\n          d = {\n            id: c,\n            type: p,\n            data: h,\n            version: 0\n          };\n          break;\n        }\n        case Ie: {\n          const {\n            id: c,\n            type: p,\n            element: h,\n            children: E,\n            properties: _,\n            attributes: R,\n            eventListeners: A\n          } = i;\n          e == null || e(_), e == null || e(A);\n          const T = [];\n          d = {\n            id: c,\n            type: p,\n            element: h,\n            version: 0,\n            children: T,\n            properties: {\n              ..._\n            },\n            attributes: {\n              ...R\n            },\n            eventListeners: {\n              ...A\n            }\n          };\n          for (const j of E)\n            T.push(l(j, d));\n          break;\n        }\n        default:\n          throw new Error(`Unknown node type: ${JSON.stringify(i)}`);\n      }\n      return s.set(d.id, d), o.set(d.id, m.id), d;\n    }\n    function f(i) {\n      if (s.delete(i.id), o.delete(i.id), t && (\"properties\" in i && t(i.properties), \"eventListeners\" in i && t(i.eventListeners)), \"children\" in i)\n        for (const m of i.children)\n          f(m);\n    }\n  }\n  /**\n   * Fetches the latest state of a remote element that has been\n   * received from the remote environment.\n   *\n   * @param node The remote node to fetch.\n   * @returns The current state of the remote node, or `undefined` if the node is not connected to the remote tree.\n   *\n   * @example\n   * import {RemoteReceiver} from '@remote-dom/core/receivers';\n   *\n   * const receiver = new RemoteReceiver();\n   *\n   * receiver.get(receiver.root) === receiver.root; // true\n   */\n  get({\n    id: e\n  }) {\n    return this.attached.get(e);\n  }\n  /**\n   * Lets you define how [remote methods](https://github.com/Shopify/remote-dom/blob/main/packages/core#remotemethods)\n   * are implemented for a particular element in the tree.\n   *\n   * @param node The remote node to subscribe for changes.\n   * @param implementation A record containing the methods to expose for the passed node.\n   *\n   * @example\n   * // In the host environment:\n   * import {RemoteReceiver} from '@remote-dom/core/receivers';\n   *\n   * const receiver = new RemoteReceiver();\n   *\n   * receiver.implement(receiver.root, {\n   *   alert(message) {\n   *     window.alert(message);\n   *   },\n   * });\n   *\n   * // In the remote environment:\n   * import {RemoteRootElement} from '@remote-dom/core/elements';\n   *\n   * customElements.define('remote-root', RemoteRootElement);\n   *\n   * const root = document.createElement('remote-root');\n   * root.connect(receiver.connection);\n   *\n   * root.callRemoteMethod('alert', 'Hello, world!');\n   */\n  implement({\n    id: e\n  }, t) {\n    t == null ? this.implementations.delete(e) : this.implementations.set(e, t);\n  }\n  /**\n   * Allows you to subscribe to changes in a remote element. This includes\n   * changes to the remote elements properties and list of children, but\n   * note that you will not receive updates for properties or children of\n   * _nested_ elements.\n   *\n   * @param node The remote node to subscribe for changes.\n   * @param subscriber A function that will be called with the updated node on each change.\n   *\n   * @example\n   * import {RemoteReceiver} from '@remote-dom/core/receivers';\n   *\n   * const abort = new AbortController();\n   * const receiver = new RemoteReceiver();\n   *\n   * // Subscribe to all changes in the top-level children, attached\n   * // directly to the remote root.\n   * receiver.subscribe(\n   *   receiver.root,\n   *   (root) => {\n   *     console.log('Root changed!', root);\n   *   },\n   *   {signal: abort.signal},\n   * );\n   */\n  subscribe({\n    id: e\n  }, t, {\n    signal: n\n  } = {}) {\n    let s = this.subscribers.get(e);\n    s == null && (s = /* @__PURE__ */ new Set(), this.subscribers.set(e, s)), s.add(t), n == null || n.addEventListener(\"abort\", () => {\n      s.delete(t), s.size === 0 && this.subscribers.delete(e);\n    });\n  }\n}\nconst Ee = /* @__PURE__ */ new WeakMap(), X = /* @__PURE__ */ new WeakMap(), Ce = /* @__PURE__ */ new WeakMap();\nclass ut {\n  constructor({\n    root: e,\n    retain: t,\n    release: n,\n    call: s,\n    cache: o\n  } = {}) {\n    /**\n     * The root element that will contain the host implementations of\n     * all nodes attached to the remote tree. To connect the receiver to\n     * a new element, call the `connect()` method.\n     */\n    /**\n     * An object that can synchronize a tree of elements between two JavaScript\n     * environments. This object acts as a thin waist, allowing for efficient\n     * communication of changes between a remote environment (usually, a JavaScript\n     * sandbox, such as an `iframe` or Web Worker) and a host environment\n     * (usually, a top-level browser page).\n     */\n    L(this, \"attached\", /* @__PURE__ */ new Map());\n    this.root = e ?? document.createDocumentFragment();\n    const {\n      attached: a\n    } = this, u = /* @__PURE__ */ new Map();\n    this.connection = De({\n      call: (i, m, ...d) => {\n        const c = i === q && this.root.nodeType !== 11 ? this.root : a.get(i);\n        return s ? s(c, m, ...d) : c[m](...d);\n      },\n      insertChild: (i, m, d) => {\n        const c = i === q ? this.root : a.get(i), p = u.get(i);\n        p && clearTimeout(p), c.insertBefore(l(m), c.childNodes[d] || null);\n      },\n      removeChild: (i, m) => {\n        const c = (i === q ? this.root : a.get(i)).childNodes[m];\n        if (c.remove(), o != null && o.maxAge) {\n          const p = u.get(i);\n          p && clearTimeout(p);\n          const h = setTimeout(() => {\n            f(c);\n          }, o.maxAge);\n          u.set(i, h);\n        } else\n          f(c);\n      },\n      updateProperty: (i, m, d, c = $) => {\n        const p = a.get(i);\n        t == null || t(d);\n        const h = X.get(p), E = h[m];\n        h[m] = d, J(p, m, d, c), n == null || n(E);\n      },\n      updateText: (i, m) => {\n        const d = a.get(i);\n        d.data = m;\n      }\n    });\n    function l(i) {\n      const m = a.get(i.id);\n      if (m) return m;\n      let d;\n      switch (i.type) {\n        case Ie: {\n          if (d = document.createElement(i.element), i.properties) {\n            X.set(d, i.properties);\n            for (const c of Object.keys(i.properties)) {\n              const p = i.properties[c];\n              t == null || t(p), J(d, c, p, $);\n            }\n          } else\n            X.set(d, {});\n          if (i.attributes)\n            for (const c of Object.keys(i.attributes)) {\n              const p = i.attributes[c];\n              t == null || t(p), J(d, c, p, de);\n            }\n          if (Ce.set(d, {}), i.eventListeners)\n            for (const c of Object.keys(i.eventListeners)) {\n              const p = i.eventListeners[c];\n              t == null || t(p), J(d, c, p, ue);\n            }\n          for (const c of i.children)\n            d.appendChild(l(c));\n          break;\n        }\n        case Pe: {\n          d = document.createTextNode(i.data);\n          break;\n        }\n        case Oe: {\n          d = document.createComment(i.data);\n          break;\n        }\n        default:\n          throw new Error(`Unknown node type: ${JSON.stringify(i)}`);\n      }\n      return Ee.set(d, i.id), a.set(i.id, d), d;\n    }\n    function f(i) {\n      const m = Ee.get(i);\n      m && a.delete(m);\n      const d = X.get(i);\n      if (d && n && n(d), i instanceof Element)\n        for (const c of i.childNodes)\n          f(c);\n    }\n  }\n  /**\n   * Connects the receiver to a new root element. The representation of\n   * any child elements of the remote root will be appended to this node\n   * as children, and the `root` property will be updated to point to the\n   * new element.\n   */\n  connect(e) {\n    const t = this.root;\n    this.root = e, t.childNodes.forEach((n) => {\n      e.appendChild(n);\n    });\n  }\n  /**\n   * Disconnects the receiver from its current root element. Any current\n   * children of the root element will be moved to a `DocumentFragment`\n   * instead, so they can be re-attached to a new element later.\n   */\n  disconnect() {\n    if (this.root.nodeType === 11) return this.root;\n    const e = this.root, t = new DocumentFragment();\n    return this.root = t, e.childNodes.forEach((n) => {\n      t.appendChild(n);\n    }), t;\n  }\n}\nfunction J(r, e, t, n) {\n  switch (n) {\n    case $: {\n      r[e] = t;\n      break;\n    }\n    case de: {\n      t == null ? r.removeAttribute(e) : r.setAttribute(e, t);\n      break;\n    }\n    case ue: {\n      const s = Ce.get(r), o = s == null ? void 0 : s[e];\n      if (o && r.removeEventListener(e, o), t != null) {\n        const a = (u) => {\n          var f;\n          if (u.target !== r) return;\n          const l = t(u.detail);\n          (f = u.resolve) == null || f.call(u, l);\n        };\n        s && (s[e] = a), r.addEventListener(e, a);\n      }\n      break;\n    }\n  }\n}\nfunction me(r, e) {\n  const [t, n] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(() => {\n    const o = e.get(r);\n    return {\n      id: r.id,\n      version: o == null ? void 0 : o.version,\n      value: o,\n      receiver: e\n    };\n  });\n  let s = t.value;\n  if (t.receiver !== e || t.id !== r.id) {\n    const o = e.get(r);\n    s = o, n({\n      receiver: e,\n      id: r.id,\n      version: o == null ? void 0 : o.version,\n      value: s\n    });\n  }\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useDebugValue)(s), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const o = new AbortController(), a = () => {\n      o.signal.aborted || n((u) => {\n        const {\n          id: l,\n          version: f,\n          receiver: i\n        } = u, {\n          id: m\n        } = r;\n        if (i !== e || l !== m)\n          return u;\n        const d = e.get(r), c = d == null ? void 0 : d.version;\n        return f === c ? u : {\n          receiver: e,\n          value: d,\n          id: m,\n          version: c\n        };\n      });\n    };\n    return e.subscribe(r, a, {\n      signal: o.signal\n    }), a(), () => {\n      o.abort();\n    };\n  }, [e, r.id]), s;\n}\nfunction mt({\n  remote: r,\n  receiver: e\n}) {\n  const t = me(r, e);\n  return t ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n    children: t.data\n  }) : null;\n}\nfunction se(r, {\n  receiver: e,\n  components: t\n}) {\n  switch (r.type) {\n    case 1: {\n      const n = t.get(r.element);\n      if (n == null)\n        throw new Error(`No component found for remote element: ${r.element}`);\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(n, {\n        element: r,\n        receiver: e,\n        components: t\n      }, r.id);\n    }\n    case 3:\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(mt, {\n        remote: r,\n        receiver: e\n      }, r.id);\n    case 8:\n      return null;\n    default:\n      throw new Error(`Unknown remote node type: ${String(r)}`);\n  }\n}\nfunction pt(r, e) {\n  if (!r) return;\n  const {\n    children: t,\n    properties: n,\n    attributes: s,\n    eventListeners: o\n  } = r, a = [], u = {\n    ...n,\n    ...s,\n    children: a\n  };\n  if (e.eventProps)\n    for (const [l, f] of Object.entries(e.eventProps)) {\n      const i = f == null ? void 0 : f.event;\n      if (i == null) continue;\n      const m = o[i];\n      m && (u[l] = be(m));\n    }\n  else\n    for (const [l, f] of Object.entries(o))\n      u[`on${l[0].toUpperCase()}${l.slice(1)}`] = be(f);\n  for (const l of t)\n    if (l.type === 1 && typeof l.attributes.slot == \"string\") {\n      const f = l.attributes.slot, i = se(l, e);\n      u[f] = u[f] ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [u[f], i]\n      }) : i;\n    } else\n      a.push(se(l, e));\n  return u;\n}\nfunction be(r) {\n  return function(...t) {\n    if (t.length === 1 && t[0] instanceof Event) {\n      const n = t[0];\n      return n.target !== n.currentTarget ? void 0 : \"detail\" in n ? r(n.detail) : r();\n    }\n    return r(...t);\n  };\n}\nconst ft = Symbol.for(\"remote-dom.element\"), ht = Symbol.for(\"remote-dom.element.attached\");\nfunction _t(r, {\n  name: e,\n  eventProps: t\n} = {}) {\n  const n = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(function({\n    element: o,\n    receiver: a,\n    components: u\n  }) {\n    const l = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(), f = me(o, a), i = f ?? o, m = i.id, d = pt(i, {\n      receiver: a,\n      components: u,\n      eventProps: t\n    });\n    if (d[ft] = i, d[ht] = f != null, l.current == null) {\n      const c = {\n        id: m,\n        receiver: a\n      };\n      c.instanceRef = Et(c), l.current = c;\n    }\n    return l.current.id = m, l.current.receiver = a, (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n      var p;\n      const c = {\n        id: m\n      };\n      return a.implement(c, (p = l.current) == null ? void 0 : p.instanceRef.current), () => {\n        a.implement(c, null);\n      };\n    }, [m, a]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(r, {\n      ref: l.current.instanceRef,\n      ...d\n    });\n  });\n  return n.displayName = e ?? `RemoteComponentRenderer(${r.displayName ?? r.name ?? \"Component\"})`, n;\n}\nfunction Et(r) {\n  let e = null;\n  return {\n    get current() {\n      return e;\n    },\n    set current(t) {\n      e = t, r.receiver.implement(r, t);\n    }\n  };\n}\nfunction bt(r) {\n  const {\n    receiver: e\n  } = r, {\n    children: t\n  } = me(e.root, e);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n    children: t.map((n) => se(n, r))\n  });\n}\nconst vt = `<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n</head>\n<body>\n  <div id=\"root\"></div>\n  <script>\n\"use strict\";\n(() => {\n  var __defProp = Object.defineProperty;\n  var __typeError = (msg) => {\n    throw TypeError(msg);\n  };\n  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\n  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\n  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\n  var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n  var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\n  var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\n\n  // ../../../node_modules/.pnpm/@remote-dom+core@1.8.1_@preact+signals-core@1.10.0/node_modules/@remote-dom/core/build/esm/elements/RemoteEvent.mjs\n  var RemoteEvent = class extends CustomEvent {\n    /**\n     * The last value received from a \\`respondWith()\\` call.\n     */\n    /**\n     * Provides the \\`response\\` value to be sent as the return value for\n     * the remote property function that triggered this event.\n     */\n    respondWith(response) {\n      this.response = response;\n    }\n  };\n\n  // ../../../node_modules/.pnpm/@remote-dom+core@1.8.1_@preact+signals-core@1.10.0/node_modules/@remote-dom/core/build/esm/constants.mjs\n  var MUTATION_TYPE_INSERT_CHILD = 0;\n  var MUTATION_TYPE_REMOVE_CHILD = 1;\n  var MUTATION_TYPE_UPDATE_TEXT = 2;\n  var MUTATION_TYPE_UPDATE_PROPERTY = 3;\n  var UPDATE_PROPERTY_TYPE_PROPERTY = 1;\n  var UPDATE_PROPERTY_TYPE_ATTRIBUTE = 2;\n  var UPDATE_PROPERTY_TYPE_EVENT_LISTENER = 3;\n  var ROOT_ID = \"~\";\n\n  // ../../../node_modules/.pnpm/@remote-dom+core@1.8.1_@preact+signals-core@1.10.0/node_modules/@remote-dom/core/build/esm/elements/internals.mjs\n  var REMOTE_CONNECTIONS = /* @__PURE__ */ new WeakMap();\n  var REMOTE_IDS = /* @__PURE__ */ new WeakMap();\n  var id = 0;\n  function remoteId(node) {\n    let remoteID = REMOTE_IDS.get(node);\n    if (remoteID == null) {\n      remoteID = String(id++);\n      REMOTE_IDS.set(node, remoteID);\n    }\n    return remoteID;\n  }\n  var REMOTE_PROPERTIES = /* @__PURE__ */ new WeakMap();\n  function remoteProperties(node) {\n    return REMOTE_PROPERTIES.get(node);\n  }\n  var REMOTE_ATTRIBUTES = /* @__PURE__ */ new WeakMap();\n  function remoteAttributes(node) {\n    let attributes = REMOTE_ATTRIBUTES.get(node);\n    if (attributes != null) return attributes;\n    if (!(node instanceof Element) || node.tagName.includes(\"-\")) return void 0;\n    attributes = {};\n    for (const {\n      name,\n      value\n    } of node.attributes) {\n      attributes[name] = value;\n    }\n    return attributes;\n  }\n  var REMOTE_EVENT_LISTENERS = /* @__PURE__ */ new WeakMap();\n  function remoteEventListeners(node) {\n    return REMOTE_EVENT_LISTENERS.get(node);\n  }\n  function updateRemoteElementProperty(node, property, value) {\n    let properties = REMOTE_PROPERTIES.get(node);\n    if (properties == null) {\n      properties = {};\n      REMOTE_PROPERTIES.set(node, properties);\n    }\n    if (properties[property] === value) return;\n    properties[property] = value;\n    const connection = REMOTE_CONNECTIONS.get(node);\n    if (connection == null) return;\n    connection.mutate([[MUTATION_TYPE_UPDATE_PROPERTY, remoteId(node), property, value, UPDATE_PROPERTY_TYPE_PROPERTY]]);\n  }\n  function updateRemoteElementAttribute(node, attribute, value) {\n    let attributes = REMOTE_ATTRIBUTES.get(node);\n    if (attributes == null) {\n      attributes = {};\n      REMOTE_ATTRIBUTES.set(node, attributes);\n    }\n    if (attributes[attribute] === value) return;\n    if (value == null) {\n      delete attributes[attribute];\n    } else {\n      attributes[attribute] = String(value);\n    }\n    const connection = REMOTE_CONNECTIONS.get(node);\n    if (connection == null) return;\n    connection.mutate([[MUTATION_TYPE_UPDATE_PROPERTY, remoteId(node), attribute, value, UPDATE_PROPERTY_TYPE_ATTRIBUTE]]);\n  }\n  function updateRemoteElementEventListener(node, event, listener) {\n    let eventListeners = REMOTE_EVENT_LISTENERS.get(node);\n    if (eventListeners == null) {\n      eventListeners = {};\n      REMOTE_EVENT_LISTENERS.set(node, eventListeners);\n    }\n    if (eventListeners[event] === listener) return;\n    if (listener == null) {\n      delete eventListeners[event];\n    } else {\n      eventListeners[event] = listener;\n    }\n    const connection = REMOTE_CONNECTIONS.get(node);\n    if (connection == null) return;\n    connection.mutate([[MUTATION_TYPE_UPDATE_PROPERTY, remoteId(node), event, listener, UPDATE_PROPERTY_TYPE_EVENT_LISTENER]]);\n  }\n  function connectRemoteNode(node, connection) {\n    const existingConnection = REMOTE_CONNECTIONS.get(node);\n    if (existingConnection === connection) return;\n    REMOTE_CONNECTIONS.set(node, connection);\n    if (node.childNodes) {\n      for (let i = 0; i < node.childNodes.length; i++) {\n        connectRemoteNode(node.childNodes[i], connection);\n      }\n    }\n  }\n  function disconnectRemoteNode(node) {\n    const existingConnection = REMOTE_CONNECTIONS.get(node);\n    if (existingConnection == null) return;\n    REMOTE_CONNECTIONS.delete(node);\n    if (node.childNodes) {\n      for (let i = 0; i < node.childNodes.length; i++) {\n        disconnectRemoteNode(node.childNodes[i]);\n      }\n    }\n  }\n  function serializeRemoteNode(node) {\n    const {\n      nodeType\n    } = node;\n    switch (nodeType) {\n      // Element\n      case 1: {\n        return {\n          id: remoteId(node),\n          type: nodeType,\n          element: node.localName,\n          properties: cloneMaybeObject(remoteProperties(node)),\n          attributes: cloneMaybeObject(remoteAttributes(node)),\n          eventListeners: cloneMaybeObject(remoteEventListeners(node)),\n          children: Array.from(node.childNodes).map(serializeRemoteNode)\n        };\n      }\n      // TextNode\n      case 3:\n      // Comment\n      // eslint-disable-next-line no-fallthrough\n      case 8: {\n        return {\n          id: remoteId(node),\n          type: nodeType,\n          data: node.data\n        };\n      }\n      default: {\n        throw new Error(\\`Cannot serialize node of type \\${node.nodeType} (\\${typeof node.nodeType})\\`);\n      }\n    }\n  }\n  function cloneMaybeObject(maybeObject) {\n    return maybeObject ? {\n      ...maybeObject\n    } : void 0;\n  }\n  function callRemoteElementMethod(node, method, ...args) {\n    const id2 = REMOTE_IDS.get(node);\n    const connection = REMOTE_CONNECTIONS.get(node);\n    if (id2 == null || connection == null) {\n      throw new Error(\\`Cannot call method \\${method} on an unconnected node\\`);\n    }\n    return connection.call(id2, method, ...args);\n  }\n\n  // ../../../node_modules/.pnpm/@remote-dom+core@1.8.1_@preact+signals-core@1.10.0/node_modules/@remote-dom/core/build/esm/elements/RemoteElement.mjs\n  var EMPTY_DEFINITION = Object.freeze({});\n  var RemoteElement = class extends HTMLElement {\n    static get observedAttributes() {\n      return this.finalize().__observedAttributes;\n    }\n    /**\n     * The resolved property definitions for this remote element.\n     */\n    static get remotePropertyDefinitions() {\n      return this.finalize().__remotePropertyDefinitions;\n    }\n    /**\n     * The resolved attribute definitions for this remote element.\n     */\n    static get remoteAttributeDefinitions() {\n      return this.finalize().__remoteAttributeDefinitions;\n    }\n    /**\n     * The resolved event listener definitions for this remote element.\n     */\n    static get remoteEventDefinitions() {\n      return this.finalize().__remoteEventDefinitions;\n    }\n    /**\n     * The resolved slot definitions for this remote element.\n     */\n    static get remoteSlotDefinitions() {\n      return this.finalize().__remoteSlotDefinitions;\n    }\n    /**\n     * Creates a new definition for a property that will be synchronized between\n     * this remote element and its host representation.\n     */\n    static createProperty(name, definition) {\n      saveRemoteProperty(name, definition, this.observedAttributes, this.remotePropertyDefinitions, this.__attributeToPropertyMap, this.__eventToPropertyMap);\n    }\n    /**\n     * Consumes all the static members defined on the class and converts them\n     * into the internal representation used to handle properties, attributes,\n     * and event listeners.\n     */\n    static finalize() {\n      if (this.hasOwnProperty(\"__finalized\")) {\n        return this;\n      }\n      this.__finalized = true;\n      const {\n        slottable,\n        remoteSlots,\n        remoteProperties: remoteProperties2,\n        remoteAttributes: remoteAttributes2,\n        remoteEvents,\n        remoteMethods\n      } = this;\n      const SuperConstructor = Object.getPrototypeOf(this);\n      const observedAttributes = /* @__PURE__ */ new Set();\n      if (slottable) observedAttributes.add(\"slot\");\n      const attributeToPropertyMap = /* @__PURE__ */ new Map();\n      const eventToPropertyMap = /* @__PURE__ */ new Map();\n      const remoteSlotDefinitions = /* @__PURE__ */ new Map();\n      const remotePropertyDefinitions = /* @__PURE__ */ new Map();\n      const remoteAttributeDefinitions = /* @__PURE__ */ new Map();\n      const remoteEventDefinitions = /* @__PURE__ */ new Map();\n      if (typeof SuperConstructor.finalize === \"function\") {\n        SuperConstructor.finalize();\n        SuperConstructor.observedAttributes.forEach((attribute) => {\n          observedAttributes.add(attribute);\n        });\n        SuperConstructor.remotePropertyDefinitions.forEach((definition, property) => {\n          remotePropertyDefinitions.set(property, definition);\n        });\n        SuperConstructor.remoteAttributeDefinitions.forEach((definition, event) => {\n          remoteAttributeDefinitions.set(event, definition);\n        });\n        SuperConstructor.remoteEventDefinitions.forEach((definition, event) => {\n          remoteEventDefinitions.set(event, definition);\n        });\n        SuperConstructor.remoteSlotDefinitions.forEach((definition, slot) => {\n          remoteSlotDefinitions.set(slot, definition);\n        });\n      }\n      if (remoteSlots != null) {\n        const slotNames = Array.isArray(remoteSlots) ? remoteSlots : Object.keys(remoteSlots);\n        slotNames.forEach((slotName) => {\n          remoteSlotDefinitions.set(slotName, EMPTY_DEFINITION);\n        });\n      }\n      if (remoteProperties2 != null) {\n        if (Array.isArray(remoteProperties2)) {\n          remoteProperties2.forEach((propertyName) => {\n            saveRemoteProperty(propertyName, void 0, observedAttributes, remotePropertyDefinitions, attributeToPropertyMap, eventToPropertyMap);\n          });\n        } else {\n          Object.keys(remoteProperties2).forEach((propertyName) => {\n            saveRemoteProperty(propertyName, remoteProperties2[propertyName], observedAttributes, remotePropertyDefinitions, attributeToPropertyMap, eventToPropertyMap);\n          });\n        }\n      }\n      if (remoteAttributes2 != null) {\n        remoteAttributes2.forEach((attribute) => {\n          remoteAttributeDefinitions.set(attribute, EMPTY_DEFINITION);\n          observedAttributes.add(attribute);\n        });\n      }\n      if (remoteEvents != null) {\n        if (Array.isArray(remoteEvents)) {\n          remoteEvents.forEach((event) => {\n            remoteEventDefinitions.set(event, EMPTY_DEFINITION);\n          });\n        } else {\n          Object.keys(remoteEvents).forEach((event) => {\n            remoteEventDefinitions.set(event, remoteEvents[event]);\n          });\n        }\n      }\n      if (remoteMethods != null) {\n        if (Array.isArray(remoteMethods)) {\n          for (const method of remoteMethods) {\n            this.prototype[method] = function(...args) {\n              return this.callRemoteMethod(method, ...args);\n            };\n          }\n        } else {\n          Object.assign(this, remoteMethods);\n        }\n      }\n      Object.defineProperties(this, {\n        __observedAttributes: {\n          value: [...observedAttributes],\n          enumerable: false\n        },\n        __remoteSlotDefinitions: {\n          value: remoteSlotDefinitions,\n          enumerable: false\n        },\n        __remotePropertyDefinitions: {\n          value: remotePropertyDefinitions,\n          enumerable: false\n        },\n        __remoteAttributeDefinitions: {\n          value: remoteAttributeDefinitions,\n          enumerable: false\n        },\n        __remoteEventDefinitions: {\n          value: remoteEventDefinitions,\n          enumerable: false\n        },\n        __attributeToPropertyMap: {\n          value: attributeToPropertyMap,\n          enumerable: false\n        },\n        __eventToPropertyMap: {\n          value: eventToPropertyMap,\n          enumerable: false\n        }\n      });\n      return this;\n    }\n    // Just need to use these types so TS doesnt lose track of them.\n    /** @internal */\n    /** @internal */\n    /** @internal */\n    /** @internal */\n    constructor() {\n      super();\n      this.constructor.finalize();\n      const propertyDescriptors = {};\n      const initialPropertiesToSet = {};\n      const prototype = Object.getPrototypeOf(this);\n      const ThisClass = this.constructor;\n      for (const [property, description] of ThisClass.remotePropertyDefinitions.entries()) {\n        const aliasedName = description.name;\n        if (prototype.hasOwnProperty(property)) {\n          continue;\n        }\n        if (property === aliasedName) {\n          initialPropertiesToSet[property] = description.default;\n        }\n        const propertyDescriptor = {\n          configurable: true,\n          enumerable: property === aliasedName,\n          get: () => {\n            return remoteProperties(this)?.[aliasedName];\n          },\n          set: (value) => {\n            updateRemoteElementProperty(this, aliasedName, value);\n          }\n        };\n        propertyDescriptors[property] = propertyDescriptor;\n      }\n      for (const [event, definition] of ThisClass.remoteEventDefinitions.entries()) {\n        const propertyFromDefinition = definition.property ?? true;\n        if (!propertyFromDefinition) continue;\n        const property = propertyFromDefinition === true ? \\`on\\${event}\\` : propertyFromDefinition;\n        propertyDescriptors[property] = {\n          configurable: true,\n          enumerable: true,\n          get: () => {\n            return getRemoteEvents(this).properties.get(property) ?? null;\n          },\n          set: (value) => {\n            const remoteEvents = getRemoteEvents(this);\n            const currentListener = remoteEvents.properties.get(property);\n            if (typeof value === \"function\") {\n              let handler = function(...args) {\n                return value.call(this, ...args);\n              };\n              remoteEvents.properties.set(property, handler);\n              this.addEventListener(event, handler);\n            } else {\n              remoteEvents.properties.delete(property);\n            }\n            if (currentListener) {\n              this.removeEventListener(event, currentListener);\n            }\n          }\n        };\n      }\n      Object.defineProperties(this, propertyDescriptors);\n      Object.assign(this, initialPropertiesToSet);\n    }\n    attributeChangedCallback(attribute, _oldValue, newValue) {\n      if (attribute === \"slot\" && this.constructor.slottable) {\n        updateRemoteElementAttribute(this, attribute, newValue ? String(newValue) : void 0);\n        return;\n      }\n      const {\n        remotePropertyDefinitions,\n        remoteAttributeDefinitions,\n        __attributeToPropertyMap: attributeToPropertyMap\n      } = this.constructor;\n      if (remoteAttributeDefinitions.has(attribute)) {\n        updateRemoteElementAttribute(this, attribute, newValue);\n        return;\n      }\n      const property = attributeToPropertyMap.get(attribute);\n      const propertyDefinition = property == null ? property : remotePropertyDefinitions.get(property);\n      if (propertyDefinition == null) return;\n      this[property] = convertAttributeValueToProperty(newValue, propertyDefinition.type);\n    }\n    connectedCallback() {\n      for (const [event, descriptor] of this.constructor.remoteEventDefinitions.entries()) {\n        if (descriptor.bubbles) {\n          this.addEventListener(event, noopBubblesEventListener);\n        }\n      }\n    }\n    disconnectedCallback() {\n      for (const [event, descriptor] of this.constructor.remoteEventDefinitions.entries()) {\n        if (descriptor.bubbles) {\n          this.removeEventListener(event, noopBubblesEventListener);\n        }\n      }\n    }\n    addEventListener(type, listener, options) {\n      const {\n        remoteEventDefinitions,\n        __eventToPropertyMap: eventToPropertyMap\n      } = this.constructor;\n      const listenerDefinition = remoteEventDefinitions.get(type);\n      const property = eventToPropertyMap.get(type);\n      if (listenerDefinition == null && property == null) {\n        return super.addEventListener(type, listener, options);\n      }\n      const remoteEvents = getRemoteEvents(this);\n      const remoteEvent = getRemoteEventRecord.call(this, type, {\n        property,\n        definition: listenerDefinition\n      });\n      const normalizedListener = typeof options === \"object\" && options?.once ? (...args) => {\n        const result = typeof listener === \"object\" ? listener.handleEvent(...args) : listener.call(this, ...args);\n        removeRemoteListener.call(this, type, listener, listenerRecord);\n        return result;\n      } : listener;\n      const listenerRecord = [normalizedListener, remoteEvent];\n      remoteEvent.listeners.add(listener);\n      remoteEvents.listeners.set(listener, listenerRecord);\n      super.addEventListener(type, normalizedListener, options);\n      if (typeof options === \"object\" && options.signal) {\n        options.signal.addEventListener(\"abort\", () => {\n          removeRemoteListener.call(this, type, listener, listenerRecord);\n        }, {\n          once: true\n        });\n      }\n      if (listenerDefinition) {\n        updateRemoteElementEventListener(this, type, remoteEvent.dispatch);\n      } else {\n        updateRemoteElementProperty(this, property, remoteEvent.dispatch);\n      }\n    }\n    removeEventListener(type, listener, options) {\n      const listenerRecord = REMOTE_EVENTS.get(this)?.listeners.get(listener);\n      const normalizedListener = listenerRecord ? listenerRecord[0] : listener;\n      super.removeEventListener(type, normalizedListener, options);\n      if (listenerRecord == null) return;\n      removeRemoteListener.call(this, type, listener, listenerRecord);\n    }\n    /**\n     * Updates a single remote property on an element node. If the element is\n     * connected to a remote root, this function will also make a \\`mutate()\\` call\n     * to communicate the change to the host.\n     */\n    updateRemoteProperty(name, value) {\n      updateRemoteElementProperty(this, name, value);\n    }\n    /**\n     * Updates a single remote attribute on an element node. If the element is\n     * connected to a remote root, this function will also make a \\`mutate()\\` call\n     * to communicate the change to the host.\n     */\n    updateRemoteAttribute(name, value) {\n      updateRemoteElementAttribute(this, name, value);\n    }\n    /**\n     * Performs a method through \\`RemoteConnection.call()\\`, using the remote ID and\n     * connection for the provided node.\n     */\n    callRemoteMethod(method, ...args) {\n      return callRemoteElementMethod(this, method, ...args);\n    }\n  };\n  __publicField(RemoteElement, \"slottable\", true);\n  __publicField(RemoteElement, \"__finalized\", true);\n  __publicField(RemoteElement, \"__observedAttributes\", []);\n  __publicField(RemoteElement, \"__attributeToPropertyMap\", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());\n  __publicField(RemoteElement, \"__eventToPropertyMap\", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());\n  __publicField(RemoteElement, \"__remotePropertyDefinitions\", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());\n  __publicField(RemoteElement, \"__remoteAttributeDefinitions\", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());\n  __publicField(RemoteElement, \"__remoteEventDefinitions\", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());\n  __publicField(RemoteElement, \"__remoteSlotDefinitions\", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());\n  var REMOTE_EVENTS = /* @__PURE__ */ new WeakMap();\n  function getRemoteEvents(element) {\n    let events = REMOTE_EVENTS.get(element);\n    if (events) return events;\n    events = {\n      events: /* @__PURE__ */ new Map(),\n      properties: /* @__PURE__ */ new Map(),\n      listeners: /* @__PURE__ */ new WeakMap()\n    };\n    REMOTE_EVENTS.set(element, events);\n    return events;\n  }\n  function getRemoteEventRecord(type, {\n    property,\n    definition\n  }) {\n    const remoteEvents = getRemoteEvents(this);\n    let remoteEvent = remoteEvents.events.get(type);\n    if (remoteEvent == null) {\n      remoteEvent = {\n        name: type,\n        property,\n        definition,\n        listeners: /* @__PURE__ */ new Set(),\n        dispatch: (arg) => {\n          const event = definition?.dispatchEvent?.call(this, arg) ?? new RemoteEvent(type, {\n            detail: arg,\n            bubbles: definition?.bubbles\n          });\n          this.dispatchEvent(event);\n          return event.response;\n        }\n      };\n      remoteEvents.events.set(type, remoteEvent);\n    }\n    return remoteEvent;\n  }\n  function removeRemoteListener(type, listener, listenerRecord) {\n    const remoteEvents = getRemoteEvents(this);\n    const remoteEvent = listenerRecord[1];\n    remoteEvent.listeners.delete(listener);\n    remoteEvents.listeners.delete(listener);\n    if (remoteEvent.listeners.size > 0) return;\n    remoteEvents.events.delete(type);\n    if (remoteEvent.property) {\n      if (remoteProperties(this)?.[remoteEvent.property] === remoteEvent.dispatch) {\n        updateRemoteElementProperty(this, remoteEvent.property, void 0);\n      }\n    } else {\n      if (remoteEventListeners(this)?.[type] === remoteEvent.dispatch) {\n        updateRemoteElementEventListener(this, type, void 0);\n      }\n    }\n  }\n  function saveRemoteProperty(name, description, observedAttributes, remotePropertyDefinitions, attributeToPropertyMap, eventToPropertyMap) {\n    if (remotePropertyDefinitions.has(name)) {\n      return remotePropertyDefinitions.get(name);\n    }\n    const looksLikeEventCallback = name[0] === \"o\" && name[1] === \"n\";\n    const resolvedDescription = description ?? {};\n    let {\n      alias\n    } = resolvedDescription;\n    const {\n      type = looksLikeEventCallback ? Function : String,\n      attribute = type !== Function,\n      event = looksLikeEventCallback,\n      default: defaultValue = type === Boolean ? false : void 0\n    } = resolvedDescription;\n    if (alias == null) {\n      const lowercaseProperty = name.toLowerCase();\n      if (lowercaseProperty !== name) {\n        alias = [lowercaseProperty];\n      }\n      if (looksLikeEventCallback) {\n        alias ?? (alias = []);\n        alias.unshift(\\`_\\${name}\\`);\n      }\n    }\n    let attributeName;\n    if (attribute === true) {\n      attributeName = camelToKebabCase(name);\n    } else if (typeof attribute === \"string\") {\n      attributeName = attribute;\n    }\n    if (attributeName) {\n      if (Array.isArray(observedAttributes)) {\n        observedAttributes.push(attributeName);\n      } else {\n        observedAttributes.add(attributeName);\n      }\n      attributeToPropertyMap.set(attributeName, name);\n    }\n    let eventName;\n    if (event === true) {\n      eventName = camelToKebabCase(looksLikeEventCallback ? name.slice(2) : name);\n    } else if (typeof event === \"string\") {\n      eventName = event;\n    }\n    if (eventName) {\n      eventToPropertyMap.set(eventName, name);\n    }\n    const definition = {\n      name,\n      type,\n      alias,\n      event: eventName,\n      attribute: attributeName,\n      default: defaultValue\n    };\n    remotePropertyDefinitions.set(name, definition);\n    if (alias) {\n      for (const propertyAlias of alias) {\n        remotePropertyDefinitions.set(propertyAlias, definition);\n      }\n    }\n    return definition;\n  }\n  function convertAttributeValueToProperty(value, type) {\n    if (value == null) return void 0;\n    switch (type) {\n      case Boolean:\n        return value != null && value !== \"false\";\n      case Object:\n      case Array:\n        try {\n          return JSON.parse(value);\n        } catch {\n          return void 0;\n        }\n      case String:\n        return String(value);\n      case Number:\n        return Number.parseFloat(value);\n      case Function:\n        return void 0;\n      default: {\n        return type.parse?.(value);\n      }\n    }\n  }\n  function camelToKebabCase(str) {\n    return str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n  }\n  function noopBubblesEventListener() {\n  }\n\n  // ../../../node_modules/.pnpm/@remote-dom+core@1.8.1_@preact+signals-core@1.10.0/node_modules/@remote-dom/core/build/esm/elements/RemoteMutationObserver.mjs\n  var RemoteMutationObserver = class extends MutationObserver {\n    constructor(connection) {\n      super((records) => {\n        const addedNodes = [];\n        const remoteRecords = [];\n        for (const record of records) {\n          const targetId = remoteId(record.target);\n          if (record.type === \"childList\") {\n            const position = record.previousSibling ? indexOf(record.previousSibling, record.target.childNodes) + 1 : 0;\n            record.removedNodes.forEach((node) => {\n              disconnectRemoteNode(node);\n              remoteRecords.push([MUTATION_TYPE_REMOVE_CHILD, targetId, position]);\n            });\n            record.addedNodes.forEach((node, index) => {\n              if (addedNodes.some((addedNode) => {\n                return addedNode === node || addedNode.contains(node);\n              })) {\n                return;\n              }\n              addedNodes.push(node);\n              connectRemoteNode(node, connection);\n              remoteRecords.push([MUTATION_TYPE_INSERT_CHILD, targetId, serializeRemoteNode(node), position + index]);\n            });\n          } else if (record.type === \"characterData\") {\n            remoteRecords.push([MUTATION_TYPE_UPDATE_TEXT, targetId, record.target.textContent ?? \"\"]);\n          } else if (record.type === \"attributes\" && record.attributeName != null && record.target instanceof Element && !record.target.tagName.includes(\"-\")) {\n            remoteRecords.push([MUTATION_TYPE_UPDATE_PROPERTY, targetId, record.attributeName, record.target.getAttribute(record.attributeName)]);\n          }\n        }\n        connection.mutate(remoteRecords);\n      });\n      this.connection = connection;\n    }\n    /**\n     * Starts watching changes to the element, and communicates changes to the\n     * host environment. By default, this method will also communicate any initial\n     * children of the element to the host environment.\n     */\n    observe(target, options) {\n      REMOTE_IDS.set(target, ROOT_ID);\n      if (options?.initial !== false && target.childNodes.length > 0) {\n        const records = [];\n        for (let i = 0; i < target.childNodes.length; i++) {\n          const node = target.childNodes[i];\n          connectRemoteNode(node, this.connection);\n          records.push([MUTATION_TYPE_INSERT_CHILD, ROOT_ID, serializeRemoteNode(node), i]);\n        }\n        this.connection.mutate(records);\n      }\n      super.observe(target, {\n        subtree: true,\n        childList: true,\n        attributes: true,\n        characterData: true,\n        ...options\n      });\n    }\n  };\n  function indexOf(node, list) {\n    for (let i = 0; i < list.length; i++) {\n      if (list[i] === node) return i;\n    }\n    return -1;\n  }\n\n  // ../../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/constants.mjs\n  var MESSAGE_CALL = 1;\n  var MESSAGE_CALL_RESULT = 2;\n  var MESSAGE_FUNCTION_CALL = 3;\n  var MESSAGE_FUNCTION_RESULT = 4;\n  var MESSAGE_FUNCTION_RELEASE = 5;\n  var SERIALIZE_METHOD = Symbol.for(\"quilt.threads.serialize\");\n  var TRANSFERABLE = Symbol.for(\"quilt.threads.transferable\");\n\n  // ../../../node_modules/.pnpm/@quilted+events@2.1.3/node_modules/@quilted/events/build/esm/abort/NestedAbortController.mjs\n  var NestedAbortController = class extends AbortController {\n    constructor(...parents) {\n      super();\n      const abortedSignal = parents.find((signal) => signal.aborted);\n      if (abortedSignal) {\n        this.abort(abortedSignal.reason);\n      } else {\n        const abort = (event) => this.abort(event.target.reason);\n        const options = {\n          signal: this.signal\n        };\n        for (const signal of parents) {\n          signal.addEventListener(\"abort\", abort, options);\n        }\n      }\n    }\n  };\n\n  // ../../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/errors.mjs\n  var ThreadClosedError = class extends Error {\n    constructor() {\n      super(\"You attempted to call a function on a closed thread.\");\n    }\n  };\n\n  // ../../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/nanoid.mjs\n  var a = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\n  function nanoid(e = 21) {\n    let t = \"\", r = crypto.getRandomValues(new Uint8Array(e));\n    for (let n = 0; n < e; n++) t += a[63 & r[n]];\n    return t;\n  }\n\n  // ../../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/functions/ThreadFunctionsAutomatic.mjs\n  var _functionsToId, _idsToFunction, _idsToProxy, _finalization, _ThreadFunctionsAutomatic_instances, finalizationRegistry_fn;\n  var ThreadFunctionsAutomatic = class {\n    constructor() {\n      __privateAdd(this, _ThreadFunctionsAutomatic_instances);\n      __privateAdd(this, _functionsToId, /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());\n      __privateAdd(this, _idsToFunction, /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());\n      __privateAdd(this, _idsToProxy, /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());\n      __privateAdd(this, _finalization, /* @__PURE__ */ (() => /* @__PURE__ */ new WeakMap())());\n    }\n    get(id2) {\n      return __privateGet(this, _idsToFunction).get(id2);\n    }\n    release(id2) {\n      const func = __privateGet(this, _idsToFunction).get(id2);\n      if (func) {\n        __privateGet(this, _idsToFunction).delete(id2);\n        __privateGet(this, _functionsToId).delete(func);\n      }\n      return Boolean(func);\n    }\n    serialize(func) {\n      let id2 = __privateGet(this, _functionsToId).get(func);\n      if (id2 == null) {\n        id2 = nanoid();\n        __privateGet(this, _functionsToId).set(func, id2);\n        __privateGet(this, _idsToFunction).set(id2, func);\n      }\n      return id2;\n    }\n    deserialize(id2, thread) {\n      let proxy = __privateGet(this, _idsToProxy).get(id2)?.deref();\n      if (proxy) return proxy;\n      proxy = (...args) => {\n        if (!__privateGet(this, _idsToProxy).has(id2)) {\n          throw new Error(\"You attempted to call a function that was already revoked.\");\n        }\n        return thread.call((callID, args2, transferable) => {\n          thread.messages.send([MESSAGE_FUNCTION_CALL, callID, id2, args2], transferable);\n        }, args);\n      };\n      __privateMethod(this, _ThreadFunctionsAutomatic_instances, finalizationRegistry_fn).call(this, thread)?.register(proxy, id2);\n      __privateGet(this, _idsToProxy).set(id2, new WeakRef(proxy));\n      return proxy;\n    }\n  };\n  _functionsToId = new WeakMap();\n  _idsToFunction = new WeakMap();\n  _idsToProxy = new WeakMap();\n  _finalization = new WeakMap();\n  _ThreadFunctionsAutomatic_instances = new WeakSet();\n  finalizationRegistry_fn = function(thread) {\n    let finalization = __privateGet(this, _finalization).get(thread);\n    if (typeof FinalizationRegistry === \"undefined\") {\n      return void 0;\n    }\n    if (!finalization) {\n      finalization = new FinalizationRegistry((id2) => {\n        thread.messages.send([MESSAGE_FUNCTION_RELEASE, id2]);\n      });\n      __privateGet(this, _finalization).set(thread, finalization);\n    }\n    return finalization;\n  };\n\n  // ../../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/serialization/shared.mjs\n  function isIterator(value) {\n    return value != null && (Symbol.asyncIterator in value || Symbol.iterator in value) && typeof value.next === \"function\";\n  }\n  function isBasicObject(value) {\n    if (value == null || typeof value !== \"object\") return false;\n    const prototype = Object.getPrototypeOf(value);\n    return prototype == null || prototype === Object.prototype;\n  }\n\n  // ../../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/serialization/ThreadSerializationStructuredClone.mjs\n  var FUNCTION = \"_@f\";\n  var ASYNC_ITERATOR = \"_@i\";\n  var _customSerializer, _customDeserializer, _ThreadSerializationStructuredClone_instances, serializeInternal_fn, deserializeInternal_fn;\n  var ThreadSerializationStructuredClone = class {\n    constructor(options) {\n      __privateAdd(this, _ThreadSerializationStructuredClone_instances);\n      __privateAdd(this, _customSerializer);\n      __privateAdd(this, _customDeserializer);\n      __privateSet(this, _customSerializer, options?.serialize);\n      __privateSet(this, _customDeserializer, options?.deserialize);\n    }\n    /**\n     * Serializes a value into a structured cloning-compatible format that can be transferred between threads.\n     */\n    serialize(value, thread, transferable) {\n      return __privateMethod(this, _ThreadSerializationStructuredClone_instances, serializeInternal_fn).call(this, value, thread, transferable);\n    }\n    /**\n     * Deserializes a structured cloning-compatible value from another thread.\n     */\n    deserialize(value, thread) {\n      return __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, value, thread);\n    }\n  };\n  _customSerializer = new WeakMap();\n  _customDeserializer = new WeakMap();\n  _ThreadSerializationStructuredClone_instances = new WeakSet();\n  serializeInternal_fn = function(value, thread, transferable, seen = /* @__PURE__ */ new Map(), isApplyingDefault = false) {\n    if (value == null) return value;\n    if (seen.has(value)) return seen.get(value);\n    seen.set(value, void 0);\n    if (typeof value === \"object\") {\n      if (__privateGet(this, _customSerializer) && !isApplyingDefault) {\n        const customValue = __privateGet(this, _customSerializer).call(this, value, (value2) => __privateMethod(this, _ThreadSerializationStructuredClone_instances, serializeInternal_fn).call(this, value2, thread, transferable, seen, true), thread, transferable);\n        if (customValue !== void 0) {\n          seen.set(value, customValue);\n          return customValue;\n        }\n      }\n      if (value[TRANSFERABLE]) {\n        transferable?.push(value);\n        seen.set(value, value);\n        return value;\n      }\n      const serializeValue = (value2) => {\n        return __privateMethod(this, _ThreadSerializationStructuredClone_instances, serializeInternal_fn).call(this, value2, thread, transferable, seen);\n      };\n      if (typeof value[SERIALIZE_METHOD] === \"function\") {\n        const result = value[SERIALIZE_METHOD]({\n          serialize: serializeValue\n        });\n        seen.set(value, result);\n        return result;\n      }\n      if (Array.isArray(value)) {\n        const result = value.map((item) => serializeValue(item));\n        seen.set(value, result);\n        return result;\n      }\n      if (value instanceof Map) {\n        const entries = [...value.entries()].map(([key, value2]) => {\n          return [serializeValue(key), serializeValue(value2)];\n        });\n        const result = new Map(entries);\n        seen.set(value, result);\n        return result;\n      }\n      if (value instanceof Set) {\n        const entries = [...value].map((entry) => serializeValue(entry));\n        const result = new Set(entries);\n        seen.set(value, result);\n        return result;\n      }\n      const valueIsIterator = isIterator(value);\n      if (isBasicObject(value) || valueIsIterator) {\n        const result = {};\n        for (const key of Object.keys(value)) {\n          result[key] = serializeValue(value[key]);\n        }\n        if (valueIsIterator) {\n          result.next ?? (result.next = serializeValue(value.next.bind(value)));\n          result.return ?? (result.return = serializeValue(value.return.bind(value)));\n          result.throw ?? (result.throw = serializeValue(value.throw.bind(value)));\n          result[ASYNC_ITERATOR] = true;\n        }\n        seen.set(value, result);\n        return result;\n      }\n    }\n    if (typeof value === \"function\") {\n      const serialized = thread.functions.serialize(value, thread, transferable);\n      const result = {\n        [FUNCTION]: serialized\n      };\n      seen.set(value, result);\n      return result;\n    }\n    seen.set(value, value);\n    return value;\n  };\n  deserializeInternal_fn = function(value, thread, isApplyingDefault = false) {\n    if (value == null) return value;\n    if (typeof value === \"object\") {\n      if (__privateGet(this, _customDeserializer) && !isApplyingDefault) {\n        const customValue = __privateGet(this, _customDeserializer).call(this, value, (value2) => __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, value2, thread, true), thread);\n        if (customValue !== void 0) {\n          return customValue;\n        }\n      }\n      if (value == null) {\n        return value;\n      }\n      if (Array.isArray(value)) {\n        return value.map((value2) => __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, value2, thread));\n      }\n      if (value instanceof Map) {\n        return new Map([...value].map(([key, value2]) => [__privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, key, thread), __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, value2, thread)]));\n      }\n      if (value instanceof Set) {\n        return new Set([...value].map((entry) => __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, entry, thread)));\n      }\n      if (FUNCTION in value) {\n        const func = thread.functions.deserialize(value[FUNCTION], thread);\n        return func;\n      }\n      if (!isBasicObject(value)) {\n        return value;\n      }\n      const result = {};\n      for (const key of Object.keys(value)) {\n        if (key === ASYNC_ITERATOR) {\n          result[Symbol.asyncIterator] = () => result;\n        } else {\n          result[key] = __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, value[key], thread);\n        }\n      }\n      return result;\n    }\n    return value;\n  };\n\n  // ../../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/Thread.mjs\n  var _abort, _idsToResolver, _Thread_instances, callLocal_fn, handlerForCall_fn, resolveCall_fn, waitForResult_fn;\n  var Thread = class {\n    constructor(messages, {\n      imports,\n      exports,\n      functions = new ThreadFunctionsAutomatic(),\n      serialization = new ThreadSerializationStructuredClone(),\n      signal\n    } = {}) {\n      __privateAdd(this, _Thread_instances);\n      __privateAdd(this, _abort);\n      __privateAdd(this, _idsToResolver, /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());\n      this.messages = messages;\n      __privateSet(this, _abort, signal ? new NestedAbortController(signal) : new AbortController());\n      this.exports = exports ?? {};\n      this.imports = createThreadImports(__privateMethod(this, _Thread_instances, handlerForCall_fn).bind(this), imports);\n      this.functions = functions;\n      this.serialization = serialization;\n      this.functions.start?.(this);\n      this.serialization.start?.(this);\n      this.signal.addEventListener(\"abort\", () => {\n        for (const id2 of __privateGet(this, _idsToResolver).keys()) {\n          __privateMethod(this, _Thread_instances, resolveCall_fn).call(this, id2, void 0, new ThreadClosedError());\n        }\n        __privateGet(this, _idsToResolver).clear();\n      }, {\n        once: true\n      });\n      messages.listen(async (rawData) => {\n        const isThreadMessageData = Array.isArray(rawData) && typeof rawData[0] === \"number\";\n        if (!isThreadMessageData) {\n          return;\n        }\n        const data = rawData;\n        switch (data[0]) {\n          case MESSAGE_CALL: {\n            const [, id2, property, args] = data;\n            const func = this.exports[property] ?? (() => {\n              throw new Error(\\`No '\\${property}' method is exported from this thread\\`);\n            });\n            await __privateMethod(this, _Thread_instances, callLocal_fn).call(this, func, args, (value, error, transferable) => {\n              this.messages.send([MESSAGE_CALL_RESULT, id2, value, error], transferable);\n            });\n            break;\n          }\n          case MESSAGE_FUNCTION_CALL: {\n            const [, callID, funcID, args] = data;\n            const func = this.functions.get(funcID, this) ?? missingThreadFunction;\n            await __privateMethod(this, _Thread_instances, callLocal_fn).call(this, func, args, (value, error, transferable) => {\n              this.messages.send([MESSAGE_FUNCTION_RESULT, callID, value, error], transferable);\n            });\n            break;\n          }\n          case MESSAGE_CALL_RESULT:\n          case MESSAGE_FUNCTION_RESULT: {\n            __privateMethod(this, _Thread_instances, resolveCall_fn).call(this, ...data.slice(1));\n            break;\n          }\n          case MESSAGE_FUNCTION_RELEASE: {\n            const id2 = data[1];\n            this.functions.release(id2, this);\n            break;\n          }\n        }\n      }, {\n        signal: this.signal\n      });\n    }\n    /**\n     * An object that exposes the methods that can be called on the paired thread.\n     * This object will automatically encode and decode arguments and return values\n     * as necessary.\n     */\n    /**\n     * An object that exposes the methods that can be called on this thread by the\n     * paired thread. To set these methods, pass the \\`exports\\` option when creating\n     * a new \\`Thread\\`.\n     */\n    /**\n     * An object that provides the message-passing interface that allows communication\n     * to flow between environments.\n     */\n    /**\n     * An object that manages how functions are proxied between threads.\n     */\n    /**\n     * An object that manages how values are serialized and deserialized between threads.\n     */\n    /**\n     * An \\`AbortSignal\\` that indicates whether the communication channel is still open.\n     */\n    get signal() {\n      return __privateGet(this, _abort).signal;\n    }\n    /**\n     * A boolean indicating whether the communication channel is still open.\n     */\n    get closed() {\n      return __privateGet(this, _abort).signal.aborted;\n    }\n    /**\n     * Closes the communication channel between the two threads. This will prevent\n     * any further communication between the threads, and will clean up any memory\n     * associated with in-progress communication. It will also reject any inflight\n     * function calls between threads with a \\`ThreadClosedError\\`.\n     */\n    close() {\n      __privateGet(this, _abort).abort();\n    }\n    /**\n     * Requests that the thread provide the context needed to make a function\n     * call between threads. You provide this method a function to call and the\n     * unserialized arguments you wish to call it with, and the thread will call\n     * the function you provided with a serialized call ID, the serialized arguments,\n     * and any transferable objects that need to be passed between threads.\n     */\n    call(func, args) {\n      if (this.closed) {\n        return Promise.reject(new ThreadClosedError());\n      }\n      const transferable = [];\n      const serialized = this.serialization.serialize(args, this, transferable);\n      const id2 = nanoid();\n      const done = __privateMethod(this, _Thread_instances, waitForResult_fn).call(this, id2);\n      func(id2, serialized, transferable);\n      return done;\n    }\n  };\n  _abort = new WeakMap();\n  _idsToResolver = new WeakMap();\n  _Thread_instances = new WeakSet();\n  callLocal_fn = async function(func, args, withResult) {\n    try {\n      const result = this.functions.call ? await this.functions.call(func, args, this) : await func(...this.serialization.deserialize(args, this));\n      const transferable = [];\n      const serialized = this.serialization.serialize(result, this, transferable);\n      withResult(serialized, void 0, transferable);\n    } catch (error) {\n      withResult(void 0, this.serialization.serialize(error, this));\n    }\n  };\n  handlerForCall_fn = function(property) {\n    return (...args) => {\n      try {\n        if (typeof property !== \"string\" && typeof property !== \"number\") {\n          throw new Error(\\`Cant call a symbol method on a thread: \\${property.toString()}\\`);\n        }\n        return this.call((id2, serializedArgs, transferable) => {\n          this.messages.send([MESSAGE_CALL, id2, property, serializedArgs], transferable);\n        }, args);\n      } catch (error) {\n        return Promise.reject(error);\n      }\n    };\n  };\n  resolveCall_fn = function(...args) {\n    const callID = args[0];\n    const resolver = __privateGet(this, _idsToResolver).get(callID);\n    if (resolver) {\n      resolver(...args);\n      __privateGet(this, _idsToResolver).delete(callID);\n    }\n  };\n  waitForResult_fn = function(id2) {\n    const promise = new Promise((resolve, reject) => {\n      __privateGet(this, _idsToResolver).set(id2, (_, value, error) => {\n        if (error == null) {\n          resolve(this.serialization.deserialize(value, this));\n        } else {\n          reject(this.serialization.deserialize(error, this));\n        }\n      });\n    });\n    Object.defineProperty(promise, Symbol.asyncIterator, {\n      async *value() {\n        const result = await promise;\n        Object.defineProperty(result, Symbol.asyncIterator, {\n          value: () => result\n        });\n        yield* result;\n      }\n    });\n    return promise;\n  };\n  function createThreadImports(handlerForImport, imported) {\n    let call;\n    if (imported == null) {\n      if (typeof Proxy !== \"function\") {\n        throw new Error(\\`You must pass an array of callable methods in environments without Proxies.\\`);\n      }\n      const cache = /* @__PURE__ */ new Map();\n      call = new Proxy({}, {\n        get(_target, property) {\n          if (cache.has(property)) {\n            return cache.get(property);\n          }\n          const handler = handlerForImport(property);\n          cache.set(property, handler);\n          return handler;\n        }\n      });\n    } else {\n      call = {};\n      for (const method of imported) {\n        Object.defineProperty(call, method, {\n          value: handlerForImport(method),\n          writable: false,\n          configurable: true,\n          enumerable: true\n        });\n      }\n    }\n    return call;\n  }\n  function missingThreadFunction() {\n    throw new Error(\\`You attempted to call a function that is not stored. It may have already been released.\\`);\n  }\n\n  // ../../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/threads/window/shared.mjs\n  var CHECK_MESSAGE = \"quilt.threads.ping\";\n  var RESPONSE_MESSAGE = \"quilt.threads.pong\";\n\n  // ../../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/threads/window/ThreadNestedWindow.mjs\n  function nestedWindowToThreadTarget(parent, {\n    targetOrigin = \"*\"\n  } = {}) {\n    const ready = () => {\n      const respond = () => parent.postMessage(RESPONSE_MESSAGE, targetOrigin);\n      self.addEventListener(\"message\", ({\n        data,\n        source\n      }) => {\n        if (source !== parent) return;\n        if (data === CHECK_MESSAGE) respond();\n      });\n      respond();\n    };\n    if (document.readyState === \"complete\") {\n      ready();\n    } else {\n      document.addEventListener(\"readystatechange\", () => {\n        if (document.readyState === \"complete\") {\n          ready();\n        }\n      });\n    }\n    return {\n      send(message, transfer) {\n        return parent.postMessage(message, targetOrigin, transfer);\n      },\n      listen(listen, {\n        signal\n      }) {\n        self.addEventListener(\"message\", (event) => {\n          if (event.data === CHECK_MESSAGE) return;\n          listen(event.data);\n        }, {\n          signal\n        });\n      }\n    };\n  }\n\n  // ../../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/threads/ThreadNestedIframe.mjs\n  var ThreadNestedIframe = class extends Thread {\n    constructor({\n      parent = globalThis.parent,\n      targetOrigin = \"*\",\n      ...options\n    } = {}) {\n      if (typeof self === \"undefined\" || parent == null) {\n        throw new Error(\"You are not inside an iframe, because there is no parent window.\");\n      }\n      super(nestedWindowToThreadTarget(parent, {\n        targetOrigin\n      }), options);\n      this.parent = parent;\n    }\n  };\n\n  // scripts/iframe-entry.js\n  new ThreadNestedIframe({\n    exports: {\n      async render(options, receiver, hostApi) {\n        if (options.remoteElements) {\n          options.remoteElements.forEach((def) => {\n            if (customElements.get(def.tagName)) return;\n            const remoteElement = class extends RemoteElement {\n              static get remoteAttributes() {\n                return def.remoteAttributes || [];\n              }\n              static get remoteEvents() {\n                return def.remoteEvents || [];\n              }\n            };\n            Object.defineProperty(remoteElement, \"name\", {\n              value: \\`Remote\\${def.tagName.replace(\n                /(^w|-w)/g,\n                (c) => c.replace(\"-\", \"\").toUpperCase()\n              )}\\`\n            });\n            customElements.define(def.tagName, remoteElement);\n          });\n        }\n        const root = document.querySelector(\"#root\");\n        const observer = new RemoteMutationObserver(receiver);\n        observer.observe(root);\n        const { code } = options;\n        if (code && root) {\n          try {\n            const scriptFunction = new Function(\"root\", \"console\", code);\n            scriptFunction(root, console);\n          } catch (e) {\n            console.error(\"Error executing remote script:\", e);\n          }\n        }\n      }\n    }\n  });\n})();\n\n  <\\/script>\n</body>\n</html>`, ve = 1, ye = 2, Le = 3, Te = 4, Ue = 5, ge = Symbol.for(\"quilt.threads.serialize\"), yt = Symbol.for(\"quilt.threads.transferable\");\nclass Tt extends AbortController {\n  constructor(...e) {\n    super();\n    const t = e.find((n) => n.aborted);\n    if (t)\n      this.abort(t.reason);\n    else {\n      const n = (o) => this.abort(o.target.reason), s = {\n        signal: this.signal\n      };\n      for (const o of e)\n        o.addEventListener(\"abort\", n, s);\n    }\n  }\n}\nclass Re extends Error {\n  constructor() {\n    super(\"You attempted to call a function on a closed thread.\");\n  }\n}\nlet gt = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nfunction ze(r = 21) {\n  let e = \"\", t = crypto.getRandomValues(new Uint8Array(r));\n  for (let n = 0; n < r; n++) e += gt[63 & t[n]];\n  return e;\n}\nvar Y, x, G, K, ee, xe;\nclass Rt {\n  constructor() {\n    S(this, ee);\n    S(this, Y, /* @__PURE__ */ new Map());\n    S(this, x, /* @__PURE__ */ new Map());\n    S(this, G, /* @__PURE__ */ new Map());\n    S(this, K, /* @__PURE__ */ new WeakMap());\n  }\n  get(e) {\n    return b(this, x).get(e);\n  }\n  release(e) {\n    const t = b(this, x).get(e);\n    return t && (b(this, x).delete(e), b(this, Y).delete(t)), !!t;\n  }\n  serialize(e) {\n    let t = b(this, Y).get(e);\n    return t == null && (t = ze(), b(this, Y).set(e, t), b(this, x).set(t, e)), t;\n  }\n  deserialize(e, t) {\n    var s, o;\n    let n = (s = b(this, G).get(e)) == null ? void 0 : s.deref();\n    return n || (n = (...a) => {\n      if (!b(this, G).has(e))\n        throw new Error(\"You attempted to call a function that was already revoked.\");\n      return t.call((u, l, f) => {\n        t.messages.send([Le, u, e, l], f);\n      }, a);\n    }, (o = y(this, ee, xe).call(this, t)) == null || o.register(n, e), b(this, G).set(e, new WeakRef(n)), n);\n  }\n}\nY = new WeakMap(), x = new WeakMap(), G = new WeakMap(), K = new WeakMap(), ee = new WeakSet(), xe = function(e) {\n  let t = b(this, K).get(e);\n  if (!(typeof FinalizationRegistry > \"u\"))\n    return t || (t = new FinalizationRegistry((n) => {\n      e.messages.send([Ue, n]);\n    }), b(this, K).set(e, t)), t;\n};\nfunction wt(r) {\n  return r != null && (Symbol.asyncIterator in r || Symbol.iterator in r) && typeof r.next == \"function\";\n}\nfunction we(r) {\n  if (r == null || typeof r != \"object\") return !1;\n  const e = Object.getPrototypeOf(r);\n  return e == null || e === Object.prototype;\n}\nconst ie = \"_@f\", Se = \"_@i\";\nvar V, W, w, Q, O;\nclass St {\n  constructor(e) {\n    S(this, w);\n    S(this, V);\n    S(this, W);\n    Z(this, V, e == null ? void 0 : e.serialize), Z(this, W, e == null ? void 0 : e.deserialize);\n  }\n  /**\n   * Serializes a value into a structured cloning-compatible format that can be transferred between threads.\n   */\n  serialize(e, t, n) {\n    return y(this, w, Q).call(this, e, t, n);\n  }\n  /**\n   * Deserializes a structured cloning-compatible value from another thread.\n   */\n  deserialize(e, t) {\n    return y(this, w, O).call(this, e, t);\n  }\n}\nV = new WeakMap(), W = new WeakMap(), w = new WeakSet(), Q = function(e, t, n, s = /* @__PURE__ */ new Map(), o = !1) {\n  if (e == null) return e;\n  if (s.has(e)) return s.get(e);\n  if (s.set(e, void 0), typeof e == \"object\") {\n    if (b(this, V) && !o) {\n      const l = b(this, V).call(this, e, (f) => y(this, w, Q).call(this, f, t, n, s, !0), t, n);\n      if (l !== void 0)\n        return s.set(e, l), l;\n    }\n    if (e[yt])\n      return n == null || n.push(e), s.set(e, e), e;\n    const a = (l) => y(this, w, Q).call(this, l, t, n, s);\n    if (typeof e[ge] == \"function\") {\n      const l = e[ge]({\n        serialize: a\n      });\n      return s.set(e, l), l;\n    }\n    if (Array.isArray(e)) {\n      const l = e.map((f) => a(f));\n      return s.set(e, l), l;\n    }\n    if (e instanceof Map) {\n      const l = [...e.entries()].map(([i, m]) => [a(i), a(m)]), f = new Map(l);\n      return s.set(e, f), f;\n    }\n    if (e instanceof Set) {\n      const l = [...e].map((i) => a(i)), f = new Set(l);\n      return s.set(e, f), f;\n    }\n    const u = wt(e);\n    if (we(e) || u) {\n      const l = {};\n      for (const f of Object.keys(e))\n        l[f] = a(e[f]);\n      return u && (l.next ?? (l.next = a(e.next.bind(e))), l.return ?? (l.return = a(e.return.bind(e))), l.throw ?? (l.throw = a(e.throw.bind(e))), l[Se] = !0), s.set(e, l), l;\n    }\n  }\n  if (typeof e == \"function\") {\n    const a = t.functions.serialize(e, t, n), u = {\n      [ie]: a\n    };\n    return s.set(e, u), u;\n  }\n  return s.set(e, e), e;\n}, O = function(e, t, n = !1) {\n  if (e == null) return e;\n  if (typeof e == \"object\") {\n    if (b(this, W) && !n) {\n      const o = b(this, W).call(this, e, (a) => y(this, w, O).call(this, a, t, !0), t);\n      if (o !== void 0)\n        return o;\n    }\n    if (e == null)\n      return e;\n    if (Array.isArray(e))\n      return e.map((o) => y(this, w, O).call(this, o, t));\n    if (e instanceof Map)\n      return new Map([...e].map(([o, a]) => [y(this, w, O).call(this, o, t), y(this, w, O).call(this, a, t)]));\n    if (e instanceof Set)\n      return new Set([...e].map((o) => y(this, w, O).call(this, o, t)));\n    if (ie in e)\n      return t.functions.deserialize(e[ie], t);\n    if (!we(e))\n      return e;\n    const s = {};\n    for (const o of Object.keys(e))\n      o === Se ? s[Symbol.asyncIterator] = () => s : s[o] = y(this, w, O).call(this, e[o], t);\n    return s;\n  }\n  return e;\n};\nvar k, D, M, ae, ke, le, je;\nclass Mt {\n  constructor(e, {\n    imports: t,\n    exports: n,\n    functions: s = new Rt(),\n    serialization: o = new St(),\n    signal: a\n  } = {}) {\n    S(this, M);\n    S(this, k);\n    S(this, D, /* @__PURE__ */ new Map());\n    var u, l, f, i;\n    this.messages = e, Z(this, k, a ? new Tt(a) : new AbortController()), this.exports = n ?? {}, this.imports = At(y(this, M, ke).bind(this), t), this.functions = s, this.serialization = o, (l = (u = this.functions).start) == null || l.call(u, this), (i = (f = this.serialization).start) == null || i.call(f, this), this.signal.addEventListener(\"abort\", () => {\n      for (const m of b(this, D).keys())\n        y(this, M, le).call(this, m, void 0, new Re());\n      b(this, D).clear();\n    }, {\n      once: !0\n    }), e.listen(async (m) => {\n      if (!(Array.isArray(m) && typeof m[0] == \"number\"))\n        return;\n      const c = m;\n      switch (c[0]) {\n        case ve: {\n          const [, p, h, E] = c, _ = this.exports[h] ?? (() => {\n            throw new Error(`No '${h}' method is exported from this thread`);\n          });\n          await y(this, M, ae).call(this, _, E, (R, A, T) => {\n            this.messages.send([ye, p, R, A], T);\n          });\n          break;\n        }\n        case Le: {\n          const [, p, h, E] = c, _ = this.functions.get(h, this) ?? Nt;\n          await y(this, M, ae).call(this, _, E, (R, A, T) => {\n            this.messages.send([Te, p, R, A], T);\n          });\n          break;\n        }\n        case ye:\n        case Te: {\n          y(this, M, le).call(this, ...c.slice(1));\n          break;\n        }\n        case Ue: {\n          const p = c[1];\n          this.functions.release(p, this);\n          break;\n        }\n      }\n    }, {\n      signal: this.signal\n    });\n  }\n  /**\n   * An object that exposes the methods that can be called on the paired thread.\n   * This object will automatically encode and decode arguments and return values\n   * as necessary.\n   */\n  /**\n   * An object that exposes the methods that can be called on this thread by the\n   * paired thread. To set these methods, pass the `exports` option when creating\n   * a new `Thread`.\n   */\n  /**\n   * An object that provides the message-passing interface that allows communication\n   * to flow between environments.\n   */\n  /**\n   * An object that manages how functions are proxied between threads.\n   */\n  /**\n   * An object that manages how values are serialized and deserialized between threads.\n   */\n  /**\n   * An `AbortSignal` that indicates whether the communication channel is still open.\n   */\n  get signal() {\n    return b(this, k).signal;\n  }\n  /**\n   * A boolean indicating whether the communication channel is still open.\n   */\n  get closed() {\n    return b(this, k).signal.aborted;\n  }\n  /**\n   * Closes the communication channel between the two threads. This will prevent\n   * any further communication between the threads, and will clean up any memory\n   * associated with in-progress communication. It will also reject any inflight\n   * function calls between threads with a `ThreadClosedError`.\n   */\n  close() {\n    b(this, k).abort();\n  }\n  /**\n   * Requests that the thread provide the context needed to make a function\n   * call between threads. You provide this method a function to call and the\n   * unserialized arguments you wish to call it with, and the thread will call\n   * the function you provided with a serialized call ID, the serialized arguments,\n   * and any transferable objects that need to be passed between threads.\n   */\n  call(e, t) {\n    if (this.closed)\n      return Promise.reject(new Re());\n    const n = [], s = this.serialization.serialize(t, this, n), o = ze(), a = y(this, M, je).call(this, o);\n    return e(o, s, n), a;\n  }\n}\nk = new WeakMap(), D = new WeakMap(), M = new WeakSet(), ae = async function(e, t, n) {\n  try {\n    const s = this.functions.call ? await this.functions.call(e, t, this) : await e(...this.serialization.deserialize(t, this)), o = [], a = this.serialization.serialize(s, this, o);\n    n(a, void 0, o);\n  } catch (s) {\n    n(void 0, this.serialization.serialize(s, this));\n  }\n}, ke = function(e) {\n  return (...t) => {\n    try {\n      if (typeof e != \"string\" && typeof e != \"number\")\n        throw new Error(`Cant call a symbol method on a thread: ${e.toString()}`);\n      return this.call((n, s, o) => {\n        this.messages.send([ve, n, e, s], o);\n      }, t);\n    } catch (n) {\n      return Promise.reject(n);\n    }\n  };\n}, le = function(...e) {\n  const t = e[0], n = b(this, D).get(t);\n  n && (n(...e), b(this, D).delete(t));\n}, je = function(e) {\n  const t = new Promise((n, s) => {\n    b(this, D).set(e, (o, a, u) => {\n      u == null ? n(this.serialization.deserialize(a, this)) : s(this.serialization.deserialize(u, this));\n    });\n  });\n  return Object.defineProperty(t, Symbol.asyncIterator, {\n    async *value() {\n      const n = await t;\n      Object.defineProperty(n, Symbol.asyncIterator, {\n        value: () => n\n      }), yield* n;\n    }\n  }), t;\n};\nfunction At(r, e) {\n  let t;\n  if (e == null) {\n    if (typeof Proxy != \"function\")\n      throw new Error(\"You must pass an array of callable methods in environments without Proxies.\");\n    const n = /* @__PURE__ */ new Map();\n    t = new Proxy({}, {\n      get(s, o) {\n        if (n.has(o))\n          return n.get(o);\n        const a = r(o);\n        return n.set(o, a), a;\n      }\n    });\n  } else {\n    t = {};\n    for (const n of e)\n      Object.defineProperty(t, n, {\n        value: r(n),\n        writable: !1,\n        configurable: !0,\n        enumerable: !0\n      });\n  }\n  return t;\n}\nfunction Nt() {\n  throw new Error(\"You attempted to call a function that is not stored. It may have already been released.\");\n}\nconst It = \"quilt.threads.ping\", Me = \"quilt.threads.pong\";\nfunction Pt(r, {\n  targetOrigin: e = \"*\"\n} = {}) {\n  let t = !1;\n  const n = function(a, u) {\n    r.postMessage(a, e, u);\n  }, s = new Promise((o) => {\n    const a = new AbortController();\n    globalThis.window.addEventListener(\"message\", (u) => {\n      u.source === r && u.data === Me && (t = !0, a.abort(), o());\n    }, {\n      signal: a.signal\n    }), a.signal.addEventListener(\"abort\", () => o(), {\n      once: !0\n    }), n(It);\n  });\n  return {\n    send(o, a) {\n      return t ? n(o, a) : s.then(() => {\n        if (t) return n(o, a);\n      });\n    },\n    listen(o, {\n      signal: a\n    }) {\n      self.addEventListener(\"message\", (u) => {\n        u.source === r && u.data !== Me && o(u.data);\n      }, {\n        signal: a\n      });\n    }\n  };\n}\nclass Ot extends Mt {\n  constructor(e, {\n    targetOrigin: t = \"*\",\n    ...n\n  } = {}) {\n    super(Pt(e.contentWindow, {\n      targetOrigin: t\n    }), n), this.iframe = e;\n  }\n}\nconst Fe = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ content: r, children: e, ...t }, n) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { ref: n, ...t, children: r || e }));\nFe.displayName = \"UIText\";\nconst Ye = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ label: r, onPress: e, onClick: t, children: n, ...s }, o) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n  \"button\",\n  {\n    ref: o,\n    onClick: (u) => {\n      e && e(), t && t(u);\n    },\n    style: {\n      padding: \"8px 16px\",\n      backgroundColor: \"#007bff\",\n      color: \"white\",\n      border: \"none\",\n      borderRadius: \"4px\",\n      cursor: \"pointer\"\n    },\n    ...s,\n    children: r || n\n  }\n));\nYe.displayName = \"UIButton\";\nconst Ge = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({\n    direction: r = \"vertical\",\n    spacing: e = \"8\",\n    align: t = \"stretch\",\n    justify: n = \"flex-start\",\n    children: s,\n    ...o\n  }, a) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    \"div\",\n    {\n      ref: a,\n      style: {\n        display: \"flex\",\n        flexDirection: r === \"horizontal\" ? \"row\" : \"column\",\n        gap: `${e}px`,\n        alignItems: t,\n        justifyContent: n\n      },\n      ...o,\n      children: s\n    }\n  )\n);\nGe.displayName = \"UIStack\";\nconst Ve = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ src: r, alt: e, width: t, height: n, children: s, ...o }, a) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n  \"img\",\n  {\n    ref: a,\n    src: r,\n    alt: e,\n    width: t,\n    height: n,\n    style: {\n      maxWidth: \"100%\",\n      height: \"auto\",\n      borderRadius: \"8px\",\n      boxShadow: \"0 2px 8px rgba(0, 0, 0, 0.1)\"\n    },\n    ...o\n  }\n));\nVe.displayName = \"UIImage\";\nconst We = {\n  name: \"basic\",\n  elements: [\n    {\n      tagName: \"ui-text\",\n      component: Fe,\n      propMapping: {\n        content: \"content\"\n      },\n      eventMapping: {}\n    },\n    {\n      tagName: \"ui-button\",\n      component: Ye,\n      propMapping: {\n        label: \"label\"\n      },\n      eventMapping: {\n        press: \"onPress\"\n      }\n    },\n    {\n      tagName: \"ui-stack\",\n      component: Ge,\n      propMapping: {\n        direction: \"direction\",\n        spacing: \"spacing\",\n        align: \"align\",\n        justify: \"justify\"\n      },\n      eventMapping: {}\n    },\n    {\n      tagName: \"ui-image\",\n      component: Ve,\n      propMapping: {\n        src: \"src\",\n        alt: \"alt\",\n        width: \"width\",\n        height: \"height\"\n      },\n      eventMapping: {}\n    }\n  ]\n}, Dt = ({ receiver: r }) => {\n  const e = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (e.current)\n      return r.connect(e.current), () => {\n        r.disconnect();\n      };\n  }, [r]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: e, \"data-testid\": \"standard-dom-renderer-container\" });\n}, Ct = ({\n  resource: r,\n  library: e,\n  remoteElements: t = [],\n  onUIAction: n\n}) => {\n  const s = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), o = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), [a, u] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), l = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => (r.mimeType || \"\").includes(\"framework=react\") ? \"react\" : \"webcomponents\", [r.mimeType]), f = `${e == null ? void 0 : e.name}-${l}`, { receiver: i, components: m } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    switch (l) {\n      case \"react\": {\n        const c = new dt(), p = e || We, h = /* @__PURE__ */ new Map();\n        return p && p.elements.forEach((E) => {\n          const _ = _t(E.component);\n          h.set(E.tagName, _);\n        }), {\n          receiver: c,\n          components: h\n        };\n      }\n      case \"webcomponents\":\n      default:\n        return {\n          receiver: new ut(),\n          components: null\n        };\n    }\n  }, [r, e, t]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    function c(p) {\n      var h;\n      if (s.current && p.source === s.current.contentWindow) {\n        const E = p.data;\n        if (!E)\n          return;\n        (h = n == null ? void 0 : n(E)) == null || h.catch((_) => {\n          console.error(\"Error handling UI action result in RemoteDOMResourceRenderer:\", _);\n        });\n      }\n    }\n    return window.addEventListener(\"message\", c), () => window.removeEventListener(\"message\", c);\n  }, [n]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const c = o.current;\n    return o.current = null, () => {\n      c == null || c.close();\n    };\n  }, [f]);\n  const d = () => {\n    const c = s.current;\n    if (!c || o.current)\n      return;\n    const p = new Ot(c);\n    o.current = p;\n    const { code: h, error: E } = tt(r);\n    if (E) {\n      u(E);\n      return;\n    }\n    if (h && (i != null && i.connection)) {\n      const _ = {\n        code: h,\n        remoteElements: t,\n        useReactRenderer: l === \"react\",\n        componentLibrary: e == null ? void 0 : e.name\n      };\n      p.imports.render(_, i.connection).catch((R) => console.error(\"Error calling remote render:\", R));\n    }\n  };\n  return a ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", { className: \"text-red-500\", children: a }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      \"iframe\",\n      {\n        ref: s,\n        srcDoc: vt,\n        sandbox: \"allow-scripts\",\n        style: { display: \"none\" },\n        title: \"Remote DOM Sandbox\",\n        onLoad: d\n      },\n      f\n    ),\n    l === \"react\" && m ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(bt, { receiver: i, components: m }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Dt, { receiver: i })\n  ] });\n};\nfunction Lt(r) {\n  var e;\n  if (r.contentType)\n    return r.contentType;\n  if (r.mimeType === \"text/html\")\n    return \"rawHtml\";\n  if (r.mimeType === \"text/uri-list\")\n    return \"externalUrl\";\n  if ((e = r.mimeType) != null && e.startsWith(\"application/vnd.mcp-ui.remote-dom\"))\n    return \"remoteDom\";\n}\nconst Ut = (r) => {\n  const { resource: e, onUIAction: t, supportedContentTypes: n, htmlProps: s, remoteDomProps: o } = r, a = Lt(e);\n  if (n && a && !n.includes(a))\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", { className: \"text-red-500\", children: [\n      \"Unsupported content type: \",\n      a,\n      \".\"\n    ] });\n  switch (a) {\n    case \"rawHtml\":\n    case \"externalUrl\":\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Ne, { resource: e, onUIAction: t, ...s });\n    case \"remoteDom\":\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n        Ct,\n        {\n          resource: e,\n          onUIAction: t,\n          library: (o == null ? void 0 : o.library) || We,\n          ...o\n        }\n      );\n    default:\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", { className: \"text-red-500\", children: \"Unsupported resource type.\" });\n  }\n};\nUt.displayName = \"UIResourceRenderer\";\nfunction jt(r) {\n  var e, t;\n  return (r.type === \"resource\" && ((t = (e = r.resource) == null ? void 0 : e.uri) == null ? void 0 : t.startsWith(\"ui://\"))) ?? !1;\n}\nconst Ft = {\n  tagName: \"ui-card\"\n}, Yt = {\n  tagName: \"ui-button\",\n  remoteAttributes: [\"label\"],\n  remoteEvents: [\"click\", \"press\"]\n}, Gt = {\n  tagName: \"ui-text\",\n  remoteAttributes: [\"content\"]\n}, Vt = {\n  tagName: \"ui-stack\",\n  remoteAttributes: [\"direction\", \"spacing\", \"align\", \"justify\"]\n}, Wt = {\n  tagName: \"ui-image\",\n  remoteAttributes: [\"src\", \"alt\", \"width\", \"height\"]\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWNwLXVpL2NsaWVudC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywwREFBMEQ7QUFDcEc7QUFDQTtBQUN5RTtBQUM0RjtBQUNySztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLEtBQUs7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMENBQTBDLEVBQUU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLDBDQUEwQyxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsTUFBTTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUs7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOEJBQThCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hELGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLG9CQUFvQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxFQUFFO0FBQ3JDLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNB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QSwyQkFBMkIsdURBQUUsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNEQUFDLE9BQU8sa0NBQWtDO0FBQ3ZFO0FBQ0EsNkJBQTZCLHNEQUFDO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzREFBQyxRQUFRLG1FQUFtRTtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFZRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG1jcC11aS9jbGllbnQvZGlzdC9pbmRleC5tanM/MzQ5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQmUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgcGUgPSAocikgPT4ge1xuICB0aHJvdyBUeXBlRXJyb3Iocik7XG59O1xudmFyICRlID0gKHIsIGUsIHQpID0+IGUgaW4gciA/IEJlKHIsIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiByW2VdID0gdDtcbnZhciBMID0gKHIsIGUsIHQpID0+ICRlKHIsIHR5cGVvZiBlICE9IFwic3ltYm9sXCIgPyBlICsgXCJcIiA6IGUsIHQpLCBvZSA9IChyLCBlLCB0KSA9PiBlLmhhcyhyKSB8fCBwZShcIkNhbm5vdCBcIiArIHQpO1xudmFyIGIgPSAociwgZSwgdCkgPT4gKG9lKHIsIGUsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIiksIHQgPyB0LmNhbGwocikgOiBlLmdldChyKSksIFMgPSAociwgZSwgdCkgPT4gZS5oYXMocikgPyBwZShcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIikgOiBlIGluc3RhbmNlb2YgV2Vha1NldCA/IGUuYWRkKHIpIDogZS5zZXQociwgdCksIFogPSAociwgZSwgdCwgbikgPT4gKG9lKHIsIGUsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKSwgbiA/IG4uY2FsbChyLCB0KSA6IGUuc2V0KHIsIHQpLCB0KSwgeSA9IChyLCBlLCB0KSA9PiAob2UociwgZSwgXCJhY2Nlc3MgcHJpdmF0ZSBtZXRob2RcIiksIHQpO1xuaW1wb3J0IHsganN4IGFzIHYsIEZyYWdtZW50IGFzIHRlLCBqc3hzIGFzIGNlIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgcmUsIHsgdXNlUmVmIGFzIEIsIHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgS2UsIHVzZU1lbW8gYXMgeiwgdXNlQ2FsbGJhY2sgYXMgWmUsIHVzZUVmZmVjdCBhcyBILCB1c2VTdGF0ZSBhcyBBZSwgdXNlRGVidWdWYWx1ZSBhcyBYZSwgbWVtbyBhcyBKZSB9IGZyb20gXCJyZWFjdFwiO1xuY29uc3QgZmUgPSB7XG4gIFBSRUZFUlJFRF9GUkFNRV9TSVpFOiBcInByZWZlcnJlZC1mcmFtZS1zaXplXCIsXG4gIElOSVRJQUxfUkVOREVSX0RBVEE6IFwiaW5pdGlhbC1yZW5kZXItZGF0YVwiXG59LCBoZSA9IFwibWNwdWkuZGV2L3VpLVwiO1xuZnVuY3Rpb24gUWUocikge1xuICBsZXQgZTtcbiAgdHJ5IHtcbiAgICBlID0gbmV3IFVSTChyKTtcbiAgfSBjYXRjaCAodCkge1xuICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiRXJyb3IgcGFyc2luZyBVUkw6XCIsIHQpLCAhMTtcbiAgfVxuICByZXR1cm4gZS5wcm90b2NvbCA9PT0gXCJodHRwOlwiIHx8IGUucHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG59XG5mdW5jdGlvbiBldChyLCBlKSB7XG4gIGlmIChyLm1pbWVUeXBlICE9PSBcInRleHQvaHRtbFwiICYmIHIubWltZVR5cGUgIT09IFwidGV4dC91cmktbGlzdFwiKVxuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogXCJSZXNvdXJjZSBtdXN0IGJlIG9mIHR5cGUgdGV4dC9odG1sIChmb3IgSFRNTCBjb250ZW50KSBvciB0ZXh0L3VyaS1saXN0IChmb3IgVVJMIGNvbnRlbnQpLlwiXG4gICAgfTtcbiAgaWYgKHIubWltZVR5cGUgPT09IFwidGV4dC91cmktbGlzdFwiKSB7XG4gICAgbGV0IHQgPSBcIlwiO1xuICAgIGlmICh0eXBlb2Ygci50ZXh0ID09IFwic3RyaW5nXCIgJiYgci50ZXh0LnRyaW0oKSAhPT0gXCJcIilcbiAgICAgIHQgPSByLnRleHQ7XG4gICAgZWxzZSBpZiAodHlwZW9mIHIuYmxvYiA9PSBcInN0cmluZ1wiKVxuICAgICAgdHJ5IHtcbiAgICAgICAgdCA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShcbiAgICAgICAgICBVaW50OEFycmF5LmZyb20oYXRvYihyLmJsb2IpLCAobykgPT4gby5jaGFyQ29kZUF0KDApKVxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkVycm9yIGRlY29kaW5nIGJhc2U2NCBibG9iIGZvciBVUkwgY29udGVudDpcIiwgbyksIHtcbiAgICAgICAgICBlcnJvcjogXCJFcnJvciBkZWNvZGluZyBVUkwgZnJvbSBibG9iLlwiXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IFwiVVJMIHJlc291cmNlIGV4cGVjdHMgYSBub24tZW1wdHkgdGV4dCBvciBibG9iIGZpZWxkIGNvbnRhaW5pbmcgdGhlIFVSTC5cIlxuICAgICAgfTtcbiAgICBpZiAodC50cmltKCkgPT09IFwiXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogXCJVUkwgY29udGVudCBpcyBlbXB0eS5cIlxuICAgICAgfTtcbiAgICBjb25zdCBuID0gdC5zcGxpdChgXG5gKS5tYXAoKG8pID0+IG8udHJpbSgpKS5maWx0ZXIoKG8pID0+IG8gJiYgIW8uc3RhcnRzV2l0aChcIiNcIikgJiYgUWUobykpO1xuICAgIGlmIChuLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBcIk5vIHZhbGlkIFVSTHMgZm91bmQgaW4gdXJpLWxpc3QgY29udGVudC5cIlxuICAgICAgfTtcbiAgICBuLmxlbmd0aCA+IDEgJiYgY29uc29sZS53YXJuKFxuICAgICAgYE11bHRpcGxlIFVSTHMgZm91bmQgaW4gdXJpLWxpc3QgY29udGVudC4gVXNpbmcgdGhlIGZpcnN0IFVSTDogXCIke25bMF19XCIuIE90aGVyIFVSTHMgaWdub3JlZDpgLFxuICAgICAgbi5zbGljZSgxKVxuICAgICk7XG4gICAgY29uc3QgcyA9IG5bMF07XG4gICAgaWYgKGUgJiYgZS50cmltKCkgIT09IFwiXCIpXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvID0gbmV3IFVSTChlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiBvLmhvc3QgPT09IHdpbmRvdy5sb2NhdGlvbi5ob3N0KVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkZvciBzZWN1cml0eSwgdGhlIHByb3h5IG9yaWdpbiBtdXN0IG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgaG9zdCBvcmlnaW4uIFVzaW5nIG9yaWdpbmFsIFVSTCBpbnN0ZWFkLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiBvLnNlYXJjaFBhcmFtcy5zZXQoXCJ1cmxcIiwgcyksIHtcbiAgICAgICAgICAgIGlmcmFtZVNyYzogby50b1N0cmluZygpLFxuICAgICAgICAgICAgaWZyYW1lUmVuZGVyTW9kZTogXCJzcmNcIlxuICAgICAgICAgIH07XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgcHJveHkgVVJMIHByb3ZpZGVkOiBcIiR7ZX1cIi4gRmFsbGluZyBiYWNrIHRvIGRpcmVjdCBVUkwuYCxcbiAgICAgICAgICBvIGluc3RhbmNlb2YgRXJyb3IgPyBvLm1lc3NhZ2UgOiBTdHJpbmcobylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaWZyYW1lU3JjOiBzLFxuICAgICAgaWZyYW1lUmVuZGVyTW9kZTogXCJzcmNcIlxuICAgIH07XG4gIH0gZWxzZSBpZiAoci5taW1lVHlwZSA9PT0gXCJ0ZXh0L2h0bWxcIikge1xuICAgIGxldCB0ID0gXCJcIjtcbiAgICBpZiAodHlwZW9mIHIudGV4dCA9PSBcInN0cmluZ1wiKVxuICAgICAgdCA9IHIudGV4dDtcbiAgICBlbHNlIGlmICh0eXBlb2Ygci5ibG9iID09IFwic3RyaW5nXCIpXG4gICAgICB0cnkge1xuICAgICAgICB0ID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKFxuICAgICAgICAgIFVpbnQ4QXJyYXkuZnJvbShhdG9iKHIuYmxvYiksIChuKSA9PiBuLmNoYXJDb2RlQXQoMCkpXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiRXJyb3IgZGVjb2RpbmcgYmFzZTY0IGJsb2IgZm9yIEhUTUwgY29udGVudDpcIiwgbiksIHtcbiAgICAgICAgICBlcnJvcjogXCJFcnJvciBkZWNvZGluZyBIVE1MIGNvbnRlbnQgZnJvbSBibG9iLlwiXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IFwiSFRNTCByZXNvdXJjZSByZXF1aXJlcyB0ZXh0IG9yIGJsb2IgY29udGVudC5cIlxuICAgICAgfTtcbiAgICBpZiAoZSAmJiBlLnRyaW0oKSAhPT0gXCJcIilcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG4gPSBuZXcgVVJMKGUpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIG4uaG9zdCA9PT0gd2luZG93LmxvY2F0aW9uLmhvc3QpXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRm9yIHNlY3VyaXR5LCB0aGUgcHJveHkgb3JpZ2luIG11c3Qgbm90IGJlIHRoZSBzYW1lIGFzIHRoZSBob3N0IG9yaWdpbi4gVXNpbmcgc3JjRG9jIHJlbmRlcmluZyBpbnN0ZWFkLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiBuLnNlYXJjaFBhcmFtcy5zZXQoXCJjb250ZW50VHlwZVwiLCBcInJhd2h0bWxcIiksIHtcbiAgICAgICAgICAgIGlmcmFtZVNyYzogbi50b1N0cmluZygpLFxuICAgICAgICAgICAgaWZyYW1lUmVuZGVyTW9kZTogXCJzcmNcIixcbiAgICAgICAgICAgIGh0bWxTdHJpbmc6IHRcbiAgICAgICAgICAgIC8vIFBhc3MgSFRNTCBzbyBpdCBjYW4gYmUgc2VudCB0byB0aGUgcHJveHkgdmlhIHBvc3RNZXNzYWdlXG4gICAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgSW52YWxpZCBwcm94eSBVUkwgcHJvdmlkZWQ6IFwiJHtlfVwiLiBGYWxsaW5nIGJhY2sgdG8gc3JjRG9jIHJlbmRlcmluZy5gLFxuICAgICAgICAgIG4gaW5zdGFuY2VvZiBFcnJvciA/IG4ubWVzc2FnZSA6IFN0cmluZyhuKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIHJldHVybiB7XG4gICAgICBodG1sU3RyaW5nOiB0LFxuICAgICAgaWZyYW1lUmVuZGVyTW9kZTogXCJzcmNEb2NcIlxuICAgIH07XG4gIH0gZWxzZVxuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogXCJVbnN1cHBvcnRlZCBtaW1lVHlwZS4gRXhwZWN0ZWQgdGV4dC9odG1sIG9yIHRleHQvdXJpLWxpc3QuXCJcbiAgICB9O1xufVxuZnVuY3Rpb24gdHQocikge1xuICBpZiAodHlwZW9mIHIudGV4dCA9PSBcInN0cmluZ1wiICYmIHIudGV4dC50cmltKCkgIT09IFwiXCIpXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IHIudGV4dFxuICAgIH07XG4gIGlmICh0eXBlb2Ygci5ibG9iID09IFwic3RyaW5nXCIpXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShcbiAgICAgICAgICBVaW50OEFycmF5LmZyb20oYXRvYihyLmJsb2IpLCAodCkgPT4gdC5jaGFyQ29kZUF0KDApKVxuICAgICAgICApXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiRXJyb3IgZGVjb2RpbmcgYmFzZTY0IGJsb2IgZm9yIHJlbW90ZSBET00gY29udGVudDpcIiwgZSksIHtcbiAgICAgICAgZXJyb3I6IFwiRXJyb3IgZGVjb2RpbmcgcmVtb3RlIERPTSBjb250ZW50IGZyb20gYmxvYi5cIlxuICAgICAgfTtcbiAgICB9XG4gIHJldHVybiB7XG4gICAgZXJyb3I6IFwiUmVtb3RlIERPTSByZXNvdXJjZSByZXF1aXJlcyBub24tZW1wdHkgdGV4dCBvciBibG9iIGNvbnRlbnQuXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIHJ0KHIpIHtcbiAgcmV0dXJuIHIuX21ldGEgPz8ge307XG59XG5mdW5jdGlvbiBudChyKSB7XG4gIGNvbnN0IGUgPSBydChyKSwgdCA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoW24sIHNdKSA9PiB7XG4gICAgbi5zdGFydHNXaXRoKGhlKSAmJiAodFtuLnNsaWNlKGhlLmxlbmd0aCldID0gcyk7XG4gIH0pLCB0O1xufVxuY29uc3QgTiA9IHtcbiAgVUlfTUVTU0FHRV9SRUNFSVZFRDogXCJ1aS1tZXNzYWdlLXJlY2VpdmVkXCIsXG4gIFVJX01FU1NBR0VfUkVTUE9OU0U6IFwidWktbWVzc2FnZS1yZXNwb25zZVwiLFxuICBVSV9TSVpFX0NIQU5HRTogXCJ1aS1zaXplLWNoYW5nZVwiLFxuICBVSV9MSUZFQ1lDTEVfSUZSQU1FX1JFQURZOiBcInVpLWxpZmVjeWNsZS1pZnJhbWUtcmVhZHlcIixcbiAgVUlfTElGRUNZQ0xFX0lGUkFNRV9SRU5ERVJfREFUQTogXCJ1aS1saWZlY3ljbGUtaWZyYW1lLXJlbmRlci1kYXRhXCIsXG4gIFVJX1JFUVVFU1RfUkVOREVSX0RBVEE6IFwidWktcmVxdWVzdC1yZW5kZXItZGF0YVwiLFxuICAvLyBQcm94eS1vbmx5IGxpZmVjeWNsZSBmb3Igb3V0ZXIgaWZyYW1lIChkaXN0aW5jdCBmcm9tIHdpZGdldCByZWFkaW5lc3MpXG4gIFVJX1BST1hZX0lGUkFNRV9SRUFEWTogXCJ1aS1wcm94eS1pZnJhbWUtcmVhZHlcIixcbiAgLy8gQ29udGVudCB0cmFuc3BvcnQgZm9yIHJhdyBIVE1MIHdoZW4gdXNpbmcgcHJveHlcbiAgVUlfSFRNTF9DT05URU5UOiBcInVpLWh0bWwtY29udGVudFwiXG59LCBvdCA9IHtcbiAgV0FJVF9GT1JfUkVOREVSX0RBVEE6IFwid2FpdEZvclJlbmRlckRhdGFcIlxufSwgTmUgPSAoe1xuICByZXNvdXJjZTogcixcbiAgb25VSUFjdGlvbjogZSxcbiAgc3R5bGU6IHQsXG4gIHByb3h5OiBuLFxuICBpZnJhbWVSZW5kZXJEYXRhOiBzLFxuICBhdXRvUmVzaXplSWZyYW1lOiBvLFxuICBzYW5kYm94UGVybWlzc2lvbnM6IGEsXG4gIGlmcmFtZVByb3BzOiB1XG59KSA9PiB7XG4gIGNvbnN0IGwgPSBCKG51bGwpO1xuICBLZSh1ID09IG51bGwgPyB2b2lkIDAgOiB1LnJlZiwgKCkgPT4gbC5jdXJyZW50KTtcbiAgY29uc3QgeyBlcnJvcjogZiwgaWZyYW1lU3JjOiBpLCBpZnJhbWVSZW5kZXJNb2RlOiBtLCBodG1sU3RyaW5nOiBkIH0gPSB6KFxuICAgICgpID0+IGV0KHIsIG4pLFxuICAgIFtyLCBuXVxuICApLCBjID0geigoKSA9PiBudChyKSwgW3JdKSwgcCA9IGNbZmUuUFJFRkVSUkVEX0ZSQU1FX1NJWkVdID8/IFtcIjEwMCVcIiwgXCIxMDAlXCJdLCBoID0gY1tmZS5JTklUSUFMX1JFTkRFUl9EQVRBXSA/PyB2b2lkIDAsIEUgPSB6KCgpID0+IHtcbiAgICBpZiAoISghcyAmJiAhaCkpXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5oLFxuICAgICAgICAuLi5zXG4gICAgICB9O1xuICB9LCBbcywgaF0pLCBfID0geigoKSA9PiB7XG4gICAgaWYgKGkgJiYgRSkge1xuICAgICAgY29uc3QgVCA9IG5ldyBVUkwoaSk7XG4gICAgICByZXR1cm4gVC5zZWFyY2hQYXJhbXMuc2V0KG90LldBSVRfRk9SX1JFTkRFUl9EQVRBLCBcInRydWVcIiksIFQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH0sIFtpLCBFXSksIFIgPSBaZShcbiAgICAoVCkgPT4ge1xuICAgICAgdmFyIGo7XG4gICAgICBpZiAoRSkge1xuICAgICAgICBjb25zdCBJID0gVC5jdXJyZW50VGFyZ2V0LmNvbnRlbnRXaW5kb3csIFAgPSBfID8gbmV3IFVSTChfKS5vcmlnaW4gOiBcIipcIjtcbiAgICAgICAgVShcbiAgICAgICAgICBOLlVJX0xJRkVDWUNMRV9JRlJBTUVfUkVOREVSX0RBVEEsXG4gICAgICAgICAgSSxcbiAgICAgICAgICBQLFxuICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZW5kZXJEYXRhOiBFXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgKGogPSB1ID09IG51bGwgPyB2b2lkIDAgOiB1Lm9uTG9hZCkgPT0gbnVsbCB8fCBqLmNhbGwodSwgVCk7XG4gICAgfSxcbiAgICBbRSwgXywgdSA9PSBudWxsID8gdm9pZCAwIDogdS5vbkxvYWRdXG4gICksIEEgPSB6KCgpID0+IG0gPT09IFwic3JjRG9jXCIgPyBfZShhID8/IFwiXCIsIFwiYWxsb3ctc2NyaXB0c1wiKSA6IF9lKGEgPz8gXCJcIiwgXCJhbGxvdy1zY3JpcHRzIGFsbG93LXNhbWUtb3JpZ2luXCIpLCBbYSwgbV0pO1xuICByZXR1cm4gSCgoKSA9PiB7XG4gICAgYXN5bmMgZnVuY3Rpb24gVChqKSB7XG4gICAgICBjb25zdCB7IHNvdXJjZTogSSwgb3JpZ2luOiBQLCBkYXRhOiBnIH0gPSBqO1xuICAgICAgaWYgKGwuY3VycmVudCAmJiBJID09PSBsLmN1cnJlbnQuY29udGVudFdpbmRvdykge1xuICAgICAgICBpZiAoKGcgPT0gbnVsbCA/IHZvaWQgMCA6IGcudHlwZSkgPT09IE4uVUlfUFJPWFlfSUZSQU1FX1JFQURZKSB7XG4gICAgICAgICAgbSA9PT0gXCJzcmNcIiAmJiBkICYmIChfICE9IG51bGwgJiYgXy5pbmNsdWRlcyhcImNvbnRlbnRUeXBlPXJhd2h0bWxcIikpICYmIFUoXG4gICAgICAgICAgICBOLlVJX0hUTUxfQ09OVEVOVCxcbiAgICAgICAgICAgIEksXG4gICAgICAgICAgICBQLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBodG1sOiBkLFxuICAgICAgICAgICAgICBzYW5kYm94OiBBXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChnID09IG51bGwgPyB2b2lkIDAgOiBnLnR5cGUpID09PSBOLlVJX0xJRkVDWUNMRV9JRlJBTUVfUkVBRFkpIHtcbiAgICAgICAgICBFICYmIFUoXG4gICAgICAgICAgICBOLlVJX0xJRkVDWUNMRV9JRlJBTUVfUkVOREVSX0RBVEEsXG4gICAgICAgICAgICBJLFxuICAgICAgICAgICAgUCxcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmVuZGVyRGF0YTogRVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZyA9PSBudWxsID8gdm9pZCAwIDogZy50eXBlKSA9PT0gTi5VSV9SRVFVRVNUX1JFTkRFUl9EQVRBKSB7XG4gICAgICAgICAgVShcbiAgICAgICAgICAgIE4uVUlfTElGRUNZQ0xFX0lGUkFNRV9SRU5ERVJfREFUQSxcbiAgICAgICAgICAgIEksXG4gICAgICAgICAgICBQLFxuICAgICAgICAgICAgZy5tZXNzYWdlSWQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJlbmRlckRhdGE6IEVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGcgPT0gbnVsbCA/IHZvaWQgMCA6IGcudHlwZSkgPT09IE4uVUlfU0laRV9DSEFOR0UpIHtcbiAgICAgICAgICBjb25zdCB7IHdpZHRoOiBGLCBoZWlnaHQ6IEMgfSA9IGcucGF5bG9hZDtcbiAgICAgICAgICBpZiAobyAmJiBsLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IEhlID0gKHR5cGVvZiBvID09IFwiYm9vbGVhblwiIHx8IG8uaGVpZ2h0KSAmJiBDLCBxZSA9ICh0eXBlb2YgbyA9PSBcImJvb2xlYW5cIiB8fCBvLndpZHRoKSAmJiBGO1xuICAgICAgICAgICAgSGUgJiYgKGwuY3VycmVudC5zdHlsZS5oZWlnaHQgPSBgJHtDfXB4YCksIHFlICYmIChsLmN1cnJlbnQuc3R5bGUud2lkdGggPSBgJHtGfXB4YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZSA9IGc7XG4gICAgICAgIGlmICghbmUpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgIGNvbnN0IEYgPSBuZS5tZXNzYWdlSWQ7XG4gICAgICAgICAgVShOLlVJX01FU1NBR0VfUkVDRUlWRUQsIEksIFAsIEYpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBDID0gYXdhaXQgZShuZSk7XG4gICAgICAgICAgICBVKE4uVUlfTUVTU0FHRV9SRVNQT05TRSwgSSwgUCwgRiwge1xuICAgICAgICAgICAgICByZXNwb25zZTogQ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoQykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGhhbmRsaW5nIFVJIGFjdGlvbiByZXN1bHQgaW4gSFRNTFJlc291cmNlUmVuZGVyZXI6XCIsIEMpLCBVKE4uVUlfTUVTU0FHRV9SRVNQT05TRSwgSSwgUCwgRiwge1xuICAgICAgICAgICAgICBlcnJvcjogQ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgVCksICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBUKTtcbiAgfSwgW2UsIEUsIG0sIGQsIF8sIEFdKSwgZiA/IC8qIEBfX1BVUkVfXyAqLyB2KFwicFwiLCB7IGNsYXNzTmFtZTogXCJ0ZXh0LXJlZC01MDBcIiwgY2hpbGRyZW46IGYgfSkgOiBtID09PSBcInNyY0RvY1wiID8gZCA9PSBudWxsID8gZiA/IG51bGwgOiAvKiBAX19QVVJFX18gKi8gdihcInBcIiwgeyBjbGFzc05hbWU6IFwidGV4dC1vcmFuZ2UtNTAwXCIsIGNoaWxkcmVuOiBcIk5vIEhUTUwgY29udGVudCB0byBkaXNwbGF5LlwiIH0pIDogLyogQF9fUFVSRV9fICovIHYoXG4gICAgXCJpZnJhbWVcIixcbiAgICB7XG4gICAgICBzcmNEb2M6IGQsXG4gICAgICBzYW5kYm94OiBBLFxuICAgICAgc3R5bGU6IHsgd2lkdGg6IHBbMF0sIGhlaWdodDogcFsxXSwgLi4udCB9LFxuICAgICAgdGl0bGU6IFwiTUNQIEhUTUwgUmVzb3VyY2UgKEVtYmVkZGVkIENvbnRlbnQpXCIsXG4gICAgICAuLi51LFxuICAgICAgcmVmOiBsLFxuICAgICAgb25Mb2FkOiBSXG4gICAgfVxuICApIDogbSA9PT0gXCJzcmNcIiA/IF8gPT0gbnVsbCA/IGYgPyBudWxsIDogLyogQF9fUFVSRV9fICovIHYoXCJwXCIsIHsgY2xhc3NOYW1lOiBcInRleHQtb3JhbmdlLTUwMFwiLCBjaGlsZHJlbjogXCJObyBVUkwgcHJvdmlkZWQgZm9yIEhUTUwgcmVzb3VyY2UuXCIgfSkgOiAvKiBAX19QVVJFX18gKi8gdihcbiAgICBcImlmcmFtZVwiLFxuICAgIHtcbiAgICAgIHNyYzogXyxcbiAgICAgIHNhbmRib3g6IEEsXG4gICAgICBzdHlsZTogeyB3aWR0aDogcFswXSwgaGVpZ2h0OiBwWzFdLCAuLi50IH0sXG4gICAgICB0aXRsZTogXCJNQ1AgSFRNTCBSZXNvdXJjZSAoVVJMKVwiLFxuICAgICAgLi4udSxcbiAgICAgIHJlZjogbCxcbiAgICAgIG9uTG9hZDogUlxuICAgIH1cbiAgKSA6IC8qIEBfX1BVUkVfXyAqLyB2KFwicFwiLCB7IGNsYXNzTmFtZTogXCJ0ZXh0LWdyYXktNTAwXCIsIGNoaWxkcmVuOiBcIkluaXRpYWxpemluZyBIVE1MIHJlc291cmNlIGRpc3BsYXkuLi5cIiB9KTtcbn07XG5OZS5kaXNwbGF5TmFtZSA9IFwiSFRNTFJlc291cmNlUmVuZGVyZXJcIjtcbmZ1bmN0aW9uIFUociwgZSwgdCwgbiwgcykge1xuICBjb25zdCBvID0gdCAmJiB0ICE9PSBcIm51bGxcIiA/IHQgOiBcIipcIjtcbiAgZSA9PSBudWxsIHx8IGUucG9zdE1lc3NhZ2UoXG4gICAge1xuICAgICAgdHlwZTogcixcbiAgICAgIG1lc3NhZ2VJZDogbiA/PyB2b2lkIDAsXG4gICAgICBwYXlsb2FkOiBzXG4gICAgfSxcbiAgICBvXG4gICk7XG59XG5mdW5jdGlvbiBfZShyLCBlKSB7XG4gIHJldHVybiBbLi4uLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLnIuc3BsaXQoXCIgXCIpLCAuLi5lLnNwbGl0KFwiIFwiKV0pXS5maWx0ZXIoQm9vbGVhbikubWFwKCh0KSA9PiB0LnRyaW0oKSkuam9pbihcIiBcIik7XG59XG5jb25zdCBJZSA9IDEsIFBlID0gMywgT2UgPSA4LCBpdCA9IDksIHN0ID0gMCwgYXQgPSAxLCBsdCA9IDIsIGN0ID0gMywgJCA9IDEsIGRlID0gMiwgdWUgPSAzLCBxID0gXCJ+XCI7XG5mdW5jdGlvbiBEZSh7XG4gIGNhbGw6IHIsXG4gIGluc2VydENoaWxkOiBlLFxuICByZW1vdmVDaGlsZDogdCxcbiAgdXBkYXRlVGV4dDogbixcbiAgdXBkYXRlUHJvcGVydHk6IHNcbn0pIHtcbiAgY29uc3QgbyA9IHtcbiAgICBbc3RdOiBlLFxuICAgIFthdF06IHQsXG4gICAgW2x0XTogbixcbiAgICBbY3RdOiBzXG4gIH07XG4gIHJldHVybiB7XG4gICAgY2FsbDogcixcbiAgICBtdXRhdGUoYSkge1xuICAgICAgZm9yIChjb25zdCBbdSwgLi4ubF0gb2YgYSlcbiAgICAgICAgb1t1XSguLi5sKTtcbiAgICB9XG4gIH07XG59XG5jbGFzcyBkdCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICByZXRhaW46IGUsXG4gICAgcmVsZWFzZTogdCxcbiAgICBtZXRob2RzOiBuXG4gIH0gPSB7fSkge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgcmVtb3RlIHRyZWUuIFRoaXMgbm9kZSBpcyBhbHdheXMgZGVmaW5lZCxcbiAgICAgKiBhbmQgeW91IHdpbGwgbGlrZWx5IGJlIG1vc3QgaW50ZXJlc3RlZCBpbiBpdHMgYGNoaWxkcmVuYCBwcm9wZXJ0eSwgd2hpY2hcbiAgICAgKiBjb250YWlucyB0aGUgdG9wLWxldmVsIGVsZW1lbnRzIG9mIHRoZSByZW1vdGUgdHJlZS5cbiAgICAgKi9cbiAgICBMKHRoaXMsIFwicm9vdFwiLCB7XG4gICAgICBpZDogcSxcbiAgICAgIHR5cGU6IGl0LFxuICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgdmVyc2lvbjogMCxcbiAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBldmVudExpc3RlbmVyczoge31cbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgdGhhdCBjYW4gc3luY2hyb25pemUgYSB0cmVlIG9mIGVsZW1lbnRzIGJldHdlZW4gdHdvIEphdmFTY3JpcHRcbiAgICAgKiBlbnZpcm9ubWVudHMuIFRoaXMgb2JqZWN0IGFjdHMgYXMgYSDigJx0aGluIHdhaXN04oCdLCBhbGxvd2luZyBmb3IgZWZmaWNpZW50XG4gICAgICogY29tbXVuaWNhdGlvbiBvZiBjaGFuZ2VzIGJldHdlZW4gYSDigJxyZW1vdGXigJ0gZW52aXJvbm1lbnQgKHVzdWFsbHksIGEgSmF2YVNjcmlwdFxuICAgICAqIHNhbmRib3gsIHN1Y2ggYXMgYW4gYGlmcmFtZWAgb3IgV2ViIFdvcmtlcikgYW5kIGEg4oCcaG9zdOKAnSBlbnZpcm9ubWVudFxuICAgICAqICh1c3VhbGx5LCBhIHRvcC1sZXZlbCBicm93c2VyIHBhZ2UpLlxuICAgICAqL1xuICAgIEwodGhpcywgXCJhdHRhY2hlZFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbW3EsIHRoaXMucm9vdF1dKSk7XG4gICAgTCh0aGlzLCBcInN1YnNjcmliZXJzXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIEwodGhpcywgXCJwYXJlbnRzXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIEwodGhpcywgXCJpbXBsZW1lbnRhdGlvbnNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgY29uc3Qge1xuICAgICAgYXR0YWNoZWQ6IHMsXG4gICAgICBwYXJlbnRzOiBvLFxuICAgICAgc3Vic2NyaWJlcnM6IGFcbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBEZSh7XG4gICAgICBjYWxsOiAoaSwgbSwgLi4uZCkgPT4ge1xuICAgICAgICBjb25zdCBjID0gdGhpcy5pbXBsZW1lbnRhdGlvbnMuZ2V0KGkpLCBwID0gYyA9PSBudWxsID8gdm9pZCAwIDogY1ttXTtcbiAgICAgICAgaWYgKHR5cGVvZiBwICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgJHtpfSBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlICR7bX0oKSBtZXRob2RgKTtcbiAgICAgICAgcmV0dXJuIHAoLi4uZCk7XG4gICAgICB9LFxuICAgICAgaW5zZXJ0Q2hpbGQ6IChpLCBtLCBkKSA9PiB7XG4gICAgICAgIGNvbnN0IGMgPSBzLmdldChpKSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBwXG4gICAgICAgIH0gPSBjLCBoID0gbChtLCBjKTtcbiAgICAgICAgZCA9PT0gcC5sZW5ndGggPyBwLnB1c2goaCkgOiBwLnNwbGljZShkLCAwLCBoKSwgYy52ZXJzaW9uICs9IDEsIHRoaXMucGFyZW50cy5zZXQobS5pZCwgYy5pZCksIHUoYyk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2hpbGQ6IChpLCBtKSA9PiB7XG4gICAgICAgIGNvbnN0IGQgPSBzLmdldChpKSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBjXG4gICAgICAgIH0gPSBkLCBbcF0gPSBjLnNwbGljZShtLCAxKTtcbiAgICAgICAgcCAmJiAoZC52ZXJzaW9uICs9IDEsIHUoZCksIGYocCkpO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZVByb3BlcnR5OiAoaSwgbSwgZCwgYyA9ICQpID0+IHtcbiAgICAgICAgY29uc3QgcCA9IHMuZ2V0KGkpO1xuICAgICAgICBlID09IG51bGwgfHwgZShkKTtcbiAgICAgICAgbGV0IGg7XG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgIGNhc2UgJDpcbiAgICAgICAgICAgIGggPSBwLnByb3BlcnRpZXM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGRlOlxuICAgICAgICAgICAgaCA9IHAuYXR0cmlidXRlcztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgdWU6XG4gICAgICAgICAgICBoID0gcC5ldmVudExpc3RlbmVycztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IEUgPSBoW21dO1xuICAgICAgICBoW21dID0gZCwgcC52ZXJzaW9uICs9IDE7XG4gICAgICAgIGxldCBfO1xuICAgICAgICBpZiAobSA9PT0gXCJzbG90XCIpIHtcbiAgICAgICAgICBjb25zdCBSID0gdGhpcy5wYXJlbnRzLmdldChpKTtcbiAgICAgICAgICBfID0gUiA9PSBudWxsID8gUiA6IHMuZ2V0KFIpLCBfICYmIChfLnZlcnNpb24gKz0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdShwKSwgXyAmJiB1KF8pLCB0ID09IG51bGwgfHwgdChFKTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVUZXh0OiAoaSwgbSkgPT4ge1xuICAgICAgICBjb25zdCBkID0gcy5nZXQoaSk7XG4gICAgICAgIGQuZGF0YSA9IG0sIGQudmVyc2lvbiArPSAxLCB1KGQpO1xuICAgICAgfVxuICAgIH0pLCBuICYmIHRoaXMuaW1wbGVtZW50KHRoaXMucm9vdCwgbik7XG4gICAgZnVuY3Rpb24gdShpKSB7XG4gICAgICBjb25zdCBtID0gYS5nZXQoaS5pZCk7XG4gICAgICBpZiAobSlcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIG0pXG4gICAgICAgICAgZChpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbChpLCBtKSB7XG4gICAgICBsZXQgZDtcbiAgICAgIHN3aXRjaCAoaS50eXBlKSB7XG4gICAgICAgIGNhc2UgUGU6XG4gICAgICAgIGNhc2UgT2U6IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpZDogYyxcbiAgICAgICAgICAgIHR5cGU6IHAsXG4gICAgICAgICAgICBkYXRhOiBoXG4gICAgICAgICAgfSA9IGk7XG4gICAgICAgICAgZCA9IHtcbiAgICAgICAgICAgIGlkOiBjLFxuICAgICAgICAgICAgdHlwZTogcCxcbiAgICAgICAgICAgIGRhdGE6IGgsXG4gICAgICAgICAgICB2ZXJzaW9uOiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEllOiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaWQ6IGMsXG4gICAgICAgICAgICB0eXBlOiBwLFxuICAgICAgICAgICAgZWxlbWVudDogaCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBFLFxuICAgICAgICAgICAgcHJvcGVydGllczogXyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFIsXG4gICAgICAgICAgICBldmVudExpc3RlbmVyczogQVxuICAgICAgICAgIH0gPSBpO1xuICAgICAgICAgIGUgPT0gbnVsbCB8fCBlKF8pLCBlID09IG51bGwgfHwgZShBKTtcbiAgICAgICAgICBjb25zdCBUID0gW107XG4gICAgICAgICAgZCA9IHtcbiAgICAgICAgICAgIGlkOiBjLFxuICAgICAgICAgICAgdHlwZTogcCxcbiAgICAgICAgICAgIGVsZW1lbnQ6IGgsXG4gICAgICAgICAgICB2ZXJzaW9uOiAwLFxuICAgICAgICAgICAgY2hpbGRyZW46IFQsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIC4uLl9cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIC4uLlJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBldmVudExpc3RlbmVyczoge1xuICAgICAgICAgICAgICAuLi5BXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGogb2YgRSlcbiAgICAgICAgICAgIFQucHVzaChsKGosIGQpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBub2RlIHR5cGU6ICR7SlNPTi5zdHJpbmdpZnkoaSl9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcy5zZXQoZC5pZCwgZCksIG8uc2V0KGQuaWQsIG0uaWQpLCBkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmKGkpIHtcbiAgICAgIGlmIChzLmRlbGV0ZShpLmlkKSwgby5kZWxldGUoaS5pZCksIHQgJiYgKFwicHJvcGVydGllc1wiIGluIGkgJiYgdChpLnByb3BlcnRpZXMpLCBcImV2ZW50TGlzdGVuZXJzXCIgaW4gaSAmJiB0KGkuZXZlbnRMaXN0ZW5lcnMpKSwgXCJjaGlsZHJlblwiIGluIGkpXG4gICAgICAgIGZvciAoY29uc3QgbSBvZiBpLmNoaWxkcmVuKVxuICAgICAgICAgIGYobSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBGZXRjaGVzIHRoZSBsYXRlc3Qgc3RhdGUgb2YgYSByZW1vdGUgZWxlbWVudCB0aGF0IGhhcyBiZWVuXG4gICAqIHJlY2VpdmVkIGZyb20gdGhlIHJlbW90ZSBlbnZpcm9ubWVudC5cbiAgICpcbiAgICogQHBhcmFtIG5vZGUgVGhlIHJlbW90ZSBub2RlIHRvIGZldGNoLlxuICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgcmVtb3RlIG5vZGUsIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBub2RlIGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhlIHJlbW90ZSB0cmVlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQge1JlbW90ZVJlY2VpdmVyfSBmcm9tICdAcmVtb3RlLWRvbS9jb3JlL3JlY2VpdmVycyc7XG4gICAqXG4gICAqIGNvbnN0IHJlY2VpdmVyID0gbmV3IFJlbW90ZVJlY2VpdmVyKCk7XG4gICAqXG4gICAqIHJlY2VpdmVyLmdldChyZWNlaXZlci5yb290KSA9PT0gcmVjZWl2ZXIucm9vdDsgLy8gdHJ1ZVxuICAgKi9cbiAgZ2V0KHtcbiAgICBpZDogZVxuICB9KSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0YWNoZWQuZ2V0KGUpO1xuICB9XG4gIC8qKlxuICAgKiBMZXRzIHlvdSBkZWZpbmUgaG93IFtyZW1vdGUgbWV0aG9kc10oaHR0cHM6Ly9naXRodWIuY29tL1Nob3BpZnkvcmVtb3RlLWRvbS9ibG9iL21haW4vcGFja2FnZXMvY29yZSNyZW1vdGVtZXRob2RzKVxuICAgKiBhcmUgaW1wbGVtZW50ZWQgZm9yIGEgcGFydGljdWxhciBlbGVtZW50IGluIHRoZSB0cmVlLlxuICAgKlxuICAgKiBAcGFyYW0gbm9kZSBUaGUgcmVtb3RlIG5vZGUgdG8gc3Vic2NyaWJlIGZvciBjaGFuZ2VzLlxuICAgKiBAcGFyYW0gaW1wbGVtZW50YXRpb24gQSByZWNvcmQgY29udGFpbmluZyB0aGUgbWV0aG9kcyB0byBleHBvc2UgZm9yIHRoZSBwYXNzZWQgbm9kZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gSW4gdGhlIGhvc3QgZW52aXJvbm1lbnQ6XG4gICAqIGltcG9ydCB7UmVtb3RlUmVjZWl2ZXJ9IGZyb20gJ0ByZW1vdGUtZG9tL2NvcmUvcmVjZWl2ZXJzJztcbiAgICpcbiAgICogY29uc3QgcmVjZWl2ZXIgPSBuZXcgUmVtb3RlUmVjZWl2ZXIoKTtcbiAgICpcbiAgICogcmVjZWl2ZXIuaW1wbGVtZW50KHJlY2VpdmVyLnJvb3QsIHtcbiAgICogICBhbGVydChtZXNzYWdlKSB7XG4gICAqICAgICB3aW5kb3cuYWxlcnQobWVzc2FnZSk7XG4gICAqICAgfSxcbiAgICogfSk7XG4gICAqXG4gICAqIC8vIEluIHRoZSByZW1vdGUgZW52aXJvbm1lbnQ6XG4gICAqIGltcG9ydCB7UmVtb3RlUm9vdEVsZW1lbnR9IGZyb20gJ0ByZW1vdGUtZG9tL2NvcmUvZWxlbWVudHMnO1xuICAgKlxuICAgKiBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ3JlbW90ZS1yb290JywgUmVtb3RlUm9vdEVsZW1lbnQpO1xuICAgKlxuICAgKiBjb25zdCByb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVtb3RlLXJvb3QnKTtcbiAgICogcm9vdC5jb25uZWN0KHJlY2VpdmVyLmNvbm5lY3Rpb24pO1xuICAgKlxuICAgKiByb290LmNhbGxSZW1vdGVNZXRob2QoJ2FsZXJ0JywgJ0hlbGxvLCB3b3JsZCEnKTtcbiAgICovXG4gIGltcGxlbWVudCh7XG4gICAgaWQ6IGVcbiAgfSwgdCkge1xuICAgIHQgPT0gbnVsbCA/IHRoaXMuaW1wbGVtZW50YXRpb25zLmRlbGV0ZShlKSA6IHRoaXMuaW1wbGVtZW50YXRpb25zLnNldChlLCB0KTtcbiAgfVxuICAvKipcbiAgICogQWxsb3dzIHlvdSB0byBzdWJzY3JpYmUgdG8gY2hhbmdlcyBpbiBhIHJlbW90ZSBlbGVtZW50LiBUaGlzIGluY2x1ZGVzXG4gICAqIGNoYW5nZXMgdG8gdGhlIHJlbW90ZSBlbGVtZW504oCZcyBwcm9wZXJ0aWVzIGFuZCBsaXN0IG9mIGNoaWxkcmVuLCBidXRcbiAgICogbm90ZSB0aGF0IHlvdSB3aWxsIG5vdCByZWNlaXZlIHVwZGF0ZXMgZm9yIHByb3BlcnRpZXMgb3IgY2hpbGRyZW4gb2ZcbiAgICogX25lc3RlZF8gZWxlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlIFRoZSByZW1vdGUgbm9kZSB0byBzdWJzY3JpYmUgZm9yIGNoYW5nZXMuXG4gICAqIEBwYXJhbSBzdWJzY3JpYmVyIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cGRhdGVkIG5vZGUgb24gZWFjaCBjaGFuZ2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7UmVtb3RlUmVjZWl2ZXJ9IGZyb20gJ0ByZW1vdGUtZG9tL2NvcmUvcmVjZWl2ZXJzJztcbiAgICpcbiAgICogY29uc3QgYWJvcnQgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAqIGNvbnN0IHJlY2VpdmVyID0gbmV3IFJlbW90ZVJlY2VpdmVyKCk7XG4gICAqXG4gICAqIC8vIFN1YnNjcmliZSB0byBhbGwgY2hhbmdlcyBpbiB0aGUgdG9wLWxldmVsIGNoaWxkcmVuLCBhdHRhY2hlZFxuICAgKiAvLyBkaXJlY3RseSB0byB0aGUgcmVtb3RlIOKAnHJvb3TigJ0uXG4gICAqIHJlY2VpdmVyLnN1YnNjcmliZShcbiAgICogICByZWNlaXZlci5yb290LFxuICAgKiAgIChyb290KSA9PiB7XG4gICAqICAgICBjb25zb2xlLmxvZygnUm9vdCBjaGFuZ2VkIScsIHJvb3QpO1xuICAgKiAgIH0sXG4gICAqICAge3NpZ25hbDogYWJvcnQuc2lnbmFsfSxcbiAgICogKTtcbiAgICovXG4gIHN1YnNjcmliZSh7XG4gICAgaWQ6IGVcbiAgfSwgdCwge1xuICAgIHNpZ25hbDogblxuICB9ID0ge30pIHtcbiAgICBsZXQgcyA9IHRoaXMuc3Vic2NyaWJlcnMuZ2V0KGUpO1xuICAgIHMgPT0gbnVsbCAmJiAocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIHRoaXMuc3Vic2NyaWJlcnMuc2V0KGUsIHMpKSwgcy5hZGQodCksIG4gPT0gbnVsbCB8fCBuLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICBzLmRlbGV0ZSh0KSwgcy5zaXplID09PSAwICYmIHRoaXMuc3Vic2NyaWJlcnMuZGVsZXRlKGUpO1xuICAgIH0pO1xuICB9XG59XG5jb25zdCBFZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBYID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIENlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jbGFzcyB1dCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICByb290OiBlLFxuICAgIHJldGFpbjogdCxcbiAgICByZWxlYXNlOiBuLFxuICAgIGNhbGw6IHMsXG4gICAgY2FjaGU6IG9cbiAgfSA9IHt9KSB7XG4gICAgLyoqXG4gICAgICogVGhlIHJvb3QgZWxlbWVudCB0aGF0IHdpbGwgY29udGFpbiB0aGUgaG9zdCBpbXBsZW1lbnRhdGlvbnMgb2ZcbiAgICAgKiBhbGwgbm9kZXMgYXR0YWNoZWQgdG8gdGhlIHJlbW90ZSB0cmVlLiBUbyBjb25uZWN0IHRoZSByZWNlaXZlciB0b1xuICAgICAqIGEgbmV3IGVsZW1lbnQsIGNhbGwgdGhlIGBjb25uZWN0KClgIG1ldGhvZC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgdGhhdCBjYW4gc3luY2hyb25pemUgYSB0cmVlIG9mIGVsZW1lbnRzIGJldHdlZW4gdHdvIEphdmFTY3JpcHRcbiAgICAgKiBlbnZpcm9ubWVudHMuIFRoaXMgb2JqZWN0IGFjdHMgYXMgYSDigJx0aGluIHdhaXN04oCdLCBhbGxvd2luZyBmb3IgZWZmaWNpZW50XG4gICAgICogY29tbXVuaWNhdGlvbiBvZiBjaGFuZ2VzIGJldHdlZW4gYSDigJxyZW1vdGXigJ0gZW52aXJvbm1lbnQgKHVzdWFsbHksIGEgSmF2YVNjcmlwdFxuICAgICAqIHNhbmRib3gsIHN1Y2ggYXMgYW4gYGlmcmFtZWAgb3IgV2ViIFdvcmtlcikgYW5kIGEg4oCcaG9zdOKAnSBlbnZpcm9ubWVudFxuICAgICAqICh1c3VhbGx5LCBhIHRvcC1sZXZlbCBicm93c2VyIHBhZ2UpLlxuICAgICAqL1xuICAgIEwodGhpcywgXCJhdHRhY2hlZFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICB0aGlzLnJvb3QgPSBlID8/IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBjb25zdCB7XG4gICAgICBhdHRhY2hlZDogYVxuICAgIH0gPSB0aGlzLCB1ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBEZSh7XG4gICAgICBjYWxsOiAoaSwgbSwgLi4uZCkgPT4ge1xuICAgICAgICBjb25zdCBjID0gaSA9PT0gcSAmJiB0aGlzLnJvb3Qubm9kZVR5cGUgIT09IDExID8gdGhpcy5yb290IDogYS5nZXQoaSk7XG4gICAgICAgIHJldHVybiBzID8gcyhjLCBtLCAuLi5kKSA6IGNbbV0oLi4uZCk7XG4gICAgICB9LFxuICAgICAgaW5zZXJ0Q2hpbGQ6IChpLCBtLCBkKSA9PiB7XG4gICAgICAgIGNvbnN0IGMgPSBpID09PSBxID8gdGhpcy5yb290IDogYS5nZXQoaSksIHAgPSB1LmdldChpKTtcbiAgICAgICAgcCAmJiBjbGVhclRpbWVvdXQocCksIGMuaW5zZXJ0QmVmb3JlKGwobSksIGMuY2hpbGROb2Rlc1tkXSB8fCBudWxsKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVDaGlsZDogKGksIG0pID0+IHtcbiAgICAgICAgY29uc3QgYyA9IChpID09PSBxID8gdGhpcy5yb290IDogYS5nZXQoaSkpLmNoaWxkTm9kZXNbbV07XG4gICAgICAgIGlmIChjLnJlbW92ZSgpLCBvICE9IG51bGwgJiYgby5tYXhBZ2UpIHtcbiAgICAgICAgICBjb25zdCBwID0gdS5nZXQoaSk7XG4gICAgICAgICAgcCAmJiBjbGVhclRpbWVvdXQocCk7XG4gICAgICAgICAgY29uc3QgaCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZihjKTtcbiAgICAgICAgICB9LCBvLm1heEFnZSk7XG4gICAgICAgICAgdS5zZXQoaSwgaCk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGYoYyk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlUHJvcGVydHk6IChpLCBtLCBkLCBjID0gJCkgPT4ge1xuICAgICAgICBjb25zdCBwID0gYS5nZXQoaSk7XG4gICAgICAgIHQgPT0gbnVsbCB8fCB0KGQpO1xuICAgICAgICBjb25zdCBoID0gWC5nZXQocCksIEUgPSBoW21dO1xuICAgICAgICBoW21dID0gZCwgSihwLCBtLCBkLCBjKSwgbiA9PSBudWxsIHx8IG4oRSk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlVGV4dDogKGksIG0pID0+IHtcbiAgICAgICAgY29uc3QgZCA9IGEuZ2V0KGkpO1xuICAgICAgICBkLmRhdGEgPSBtO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGwoaSkge1xuICAgICAgY29uc3QgbSA9IGEuZ2V0KGkuaWQpO1xuICAgICAgaWYgKG0pIHJldHVybiBtO1xuICAgICAgbGV0IGQ7XG4gICAgICBzd2l0Y2ggKGkudHlwZSkge1xuICAgICAgICBjYXNlIEllOiB7XG4gICAgICAgICAgaWYgKGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGkuZWxlbWVudCksIGkucHJvcGVydGllcykge1xuICAgICAgICAgICAgWC5zZXQoZCwgaS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBPYmplY3Qua2V5cyhpLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHAgPSBpLnByb3BlcnRpZXNbY107XG4gICAgICAgICAgICAgIHQgPT0gbnVsbCB8fCB0KHApLCBKKGQsIGMsIHAsICQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgWC5zZXQoZCwge30pO1xuICAgICAgICAgIGlmIChpLmF0dHJpYnV0ZXMpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgT2JqZWN0LmtleXMoaS5hdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgICBjb25zdCBwID0gaS5hdHRyaWJ1dGVzW2NdO1xuICAgICAgICAgICAgICB0ID09IG51bGwgfHwgdChwKSwgSihkLCBjLCBwLCBkZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgaWYgKENlLnNldChkLCB7fSksIGkuZXZlbnRMaXN0ZW5lcnMpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgT2JqZWN0LmtleXMoaS5ldmVudExpc3RlbmVycykpIHtcbiAgICAgICAgICAgICAgY29uc3QgcCA9IGkuZXZlbnRMaXN0ZW5lcnNbY107XG4gICAgICAgICAgICAgIHQgPT0gbnVsbCB8fCB0KHApLCBKKGQsIGMsIHAsIHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgaS5jaGlsZHJlbilcbiAgICAgICAgICAgIGQuYXBwZW5kQ2hpbGQobChjKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBQZToge1xuICAgICAgICAgIGQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShpLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgT2U6IHtcbiAgICAgICAgICBkID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChpLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG5vZGUgdHlwZTogJHtKU09OLnN0cmluZ2lmeShpKX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBFZS5zZXQoZCwgaS5pZCksIGEuc2V0KGkuaWQsIGQpLCBkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmKGkpIHtcbiAgICAgIGNvbnN0IG0gPSBFZS5nZXQoaSk7XG4gICAgICBtICYmIGEuZGVsZXRlKG0pO1xuICAgICAgY29uc3QgZCA9IFguZ2V0KGkpO1xuICAgICAgaWYgKGQgJiYgbiAmJiBuKGQpLCBpIGluc3RhbmNlb2YgRWxlbWVudClcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGkuY2hpbGROb2RlcylcbiAgICAgICAgICBmKGMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29ubmVjdHMgdGhlIHJlY2VpdmVyIHRvIGEgbmV3IHJvb3QgZWxlbWVudC4gVGhlIHJlcHJlc2VudGF0aW9uIG9mXG4gICAqIGFueSBjaGlsZCBlbGVtZW50cyBvZiB0aGUgcmVtb3RlIHJvb3Qgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGlzIG5vZGVcbiAgICogYXMgY2hpbGRyZW4sIGFuZCB0aGUgYHJvb3RgIHByb3BlcnR5IHdpbGwgYmUgdXBkYXRlZCB0byBwb2ludCB0byB0aGVcbiAgICogbmV3IGVsZW1lbnQuXG4gICAqL1xuICBjb25uZWN0KGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5yb290O1xuICAgIHRoaXMucm9vdCA9IGUsIHQuY2hpbGROb2Rlcy5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBlLmFwcGVuZENoaWxkKG4pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyB0aGUgcmVjZWl2ZXIgZnJvbSBpdHMgY3VycmVudCByb290IGVsZW1lbnQuIEFueSBjdXJyZW50XG4gICAqIGNoaWxkcmVuIG9mIHRoZSByb290IGVsZW1lbnQgd2lsbCBiZSBtb3ZlZCB0byBhIGBEb2N1bWVudEZyYWdtZW50YFxuICAgKiBpbnN0ZWFkLCBzbyB0aGV5IGNhbiBiZSByZS1hdHRhY2hlZCB0byBhIG5ldyBlbGVtZW50IGxhdGVyLlxuICAgKi9cbiAgZGlzY29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5yb290Lm5vZGVUeXBlID09PSAxMSkgcmV0dXJuIHRoaXMucm9vdDtcbiAgICBjb25zdCBlID0gdGhpcy5yb290LCB0ID0gbmV3IERvY3VtZW50RnJhZ21lbnQoKTtcbiAgICByZXR1cm4gdGhpcy5yb290ID0gdCwgZS5jaGlsZE5vZGVzLmZvckVhY2goKG4pID0+IHtcbiAgICAgIHQuYXBwZW5kQ2hpbGQobik7XG4gICAgfSksIHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIEoociwgZSwgdCwgbikge1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlICQ6IHtcbiAgICAgIHJbZV0gPSB0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgZGU6IHtcbiAgICAgIHQgPT0gbnVsbCA/IHIucmVtb3ZlQXR0cmlidXRlKGUpIDogci5zZXRBdHRyaWJ1dGUoZSwgdCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSB1ZToge1xuICAgICAgY29uc3QgcyA9IENlLmdldChyKSwgbyA9IHMgPT0gbnVsbCA/IHZvaWQgMCA6IHNbZV07XG4gICAgICBpZiAobyAmJiByLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgbyksIHQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBhID0gKHUpID0+IHtcbiAgICAgICAgICB2YXIgZjtcbiAgICAgICAgICBpZiAodS50YXJnZXQgIT09IHIpIHJldHVybjtcbiAgICAgICAgICBjb25zdCBsID0gdCh1LmRldGFpbCk7XG4gICAgICAgICAgKGYgPSB1LnJlc29sdmUpID09IG51bGwgfHwgZi5jYWxsKHUsIGwpO1xuICAgICAgICB9O1xuICAgICAgICBzICYmIChzW2VdID0gYSksIHIuYWRkRXZlbnRMaXN0ZW5lcihlLCBhKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWUociwgZSkge1xuICBjb25zdCBbdCwgbl0gPSBBZSgoKSA9PiB7XG4gICAgY29uc3QgbyA9IGUuZ2V0KHIpO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogci5pZCxcbiAgICAgIHZlcnNpb246IG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8udmVyc2lvbixcbiAgICAgIHZhbHVlOiBvLFxuICAgICAgcmVjZWl2ZXI6IGVcbiAgICB9O1xuICB9KTtcbiAgbGV0IHMgPSB0LnZhbHVlO1xuICBpZiAodC5yZWNlaXZlciAhPT0gZSB8fCB0LmlkICE9PSByLmlkKSB7XG4gICAgY29uc3QgbyA9IGUuZ2V0KHIpO1xuICAgIHMgPSBvLCBuKHtcbiAgICAgIHJlY2VpdmVyOiBlLFxuICAgICAgaWQ6IHIuaWQsXG4gICAgICB2ZXJzaW9uOiBvID09IG51bGwgPyB2b2lkIDAgOiBvLnZlcnNpb24sXG4gICAgICB2YWx1ZTogc1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBYZShzKSwgSCgoKSA9PiB7XG4gICAgY29uc3QgbyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKSwgYSA9ICgpID0+IHtcbiAgICAgIG8uc2lnbmFsLmFib3J0ZWQgfHwgbigodSkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWQ6IGwsXG4gICAgICAgICAgdmVyc2lvbjogZixcbiAgICAgICAgICByZWNlaXZlcjogaVxuICAgICAgICB9ID0gdSwge1xuICAgICAgICAgIGlkOiBtXG4gICAgICAgIH0gPSByO1xuICAgICAgICBpZiAoaSAhPT0gZSB8fCBsICE9PSBtKVxuICAgICAgICAgIHJldHVybiB1O1xuICAgICAgICBjb25zdCBkID0gZS5nZXQociksIGMgPSBkID09IG51bGwgPyB2b2lkIDAgOiBkLnZlcnNpb247XG4gICAgICAgIHJldHVybiBmID09PSBjID8gdSA6IHtcbiAgICAgICAgICByZWNlaXZlcjogZSxcbiAgICAgICAgICB2YWx1ZTogZCxcbiAgICAgICAgICBpZDogbSxcbiAgICAgICAgICB2ZXJzaW9uOiBjXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBlLnN1YnNjcmliZShyLCBhLCB7XG4gICAgICBzaWduYWw6IG8uc2lnbmFsXG4gICAgfSksIGEoKSwgKCkgPT4ge1xuICAgICAgby5hYm9ydCgpO1xuICAgIH07XG4gIH0sIFtlLCByLmlkXSksIHM7XG59XG5mdW5jdGlvbiBtdCh7XG4gIHJlbW90ZTogcixcbiAgcmVjZWl2ZXI6IGVcbn0pIHtcbiAgY29uc3QgdCA9IG1lKHIsIGUpO1xuICByZXR1cm4gdCA/IC8qIEBfX1BVUkVfXyAqLyB2KHRlLCB7XG4gICAgY2hpbGRyZW46IHQuZGF0YVxuICB9KSA6IG51bGw7XG59XG5mdW5jdGlvbiBzZShyLCB7XG4gIHJlY2VpdmVyOiBlLFxuICBjb21wb25lbnRzOiB0XG59KSB7XG4gIHN3aXRjaCAoci50eXBlKSB7XG4gICAgY2FzZSAxOiB7XG4gICAgICBjb25zdCBuID0gdC5nZXQoci5lbGVtZW50KTtcbiAgICAgIGlmIChuID09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gY29tcG9uZW50IGZvdW5kIGZvciByZW1vdGUgZWxlbWVudDogJHtyLmVsZW1lbnR9YCk7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIHYobiwge1xuICAgICAgICBlbGVtZW50OiByLFxuICAgICAgICByZWNlaXZlcjogZSxcbiAgICAgICAgY29tcG9uZW50czogdFxuICAgICAgfSwgci5pZCk7XG4gICAgfVxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gdihtdCwge1xuICAgICAgICByZW1vdGU6IHIsXG4gICAgICAgIHJlY2VpdmVyOiBlXG4gICAgICB9LCByLmlkKTtcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHJlbW90ZSBub2RlIHR5cGU6ICR7U3RyaW5nKHIpfWApO1xuICB9XG59XG5mdW5jdGlvbiBwdChyLCBlKSB7XG4gIGlmICghcikgcmV0dXJuO1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW46IHQsXG4gICAgcHJvcGVydGllczogbixcbiAgICBhdHRyaWJ1dGVzOiBzLFxuICAgIGV2ZW50TGlzdGVuZXJzOiBvXG4gIH0gPSByLCBhID0gW10sIHUgPSB7XG4gICAgLi4ubixcbiAgICAuLi5zLFxuICAgIGNoaWxkcmVuOiBhXG4gIH07XG4gIGlmIChlLmV2ZW50UHJvcHMpXG4gICAgZm9yIChjb25zdCBbbCwgZl0gb2YgT2JqZWN0LmVudHJpZXMoZS5ldmVudFByb3BzKSkge1xuICAgICAgY29uc3QgaSA9IGYgPT0gbnVsbCA/IHZvaWQgMCA6IGYuZXZlbnQ7XG4gICAgICBpZiAoaSA9PSBudWxsKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IG0gPSBvW2ldO1xuICAgICAgbSAmJiAodVtsXSA9IGJlKG0pKTtcbiAgICB9XG4gIGVsc2VcbiAgICBmb3IgKGNvbnN0IFtsLCBmXSBvZiBPYmplY3QuZW50cmllcyhvKSlcbiAgICAgIHVbYG9uJHtsWzBdLnRvVXBwZXJDYXNlKCl9JHtsLnNsaWNlKDEpfWBdID0gYmUoZik7XG4gIGZvciAoY29uc3QgbCBvZiB0KVxuICAgIGlmIChsLnR5cGUgPT09IDEgJiYgdHlwZW9mIGwuYXR0cmlidXRlcy5zbG90ID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGYgPSBsLmF0dHJpYnV0ZXMuc2xvdCwgaSA9IHNlKGwsIGUpO1xuICAgICAgdVtmXSA9IHVbZl0gPyAvKiBAX19QVVJFX18gKi8gY2UodGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFt1W2ZdLCBpXVxuICAgICAgfSkgOiBpO1xuICAgIH0gZWxzZVxuICAgICAgYS5wdXNoKHNlKGwsIGUpKTtcbiAgcmV0dXJuIHU7XG59XG5mdW5jdGlvbiBiZShyKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi50KSB7XG4gICAgaWYgKHQubGVuZ3RoID09PSAxICYmIHRbMF0gaW5zdGFuY2VvZiBFdmVudCkge1xuICAgICAgY29uc3QgbiA9IHRbMF07XG4gICAgICByZXR1cm4gbi50YXJnZXQgIT09IG4uY3VycmVudFRhcmdldCA/IHZvaWQgMCA6IFwiZGV0YWlsXCIgaW4gbiA/IHIobi5kZXRhaWwpIDogcigpO1xuICAgIH1cbiAgICByZXR1cm4gciguLi50KTtcbiAgfTtcbn1cbmNvbnN0IGZ0ID0gU3ltYm9sLmZvcihcInJlbW90ZS1kb20uZWxlbWVudFwiKSwgaHQgPSBTeW1ib2wuZm9yKFwicmVtb3RlLWRvbS5lbGVtZW50LmF0dGFjaGVkXCIpO1xuZnVuY3Rpb24gX3Qociwge1xuICBuYW1lOiBlLFxuICBldmVudFByb3BzOiB0XG59ID0ge30pIHtcbiAgY29uc3QgbiA9IC8qIEBfX1BVUkVfXyAqLyBKZShmdW5jdGlvbih7XG4gICAgZWxlbWVudDogbyxcbiAgICByZWNlaXZlcjogYSxcbiAgICBjb21wb25lbnRzOiB1XG4gIH0pIHtcbiAgICBjb25zdCBsID0gQigpLCBmID0gbWUobywgYSksIGkgPSBmID8/IG8sIG0gPSBpLmlkLCBkID0gcHQoaSwge1xuICAgICAgcmVjZWl2ZXI6IGEsXG4gICAgICBjb21wb25lbnRzOiB1LFxuICAgICAgZXZlbnRQcm9wczogdFxuICAgIH0pO1xuICAgIGlmIChkW2Z0XSA9IGksIGRbaHRdID0gZiAhPSBudWxsLCBsLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgY29uc3QgYyA9IHtcbiAgICAgICAgaWQ6IG0sXG4gICAgICAgIHJlY2VpdmVyOiBhXG4gICAgICB9O1xuICAgICAgYy5pbnN0YW5jZVJlZiA9IEV0KGMpLCBsLmN1cnJlbnQgPSBjO1xuICAgIH1cbiAgICByZXR1cm4gbC5jdXJyZW50LmlkID0gbSwgbC5jdXJyZW50LnJlY2VpdmVyID0gYSwgSCgoKSA9PiB7XG4gICAgICB2YXIgcDtcbiAgICAgIGNvbnN0IGMgPSB7XG4gICAgICAgIGlkOiBtXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGEuaW1wbGVtZW50KGMsIChwID0gbC5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogcC5pbnN0YW5jZVJlZi5jdXJyZW50KSwgKCkgPT4ge1xuICAgICAgICBhLmltcGxlbWVudChjLCBudWxsKTtcbiAgICAgIH07XG4gICAgfSwgW20sIGFdKSwgLyogQF9fUFVSRV9fICovIHYociwge1xuICAgICAgcmVmOiBsLmN1cnJlbnQuaW5zdGFuY2VSZWYsXG4gICAgICAuLi5kXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gbi5kaXNwbGF5TmFtZSA9IGUgPz8gYFJlbW90ZUNvbXBvbmVudFJlbmRlcmVyKCR7ci5kaXNwbGF5TmFtZSA/PyByLm5hbWUgPz8gXCJDb21wb25lbnRcIn0pYCwgbjtcbn1cbmZ1bmN0aW9uIEV0KHIpIHtcbiAgbGV0IGUgPSBudWxsO1xuICByZXR1cm4ge1xuICAgIGdldCBjdXJyZW50KCkge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfSxcbiAgICBzZXQgY3VycmVudCh0KSB7XG4gICAgICBlID0gdCwgci5yZWNlaXZlci5pbXBsZW1lbnQociwgdCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYnQocikge1xuICBjb25zdCB7XG4gICAgcmVjZWl2ZXI6IGVcbiAgfSA9IHIsIHtcbiAgICBjaGlsZHJlbjogdFxuICB9ID0gbWUoZS5yb290LCBlKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB2KHRlLCB7XG4gICAgY2hpbGRyZW46IHQubWFwKChuKSA9PiBzZShuLCByKSlcbiAgfSk7XG59XG5jb25zdCB2dCA9IGA8IURPQ1RZUEUgaHRtbD5cbjxodG1sPlxuPGhlYWQ+XG4gIDxtZXRhIGNoYXJzZXQ9XCJ1dGYtOFwiPlxuPC9oZWFkPlxuPGJvZHk+XG4gIDxkaXYgaWQ9XCJyb290XCI+PC9kaXY+XG4gIDxzY3JpcHQ+XG5cInVzZSBzdHJpY3RcIjtcbigoKSA9PiB7XG4gIHZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gIHZhciBfX3R5cGVFcnJvciA9IChtc2cpID0+IHtcbiAgICB0aHJvdyBUeXBlRXJyb3IobXNnKTtcbiAgfTtcbiAgdmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xuICB2YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHZhciBfX2FjY2Vzc0NoZWNrID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IG1lbWJlci5oYXMob2JqKSB8fCBfX3R5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG4gIHZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4gKF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIiksIGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiBtZW1iZXIuZ2V0KG9iaikpO1xuICB2YXIgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4gbWVtYmVyLmhhcyhvYmopID8gX190eXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpIDogbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG4gIHZhciBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIiksIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKSwgdmFsdWUpO1xuICB2YXIgX19wcml2YXRlTWV0aG9kID0gKG9iaiwgbWVtYmVyLCBtZXRob2QpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcImFjY2VzcyBwcml2YXRlIG1ldGhvZFwiKSwgbWV0aG9kKTtcblxuICAvLyAuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlbW90ZS1kb20rY29yZUAxLjguMV9AcHJlYWN0K3NpZ25hbHMtY29yZUAxLjEwLjAvbm9kZV9tb2R1bGVzL0ByZW1vdGUtZG9tL2NvcmUvYnVpbGQvZXNtL2VsZW1lbnRzL1JlbW90ZUV2ZW50Lm1qc1xuICB2YXIgUmVtb3RlRXZlbnQgPSBjbGFzcyBleHRlbmRzIEN1c3RvbUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCB2YWx1ZSByZWNlaXZlZCBmcm9tIGEgXFxgcmVzcG9uZFdpdGgoKVxcYCBjYWxsLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIHRoZSBcXGByZXNwb25zZVxcYCB2YWx1ZSB0byBiZSBzZW50IGFzIHRoZSByZXR1cm4gdmFsdWUgZm9yXG4gICAgICogdGhlIHJlbW90ZSBwcm9wZXJ0eSBmdW5jdGlvbiB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50LlxuICAgICAqL1xuICAgIHJlc3BvbmRXaXRoKHJlc3BvbnNlKSB7XG4gICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgfVxuICB9O1xuXG4gIC8vIC4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AcmVtb3RlLWRvbStjb3JlQDEuOC4xX0BwcmVhY3Qrc2lnbmFscy1jb3JlQDEuMTAuMC9ub2RlX21vZHVsZXMvQHJlbW90ZS1kb20vY29yZS9idWlsZC9lc20vY29uc3RhbnRzLm1qc1xuICB2YXIgTVVUQVRJT05fVFlQRV9JTlNFUlRfQ0hJTEQgPSAwO1xuICB2YXIgTVVUQVRJT05fVFlQRV9SRU1PVkVfQ0hJTEQgPSAxO1xuICB2YXIgTVVUQVRJT05fVFlQRV9VUERBVEVfVEVYVCA9IDI7XG4gIHZhciBNVVRBVElPTl9UWVBFX1VQREFURV9QUk9QRVJUWSA9IDM7XG4gIHZhciBVUERBVEVfUFJPUEVSVFlfVFlQRV9QUk9QRVJUWSA9IDE7XG4gIHZhciBVUERBVEVfUFJPUEVSVFlfVFlQRV9BVFRSSUJVVEUgPSAyO1xuICB2YXIgVVBEQVRFX1BST1BFUlRZX1RZUEVfRVZFTlRfTElTVEVORVIgPSAzO1xuICB2YXIgUk9PVF9JRCA9IFwiflwiO1xuXG4gIC8vIC4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AcmVtb3RlLWRvbStjb3JlQDEuOC4xX0BwcmVhY3Qrc2lnbmFscy1jb3JlQDEuMTAuMC9ub2RlX21vZHVsZXMvQHJlbW90ZS1kb20vY29yZS9idWlsZC9lc20vZWxlbWVudHMvaW50ZXJuYWxzLm1qc1xuICB2YXIgUkVNT1RFX0NPTk5FQ1RJT05TID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIHZhciBSRU1PVEVfSURTID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIHZhciBpZCA9IDA7XG4gIGZ1bmN0aW9uIHJlbW90ZUlkKG5vZGUpIHtcbiAgICBsZXQgcmVtb3RlSUQgPSBSRU1PVEVfSURTLmdldChub2RlKTtcbiAgICBpZiAocmVtb3RlSUQgPT0gbnVsbCkge1xuICAgICAgcmVtb3RlSUQgPSBTdHJpbmcoaWQrKyk7XG4gICAgICBSRU1PVEVfSURTLnNldChub2RlLCByZW1vdGVJRCk7XG4gICAgfVxuICAgIHJldHVybiByZW1vdGVJRDtcbiAgfVxuICB2YXIgUkVNT1RFX1BST1BFUlRJRVMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgZnVuY3Rpb24gcmVtb3RlUHJvcGVydGllcyhub2RlKSB7XG4gICAgcmV0dXJuIFJFTU9URV9QUk9QRVJUSUVTLmdldChub2RlKTtcbiAgfVxuICB2YXIgUkVNT1RFX0FUVFJJQlVURVMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgZnVuY3Rpb24gcmVtb3RlQXR0cmlidXRlcyhub2RlKSB7XG4gICAgbGV0IGF0dHJpYnV0ZXMgPSBSRU1PVEVfQVRUUklCVVRFUy5nZXQobm9kZSk7XG4gICAgaWYgKGF0dHJpYnV0ZXMgIT0gbnVsbCkgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHx8IG5vZGUudGFnTmFtZS5pbmNsdWRlcyhcIi1cIikpIHJldHVybiB2b2lkIDA7XG4gICAgYXR0cmlidXRlcyA9IHt9O1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHZhbHVlXG4gICAgfSBvZiBub2RlLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gIH1cbiAgdmFyIFJFTU9URV9FVkVOVF9MSVNURU5FUlMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgZnVuY3Rpb24gcmVtb3RlRXZlbnRMaXN0ZW5lcnMobm9kZSkge1xuICAgIHJldHVybiBSRU1PVEVfRVZFTlRfTElTVEVORVJTLmdldChub2RlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVSZW1vdGVFbGVtZW50UHJvcGVydHkobm9kZSwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgbGV0IHByb3BlcnRpZXMgPSBSRU1PVEVfUFJPUEVSVElFUy5nZXQobm9kZSk7XG4gICAgaWYgKHByb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgUkVNT1RFX1BST1BFUlRJRVMuc2V0KG5vZGUsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBpZiAocHJvcGVydGllc1twcm9wZXJ0eV0gPT09IHZhbHVlKSByZXR1cm47XG4gICAgcHJvcGVydGllc1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICBjb25zdCBjb25uZWN0aW9uID0gUkVNT1RFX0NPTk5FQ1RJT05TLmdldChub2RlKTtcbiAgICBpZiAoY29ubmVjdGlvbiA9PSBudWxsKSByZXR1cm47XG4gICAgY29ubmVjdGlvbi5tdXRhdGUoW1tNVVRBVElPTl9UWVBFX1VQREFURV9QUk9QRVJUWSwgcmVtb3RlSWQobm9kZSksIHByb3BlcnR5LCB2YWx1ZSwgVVBEQVRFX1BST1BFUlRZX1RZUEVfUFJPUEVSVFldXSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUmVtb3RlRWxlbWVudEF0dHJpYnV0ZShub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgbGV0IGF0dHJpYnV0ZXMgPSBSRU1PVEVfQVRUUklCVVRFUy5nZXQobm9kZSk7XG4gICAgaWYgKGF0dHJpYnV0ZXMgPT0gbnVsbCkge1xuICAgICAgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgUkVNT1RFX0FUVFJJQlVURVMuc2V0KG5vZGUsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlc1thdHRyaWJ1dGVdID09PSB2YWx1ZSkgcmV0dXJuO1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWxldGUgYXR0cmlidXRlc1thdHRyaWJ1dGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICBjb25zdCBjb25uZWN0aW9uID0gUkVNT1RFX0NPTk5FQ1RJT05TLmdldChub2RlKTtcbiAgICBpZiAoY29ubmVjdGlvbiA9PSBudWxsKSByZXR1cm47XG4gICAgY29ubmVjdGlvbi5tdXRhdGUoW1tNVVRBVElPTl9UWVBFX1VQREFURV9QUk9QRVJUWSwgcmVtb3RlSWQobm9kZSksIGF0dHJpYnV0ZSwgdmFsdWUsIFVQREFURV9QUk9QRVJUWV9UWVBFX0FUVFJJQlVURV1dKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVSZW1vdGVFbGVtZW50RXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgICBsZXQgZXZlbnRMaXN0ZW5lcnMgPSBSRU1PVEVfRVZFTlRfTElTVEVORVJTLmdldChub2RlKTtcbiAgICBpZiAoZXZlbnRMaXN0ZW5lcnMgPT0gbnVsbCkge1xuICAgICAgZXZlbnRMaXN0ZW5lcnMgPSB7fTtcbiAgICAgIFJFTU9URV9FVkVOVF9MSVNURU5FUlMuc2V0KG5vZGUsIGV2ZW50TGlzdGVuZXJzKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50TGlzdGVuZXJzW2V2ZW50XSA9PT0gbGlzdGVuZXIpIHJldHVybjtcbiAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkge1xuICAgICAgZGVsZXRlIGV2ZW50TGlzdGVuZXJzW2V2ZW50XTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnRMaXN0ZW5lcnNbZXZlbnRdID0gbGlzdGVuZXI7XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBSRU1PVEVfQ09OTkVDVElPTlMuZ2V0KG5vZGUpO1xuICAgIGlmIChjb25uZWN0aW9uID09IG51bGwpIHJldHVybjtcbiAgICBjb25uZWN0aW9uLm11dGF0ZShbW01VVEFUSU9OX1RZUEVfVVBEQVRFX1BST1BFUlRZLCByZW1vdGVJZChub2RlKSwgZXZlbnQsIGxpc3RlbmVyLCBVUERBVEVfUFJPUEVSVFlfVFlQRV9FVkVOVF9MSVNURU5FUl1dKTtcbiAgfVxuICBmdW5jdGlvbiBjb25uZWN0UmVtb3RlTm9kZShub2RlLCBjb25uZWN0aW9uKSB7XG4gICAgY29uc3QgZXhpc3RpbmdDb25uZWN0aW9uID0gUkVNT1RFX0NPTk5FQ1RJT05TLmdldChub2RlKTtcbiAgICBpZiAoZXhpc3RpbmdDb25uZWN0aW9uID09PSBjb25uZWN0aW9uKSByZXR1cm47XG4gICAgUkVNT1RFX0NPTk5FQ1RJT05TLnNldChub2RlLCBjb25uZWN0aW9uKTtcbiAgICBpZiAobm9kZS5jaGlsZE5vZGVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25uZWN0UmVtb3RlTm9kZShub2RlLmNoaWxkTm9kZXNbaV0sIGNvbm5lY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkaXNjb25uZWN0UmVtb3RlTm9kZShub2RlKSB7XG4gICAgY29uc3QgZXhpc3RpbmdDb25uZWN0aW9uID0gUkVNT1RFX0NPTk5FQ1RJT05TLmdldChub2RlKTtcbiAgICBpZiAoZXhpc3RpbmdDb25uZWN0aW9uID09IG51bGwpIHJldHVybjtcbiAgICBSRU1PVEVfQ09OTkVDVElPTlMuZGVsZXRlKG5vZGUpO1xuICAgIGlmIChub2RlLmNoaWxkTm9kZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRpc2Nvbm5lY3RSZW1vdGVOb2RlKG5vZGUuY2hpbGROb2Rlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZVJlbW90ZU5vZGUobm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5vZGVUeXBlXG4gICAgfSA9IG5vZGU7XG4gICAgc3dpdGNoIChub2RlVHlwZSkge1xuICAgICAgLy8gRWxlbWVudFxuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IHJlbW90ZUlkKG5vZGUpLFxuICAgICAgICAgIHR5cGU6IG5vZGVUeXBlLFxuICAgICAgICAgIGVsZW1lbnQ6IG5vZGUubG9jYWxOYW1lLFxuICAgICAgICAgIHByb3BlcnRpZXM6IGNsb25lTWF5YmVPYmplY3QocmVtb3RlUHJvcGVydGllcyhub2RlKSksXG4gICAgICAgICAgYXR0cmlidXRlczogY2xvbmVNYXliZU9iamVjdChyZW1vdGVBdHRyaWJ1dGVzKG5vZGUpKSxcbiAgICAgICAgICBldmVudExpc3RlbmVyczogY2xvbmVNYXliZU9iamVjdChyZW1vdGVFdmVudExpc3RlbmVycyhub2RlKSksXG4gICAgICAgICAgY2hpbGRyZW46IEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKS5tYXAoc2VyaWFsaXplUmVtb3RlTm9kZSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8vIFRleHROb2RlXG4gICAgICBjYXNlIDM6XG4gICAgICAvLyBDb21tZW50XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgIGNhc2UgODoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiByZW1vdGVJZChub2RlKSxcbiAgICAgICAgICB0eXBlOiBub2RlVHlwZSxcbiAgICAgICAgICBkYXRhOiBub2RlLmRhdGFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcYENhbm5vdCBzZXJpYWxpemUgbm9kZSBvZiB0eXBlIFxcJHtub2RlLm5vZGVUeXBlfSAoXFwke3R5cGVvZiBub2RlLm5vZGVUeXBlfSlcXGApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjbG9uZU1heWJlT2JqZWN0KG1heWJlT2JqZWN0KSB7XG4gICAgcmV0dXJuIG1heWJlT2JqZWN0ID8ge1xuICAgICAgLi4ubWF5YmVPYmplY3RcbiAgICB9IDogdm9pZCAwO1xuICB9XG4gIGZ1bmN0aW9uIGNhbGxSZW1vdGVFbGVtZW50TWV0aG9kKG5vZGUsIG1ldGhvZCwgLi4uYXJncykge1xuICAgIGNvbnN0IGlkMiA9IFJFTU9URV9JRFMuZ2V0KG5vZGUpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBSRU1PVEVfQ09OTkVDVElPTlMuZ2V0KG5vZGUpO1xuICAgIGlmIChpZDIgPT0gbnVsbCB8fCBjb25uZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcXGBDYW5ub3QgY2FsbCBtZXRob2QgXFwke21ldGhvZH0gb24gYW4gdW5jb25uZWN0ZWQgbm9kZVxcYCk7XG4gICAgfVxuICAgIHJldHVybiBjb25uZWN0aW9uLmNhbGwoaWQyLCBtZXRob2QsIC4uLmFyZ3MpO1xuICB9XG5cbiAgLy8gLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0ByZW1vdGUtZG9tK2NvcmVAMS44LjFfQHByZWFjdCtzaWduYWxzLWNvcmVAMS4xMC4wL25vZGVfbW9kdWxlcy9AcmVtb3RlLWRvbS9jb3JlL2J1aWxkL2VzbS9lbGVtZW50cy9SZW1vdGVFbGVtZW50Lm1qc1xuICB2YXIgRU1QVFlfREVGSU5JVElPTiA9IE9iamVjdC5mcmVlemUoe30pO1xuICB2YXIgUmVtb3RlRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUoKS5fX29ic2VydmVkQXR0cmlidXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJlc29sdmVkIHByb3BlcnR5IGRlZmluaXRpb25zIGZvciB0aGlzIHJlbW90ZSBlbGVtZW50LlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgcmVtb3RlUHJvcGVydHlEZWZpbml0aW9ucygpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKCkuX19yZW1vdGVQcm9wZXJ0eURlZmluaXRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzb2x2ZWQgYXR0cmlidXRlIGRlZmluaXRpb25zIGZvciB0aGlzIHJlbW90ZSBlbGVtZW50LlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgcmVtb3RlQXR0cmlidXRlRGVmaW5pdGlvbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZSgpLl9fcmVtb3RlQXR0cmlidXRlRGVmaW5pdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByZXNvbHZlZCBldmVudCBsaXN0ZW5lciBkZWZpbml0aW9ucyBmb3IgdGhpcyByZW1vdGUgZWxlbWVudC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IHJlbW90ZUV2ZW50RGVmaW5pdGlvbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZSgpLl9fcmVtb3RlRXZlbnREZWZpbml0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJlc29sdmVkIHNsb3QgZGVmaW5pdGlvbnMgZm9yIHRoaXMgcmVtb3RlIGVsZW1lbnQuXG4gICAgICovXG4gICAgc3RhdGljIGdldCByZW1vdGVTbG90RGVmaW5pdGlvbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZSgpLl9fcmVtb3RlU2xvdERlZmluaXRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGRlZmluaXRpb24gZm9yIGEgcHJvcGVydHkgdGhhdCB3aWxsIGJlIHN5bmNocm9uaXplZCBiZXR3ZWVuXG4gICAgICogdGhpcyByZW1vdGUgZWxlbWVudCBhbmQgaXRzIGhvc3QgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVByb3BlcnR5KG5hbWUsIGRlZmluaXRpb24pIHtcbiAgICAgIHNhdmVSZW1vdGVQcm9wZXJ0eShuYW1lLCBkZWZpbml0aW9uLCB0aGlzLm9ic2VydmVkQXR0cmlidXRlcywgdGhpcy5yZW1vdGVQcm9wZXJ0eURlZmluaXRpb25zLCB0aGlzLl9fYXR0cmlidXRlVG9Qcm9wZXJ0eU1hcCwgdGhpcy5fX2V2ZW50VG9Qcm9wZXJ0eU1hcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN1bWVzIGFsbCB0aGUgc3RhdGljIG1lbWJlcnMgZGVmaW5lZCBvbiB0aGUgY2xhc3MgYW5kIGNvbnZlcnRzIHRoZW1cbiAgICAgKiBpbnRvIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiB1c2VkIHRvIGhhbmRsZSBwcm9wZXJ0aWVzLCBhdHRyaWJ1dGVzLFxuICAgICAqIGFuZCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgc3RhdGljIGZpbmFsaXplKCkge1xuICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoXCJfX2ZpbmFsaXplZFwiKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMuX19maW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzbG90dGFibGUsXG4gICAgICAgIHJlbW90ZVNsb3RzLFxuICAgICAgICByZW1vdGVQcm9wZXJ0aWVzOiByZW1vdGVQcm9wZXJ0aWVzMixcbiAgICAgICAgcmVtb3RlQXR0cmlidXRlczogcmVtb3RlQXR0cmlidXRlczIsXG4gICAgICAgIHJlbW90ZUV2ZW50cyxcbiAgICAgICAgcmVtb3RlTWV0aG9kc1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCBTdXBlckNvbnN0cnVjdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpO1xuICAgICAgY29uc3Qgb2JzZXJ2ZWRBdHRyaWJ1dGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGlmIChzbG90dGFibGUpIG9ic2VydmVkQXR0cmlidXRlcy5hZGQoXCJzbG90XCIpO1xuICAgICAgY29uc3QgYXR0cmlidXRlVG9Qcm9wZXJ0eU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBldmVudFRvUHJvcGVydHlNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgcmVtb3RlU2xvdERlZmluaXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IHJlbW90ZVByb3BlcnR5RGVmaW5pdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgcmVtb3RlQXR0cmlidXRlRGVmaW5pdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgcmVtb3RlRXZlbnREZWZpbml0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBpZiAodHlwZW9mIFN1cGVyQ29uc3RydWN0b3IuZmluYWxpemUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBTdXBlckNvbnN0cnVjdG9yLmZpbmFsaXplKCk7XG4gICAgICAgIFN1cGVyQ29uc3RydWN0b3Iub2JzZXJ2ZWRBdHRyaWJ1dGVzLmZvckVhY2goKGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgICAgIG9ic2VydmVkQXR0cmlidXRlcy5hZGQoYXR0cmlidXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFN1cGVyQ29uc3RydWN0b3IucmVtb3RlUHJvcGVydHlEZWZpbml0aW9ucy5mb3JFYWNoKChkZWZpbml0aW9uLCBwcm9wZXJ0eSkgPT4ge1xuICAgICAgICAgIHJlbW90ZVByb3BlcnR5RGVmaW5pdGlvbnMuc2V0KHByb3BlcnR5LCBkZWZpbml0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFN1cGVyQ29uc3RydWN0b3IucmVtb3RlQXR0cmlidXRlRGVmaW5pdGlvbnMuZm9yRWFjaCgoZGVmaW5pdGlvbiwgZXZlbnQpID0+IHtcbiAgICAgICAgICByZW1vdGVBdHRyaWJ1dGVEZWZpbml0aW9ucy5zZXQoZXZlbnQsIGRlZmluaXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgU3VwZXJDb25zdHJ1Y3Rvci5yZW1vdGVFdmVudERlZmluaXRpb25zLmZvckVhY2goKGRlZmluaXRpb24sIGV2ZW50KSA9PiB7XG4gICAgICAgICAgcmVtb3RlRXZlbnREZWZpbml0aW9ucy5zZXQoZXZlbnQsIGRlZmluaXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgU3VwZXJDb25zdHJ1Y3Rvci5yZW1vdGVTbG90RGVmaW5pdGlvbnMuZm9yRWFjaCgoZGVmaW5pdGlvbiwgc2xvdCkgPT4ge1xuICAgICAgICAgIHJlbW90ZVNsb3REZWZpbml0aW9ucy5zZXQoc2xvdCwgZGVmaW5pdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHJlbW90ZVNsb3RzICE9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc2xvdE5hbWVzID0gQXJyYXkuaXNBcnJheShyZW1vdGVTbG90cykgPyByZW1vdGVTbG90cyA6IE9iamVjdC5rZXlzKHJlbW90ZVNsb3RzKTtcbiAgICAgICAgc2xvdE5hbWVzLmZvckVhY2goKHNsb3ROYW1lKSA9PiB7XG4gICAgICAgICAgcmVtb3RlU2xvdERlZmluaXRpb25zLnNldChzbG90TmFtZSwgRU1QVFlfREVGSU5JVElPTik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHJlbW90ZVByb3BlcnRpZXMyICE9IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVtb3RlUHJvcGVydGllczIpKSB7XG4gICAgICAgICAgcmVtb3RlUHJvcGVydGllczIuZm9yRWFjaCgocHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICAgICAgICBzYXZlUmVtb3RlUHJvcGVydHkocHJvcGVydHlOYW1lLCB2b2lkIDAsIG9ic2VydmVkQXR0cmlidXRlcywgcmVtb3RlUHJvcGVydHlEZWZpbml0aW9ucywgYXR0cmlidXRlVG9Qcm9wZXJ0eU1hcCwgZXZlbnRUb1Byb3BlcnR5TWFwKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhyZW1vdGVQcm9wZXJ0aWVzMikuZm9yRWFjaCgocHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICAgICAgICBzYXZlUmVtb3RlUHJvcGVydHkocHJvcGVydHlOYW1lLCByZW1vdGVQcm9wZXJ0aWVzMltwcm9wZXJ0eU5hbWVdLCBvYnNlcnZlZEF0dHJpYnV0ZXMsIHJlbW90ZVByb3BlcnR5RGVmaW5pdGlvbnMsIGF0dHJpYnV0ZVRvUHJvcGVydHlNYXAsIGV2ZW50VG9Qcm9wZXJ0eU1hcCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZW1vdGVBdHRyaWJ1dGVzMiAhPSBudWxsKSB7XG4gICAgICAgIHJlbW90ZUF0dHJpYnV0ZXMyLmZvckVhY2goKGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgICAgIHJlbW90ZUF0dHJpYnV0ZURlZmluaXRpb25zLnNldChhdHRyaWJ1dGUsIEVNUFRZX0RFRklOSVRJT04pO1xuICAgICAgICAgIG9ic2VydmVkQXR0cmlidXRlcy5hZGQoYXR0cmlidXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAocmVtb3RlRXZlbnRzICE9IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVtb3RlRXZlbnRzKSkge1xuICAgICAgICAgIHJlbW90ZUV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgICAgICAgcmVtb3RlRXZlbnREZWZpbml0aW9ucy5zZXQoZXZlbnQsIEVNUFRZX0RFRklOSVRJT04pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHJlbW90ZUV2ZW50cykuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHJlbW90ZUV2ZW50RGVmaW5pdGlvbnMuc2V0KGV2ZW50LCByZW1vdGVFdmVudHNbZXZlbnRdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlbW90ZU1ldGhvZHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZW1vdGVNZXRob2RzKSkge1xuICAgICAgICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIHJlbW90ZU1ldGhvZHMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGxSZW1vdGVNZXRob2QobWV0aG9kLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcmVtb3RlTWV0aG9kcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgX19vYnNlcnZlZEF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICB2YWx1ZTogWy4uLm9ic2VydmVkQXR0cmlidXRlc10sXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgX19yZW1vdGVTbG90RGVmaW5pdGlvbnM6IHtcbiAgICAgICAgICB2YWx1ZTogcmVtb3RlU2xvdERlZmluaXRpb25zLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIF9fcmVtb3RlUHJvcGVydHlEZWZpbml0aW9uczoge1xuICAgICAgICAgIHZhbHVlOiByZW1vdGVQcm9wZXJ0eURlZmluaXRpb25zLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIF9fcmVtb3RlQXR0cmlidXRlRGVmaW5pdGlvbnM6IHtcbiAgICAgICAgICB2YWx1ZTogcmVtb3RlQXR0cmlidXRlRGVmaW5pdGlvbnMsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgX19yZW1vdGVFdmVudERlZmluaXRpb25zOiB7XG4gICAgICAgICAgdmFsdWU6IHJlbW90ZUV2ZW50RGVmaW5pdGlvbnMsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgX19hdHRyaWJ1dGVUb1Byb3BlcnR5TWFwOiB7XG4gICAgICAgICAgdmFsdWU6IGF0dHJpYnV0ZVRvUHJvcGVydHlNYXAsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgX19ldmVudFRvUHJvcGVydHlNYXA6IHtcbiAgICAgICAgICB2YWx1ZTogZXZlbnRUb1Byb3BlcnR5TWFwLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEp1c3QgbmVlZCB0byB1c2UgdGhlc2UgdHlwZXMgc28gVFMgZG9lc27igJl0IGxvc2UgdHJhY2sgb2YgdGhlbS5cbiAgICAvKiogQGludGVybmFsICovXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAvKiogQGludGVybmFsICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5maW5hbGl6ZSgpO1xuICAgICAgY29uc3QgcHJvcGVydHlEZXNjcmlwdG9ycyA9IHt9O1xuICAgICAgY29uc3QgaW5pdGlhbFByb3BlcnRpZXNUb1NldCA9IHt9O1xuICAgICAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpO1xuICAgICAgY29uc3QgVGhpc0NsYXNzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgIGZvciAoY29uc3QgW3Byb3BlcnR5LCBkZXNjcmlwdGlvbl0gb2YgVGhpc0NsYXNzLnJlbW90ZVByb3BlcnR5RGVmaW5pdGlvbnMuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IGFsaWFzZWROYW1lID0gZGVzY3JpcHRpb24ubmFtZTtcbiAgICAgICAgaWYgKHByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydHkgPT09IGFsaWFzZWROYW1lKSB7XG4gICAgICAgICAgaW5pdGlhbFByb3BlcnRpZXNUb1NldFtwcm9wZXJ0eV0gPSBkZXNjcmlwdGlvbi5kZWZhdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3BlcnR5RGVzY3JpcHRvciA9IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogcHJvcGVydHkgPT09IGFsaWFzZWROYW1lLFxuICAgICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlbW90ZVByb3BlcnRpZXModGhpcyk/LlthbGlhc2VkTmFtZV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdXBkYXRlUmVtb3RlRWxlbWVudFByb3BlcnR5KHRoaXMsIGFsaWFzZWROYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBwcm9wZXJ0eURlc2NyaXB0b3JzW3Byb3BlcnR5XSA9IHByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW2V2ZW50LCBkZWZpbml0aW9uXSBvZiBUaGlzQ2xhc3MucmVtb3RlRXZlbnREZWZpbml0aW9ucy5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlGcm9tRGVmaW5pdGlvbiA9IGRlZmluaXRpb24ucHJvcGVydHkgPz8gdHJ1ZTtcbiAgICAgICAgaWYgKCFwcm9wZXJ0eUZyb21EZWZpbml0aW9uKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBwcm9wZXJ0eUZyb21EZWZpbml0aW9uID09PSB0cnVlID8gXFxgb25cXCR7ZXZlbnR9XFxgIDogcHJvcGVydHlGcm9tRGVmaW5pdGlvbjtcbiAgICAgICAgcHJvcGVydHlEZXNjcmlwdG9yc1twcm9wZXJ0eV0gPSB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UmVtb3RlRXZlbnRzKHRoaXMpLnByb3BlcnRpZXMuZ2V0KHByb3BlcnR5KSA/PyBudWxsO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZUV2ZW50cyA9IGdldFJlbW90ZUV2ZW50cyh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMaXN0ZW5lciA9IHJlbW90ZUV2ZW50cy5wcm9wZXJ0aWVzLmdldChwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgbGV0IGhhbmRsZXIgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmNhbGwodGhpcywgLi4uYXJncyk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJlbW90ZUV2ZW50cy5wcm9wZXJ0aWVzLnNldChwcm9wZXJ0eSwgaGFuZGxlcik7XG4gICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZW1vdGVFdmVudHMucHJvcGVydGllcy5kZWxldGUocHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGN1cnJlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywgcHJvcGVydHlEZXNjcmlwdG9ycyk7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGluaXRpYWxQcm9wZXJ0aWVzVG9TZXQpO1xuICAgIH1cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0cmlidXRlLCBfb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICBpZiAoYXR0cmlidXRlID09PSBcInNsb3RcIiAmJiB0aGlzLmNvbnN0cnVjdG9yLnNsb3R0YWJsZSkge1xuICAgICAgICB1cGRhdGVSZW1vdGVFbGVtZW50QXR0cmlidXRlKHRoaXMsIGF0dHJpYnV0ZSwgbmV3VmFsdWUgPyBTdHJpbmcobmV3VmFsdWUpIDogdm9pZCAwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICByZW1vdGVQcm9wZXJ0eURlZmluaXRpb25zLFxuICAgICAgICByZW1vdGVBdHRyaWJ1dGVEZWZpbml0aW9ucyxcbiAgICAgICAgX19hdHRyaWJ1dGVUb1Byb3BlcnR5TWFwOiBhdHRyaWJ1dGVUb1Byb3BlcnR5TWFwXG4gICAgICB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChyZW1vdGVBdHRyaWJ1dGVEZWZpbml0aW9ucy5oYXMoYXR0cmlidXRlKSkge1xuICAgICAgICB1cGRhdGVSZW1vdGVFbGVtZW50QXR0cmlidXRlKHRoaXMsIGF0dHJpYnV0ZSwgbmV3VmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IGF0dHJpYnV0ZVRvUHJvcGVydHlNYXAuZ2V0KGF0dHJpYnV0ZSk7XG4gICAgICBjb25zdCBwcm9wZXJ0eURlZmluaXRpb24gPSBwcm9wZXJ0eSA9PSBudWxsID8gcHJvcGVydHkgOiByZW1vdGVQcm9wZXJ0eURlZmluaXRpb25zLmdldChwcm9wZXJ0eSk7XG4gICAgICBpZiAocHJvcGVydHlEZWZpbml0aW9uID09IG51bGwpIHJldHVybjtcbiAgICAgIHRoaXNbcHJvcGVydHldID0gY29udmVydEF0dHJpYnV0ZVZhbHVlVG9Qcm9wZXJ0eShuZXdWYWx1ZSwgcHJvcGVydHlEZWZpbml0aW9uLnR5cGUpO1xuICAgIH1cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGZvciAoY29uc3QgW2V2ZW50LCBkZXNjcmlwdG9yXSBvZiB0aGlzLmNvbnN0cnVjdG9yLnJlbW90ZUV2ZW50RGVmaW5pdGlvbnMuZW50cmllcygpKSB7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yLmJ1YmJsZXMpIHtcbiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG5vb3BCdWJibGVzRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBmb3IgKGNvbnN0IFtldmVudCwgZGVzY3JpcHRvcl0gb2YgdGhpcy5jb25zdHJ1Y3Rvci5yZW1vdGVFdmVudERlZmluaXRpb25zLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAoZGVzY3JpcHRvci5idWJibGVzKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBub29wQnViYmxlc0V2ZW50TGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVtb3RlRXZlbnREZWZpbml0aW9ucyxcbiAgICAgICAgX19ldmVudFRvUHJvcGVydHlNYXA6IGV2ZW50VG9Qcm9wZXJ0eU1hcFxuICAgICAgfSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICBjb25zdCBsaXN0ZW5lckRlZmluaXRpb24gPSByZW1vdGVFdmVudERlZmluaXRpb25zLmdldCh0eXBlKTtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gZXZlbnRUb1Byb3BlcnR5TWFwLmdldCh0eXBlKTtcbiAgICAgIGlmIChsaXN0ZW5lckRlZmluaXRpb24gPT0gbnVsbCAmJiBwcm9wZXJ0eSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbW90ZUV2ZW50cyA9IGdldFJlbW90ZUV2ZW50cyh0aGlzKTtcbiAgICAgIGNvbnN0IHJlbW90ZUV2ZW50ID0gZ2V0UmVtb3RlRXZlbnRSZWNvcmQuY2FsbCh0aGlzLCB0eXBlLCB7XG4gICAgICAgIHByb3BlcnR5LFxuICAgICAgICBkZWZpbml0aW9uOiBsaXN0ZW5lckRlZmluaXRpb25cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZExpc3RlbmVyID0gdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucz8ub25jZSA/ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHR5cGVvZiBsaXN0ZW5lciA9PT0gXCJvYmplY3RcIiA/IGxpc3RlbmVyLmhhbmRsZUV2ZW50KC4uLmFyZ3MpIDogbGlzdGVuZXIuY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgICAgICAgcmVtb3ZlUmVtb3RlTGlzdGVuZXIuY2FsbCh0aGlzLCB0eXBlLCBsaXN0ZW5lciwgbGlzdGVuZXJSZWNvcmQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSA6IGxpc3RlbmVyO1xuICAgICAgY29uc3QgbGlzdGVuZXJSZWNvcmQgPSBbbm9ybWFsaXplZExpc3RlbmVyLCByZW1vdGVFdmVudF07XG4gICAgICByZW1vdGVFdmVudC5saXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICAgIHJlbW90ZUV2ZW50cy5saXN0ZW5lcnMuc2V0KGxpc3RlbmVyLCBsaXN0ZW5lclJlY29yZCk7XG4gICAgICBzdXBlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIG5vcm1hbGl6ZWRMaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5zaWduYWwpIHtcbiAgICAgICAgb3B0aW9ucy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgICByZW1vdmVSZW1vdGVMaXN0ZW5lci5jYWxsKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBsaXN0ZW5lclJlY29yZCk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3RlbmVyRGVmaW5pdGlvbikge1xuICAgICAgICB1cGRhdGVSZW1vdGVFbGVtZW50RXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCByZW1vdGVFdmVudC5kaXNwYXRjaCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVSZW1vdGVFbGVtZW50UHJvcGVydHkodGhpcywgcHJvcGVydHksIHJlbW90ZUV2ZW50LmRpc3BhdGNoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgY29uc3QgbGlzdGVuZXJSZWNvcmQgPSBSRU1PVEVfRVZFTlRTLmdldCh0aGlzKT8ubGlzdGVuZXJzLmdldChsaXN0ZW5lcik7XG4gICAgICBjb25zdCBub3JtYWxpemVkTGlzdGVuZXIgPSBsaXN0ZW5lclJlY29yZCA/IGxpc3RlbmVyUmVjb3JkWzBdIDogbGlzdGVuZXI7XG4gICAgICBzdXBlci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIG5vcm1hbGl6ZWRMaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgICBpZiAobGlzdGVuZXJSZWNvcmQgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgcmVtb3ZlUmVtb3RlTGlzdGVuZXIuY2FsbCh0aGlzLCB0eXBlLCBsaXN0ZW5lciwgbGlzdGVuZXJSZWNvcmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgc2luZ2xlIHJlbW90ZSBwcm9wZXJ0eSBvbiBhbiBlbGVtZW50IG5vZGUuIElmIHRoZSBlbGVtZW50IGlzXG4gICAgICogY29ubmVjdGVkIHRvIGEgcmVtb3RlIHJvb3QsIHRoaXMgZnVuY3Rpb24gd2lsbCBhbHNvIG1ha2UgYSBcXGBtdXRhdGUoKVxcYCBjYWxsXG4gICAgICogdG8gY29tbXVuaWNhdGUgdGhlIGNoYW5nZSB0byB0aGUgaG9zdC5cbiAgICAgKi9cbiAgICB1cGRhdGVSZW1vdGVQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgICAgdXBkYXRlUmVtb3RlRWxlbWVudFByb3BlcnR5KHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhIHNpbmdsZSByZW1vdGUgYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQgbm9kZS4gSWYgdGhlIGVsZW1lbnQgaXNcbiAgICAgKiBjb25uZWN0ZWQgdG8gYSByZW1vdGUgcm9vdCwgdGhpcyBmdW5jdGlvbiB3aWxsIGFsc28gbWFrZSBhIFxcYG11dGF0ZSgpXFxgIGNhbGxcbiAgICAgKiB0byBjb21tdW5pY2F0ZSB0aGUgY2hhbmdlIHRvIHRoZSBob3N0LlxuICAgICAqL1xuICAgIHVwZGF0ZVJlbW90ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICAgICAgdXBkYXRlUmVtb3RlRWxlbWVudEF0dHJpYnV0ZSh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgbWV0aG9kIHRocm91Z2ggXFxgUmVtb3RlQ29ubmVjdGlvbi5jYWxsKClcXGAsIHVzaW5nIHRoZSByZW1vdGUgSUQgYW5kXG4gICAgICogY29ubmVjdGlvbiBmb3IgdGhlIHByb3ZpZGVkIG5vZGUuXG4gICAgICovXG4gICAgY2FsbFJlbW90ZU1ldGhvZChtZXRob2QsIC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiBjYWxsUmVtb3RlRWxlbWVudE1ldGhvZCh0aGlzLCBtZXRob2QsIC4uLmFyZ3MpO1xuICAgIH1cbiAgfTtcbiAgX19wdWJsaWNGaWVsZChSZW1vdGVFbGVtZW50LCBcInNsb3R0YWJsZVwiLCB0cnVlKTtcbiAgX19wdWJsaWNGaWVsZChSZW1vdGVFbGVtZW50LCBcIl9fZmluYWxpemVkXCIsIHRydWUpO1xuICBfX3B1YmxpY0ZpZWxkKFJlbW90ZUVsZW1lbnQsIFwiX19vYnNlcnZlZEF0dHJpYnV0ZXNcIiwgW10pO1xuICBfX3B1YmxpY0ZpZWxkKFJlbW90ZUVsZW1lbnQsIFwiX19hdHRyaWJ1dGVUb1Byb3BlcnR5TWFwXCIsIC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSkoKSk7XG4gIF9fcHVibGljRmllbGQoUmVtb3RlRWxlbWVudCwgXCJfX2V2ZW50VG9Qcm9wZXJ0eU1hcFwiLCAvKiBAX19QVVJFX18gKi8gKCgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpKCkpO1xuICBfX3B1YmxpY0ZpZWxkKFJlbW90ZUVsZW1lbnQsIFwiX19yZW1vdGVQcm9wZXJ0eURlZmluaXRpb25zXCIsIC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSkoKSk7XG4gIF9fcHVibGljRmllbGQoUmVtb3RlRWxlbWVudCwgXCJfX3JlbW90ZUF0dHJpYnV0ZURlZmluaXRpb25zXCIsIC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSkoKSk7XG4gIF9fcHVibGljRmllbGQoUmVtb3RlRWxlbWVudCwgXCJfX3JlbW90ZUV2ZW50RGVmaW5pdGlvbnNcIiwgLyogQF9fUFVSRV9fICovICgoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKSgpKTtcbiAgX19wdWJsaWNGaWVsZChSZW1vdGVFbGVtZW50LCBcIl9fcmVtb3RlU2xvdERlZmluaXRpb25zXCIsIC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSkoKSk7XG4gIHZhciBSRU1PVEVfRVZFTlRTID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGZ1bmN0aW9uIGdldFJlbW90ZUV2ZW50cyhlbGVtZW50KSB7XG4gICAgbGV0IGV2ZW50cyA9IFJFTU9URV9FVkVOVFMuZ2V0KGVsZW1lbnQpO1xuICAgIGlmIChldmVudHMpIHJldHVybiBldmVudHM7XG4gICAgZXZlbnRzID0ge1xuICAgICAgZXZlbnRzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgcHJvcGVydGllczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIGxpc3RlbmVyczogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKClcbiAgICB9O1xuICAgIFJFTU9URV9FVkVOVFMuc2V0KGVsZW1lbnQsIGV2ZW50cyk7XG4gICAgcmV0dXJuIGV2ZW50cztcbiAgfVxuICBmdW5jdGlvbiBnZXRSZW1vdGVFdmVudFJlY29yZCh0eXBlLCB7XG4gICAgcHJvcGVydHksXG4gICAgZGVmaW5pdGlvblxuICB9KSB7XG4gICAgY29uc3QgcmVtb3RlRXZlbnRzID0gZ2V0UmVtb3RlRXZlbnRzKHRoaXMpO1xuICAgIGxldCByZW1vdGVFdmVudCA9IHJlbW90ZUV2ZW50cy5ldmVudHMuZ2V0KHR5cGUpO1xuICAgIGlmIChyZW1vdGVFdmVudCA9PSBudWxsKSB7XG4gICAgICByZW1vdGVFdmVudCA9IHtcbiAgICAgICAgbmFtZTogdHlwZSxcbiAgICAgICAgcHJvcGVydHksXG4gICAgICAgIGRlZmluaXRpb24sXG4gICAgICAgIGxpc3RlbmVyczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgICAgZGlzcGF0Y2g6IChhcmcpID0+IHtcbiAgICAgICAgICBjb25zdCBldmVudCA9IGRlZmluaXRpb24/LmRpc3BhdGNoRXZlbnQ/LmNhbGwodGhpcywgYXJnKSA/PyBuZXcgUmVtb3RlRXZlbnQodHlwZSwge1xuICAgICAgICAgICAgZGV0YWlsOiBhcmcsXG4gICAgICAgICAgICBidWJibGVzOiBkZWZpbml0aW9uPy5idWJibGVzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICByZXR1cm4gZXZlbnQucmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZW1vdGVFdmVudHMuZXZlbnRzLnNldCh0eXBlLCByZW1vdGVFdmVudCk7XG4gICAgfVxuICAgIHJldHVybiByZW1vdGVFdmVudDtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVSZW1vdGVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgbGlzdGVuZXJSZWNvcmQpIHtcbiAgICBjb25zdCByZW1vdGVFdmVudHMgPSBnZXRSZW1vdGVFdmVudHModGhpcyk7XG4gICAgY29uc3QgcmVtb3RlRXZlbnQgPSBsaXN0ZW5lclJlY29yZFsxXTtcbiAgICByZW1vdGVFdmVudC5saXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICByZW1vdGVFdmVudHMubGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgaWYgKHJlbW90ZUV2ZW50Lmxpc3RlbmVycy5zaXplID4gMCkgcmV0dXJuO1xuICAgIHJlbW90ZUV2ZW50cy5ldmVudHMuZGVsZXRlKHR5cGUpO1xuICAgIGlmIChyZW1vdGVFdmVudC5wcm9wZXJ0eSkge1xuICAgICAgaWYgKHJlbW90ZVByb3BlcnRpZXModGhpcyk/LltyZW1vdGVFdmVudC5wcm9wZXJ0eV0gPT09IHJlbW90ZUV2ZW50LmRpc3BhdGNoKSB7XG4gICAgICAgIHVwZGF0ZVJlbW90ZUVsZW1lbnRQcm9wZXJ0eSh0aGlzLCByZW1vdGVFdmVudC5wcm9wZXJ0eSwgdm9pZCAwKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlbW90ZUV2ZW50TGlzdGVuZXJzKHRoaXMpPy5bdHlwZV0gPT09IHJlbW90ZUV2ZW50LmRpc3BhdGNoKSB7XG4gICAgICAgIHVwZGF0ZVJlbW90ZUVsZW1lbnRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIHZvaWQgMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNhdmVSZW1vdGVQcm9wZXJ0eShuYW1lLCBkZXNjcmlwdGlvbiwgb2JzZXJ2ZWRBdHRyaWJ1dGVzLCByZW1vdGVQcm9wZXJ0eURlZmluaXRpb25zLCBhdHRyaWJ1dGVUb1Byb3BlcnR5TWFwLCBldmVudFRvUHJvcGVydHlNYXApIHtcbiAgICBpZiAocmVtb3RlUHJvcGVydHlEZWZpbml0aW9ucy5oYXMobmFtZSkpIHtcbiAgICAgIHJldHVybiByZW1vdGVQcm9wZXJ0eURlZmluaXRpb25zLmdldChuYW1lKTtcbiAgICB9XG4gICAgY29uc3QgbG9va3NMaWtlRXZlbnRDYWxsYmFjayA9IG5hbWVbMF0gPT09IFwib1wiICYmIG5hbWVbMV0gPT09IFwiblwiO1xuICAgIGNvbnN0IHJlc29sdmVkRGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbiA/PyB7fTtcbiAgICBsZXQge1xuICAgICAgYWxpYXNcbiAgICB9ID0gcmVzb2x2ZWREZXNjcmlwdGlvbjtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlID0gbG9va3NMaWtlRXZlbnRDYWxsYmFjayA/IEZ1bmN0aW9uIDogU3RyaW5nLFxuICAgICAgYXR0cmlidXRlID0gdHlwZSAhPT0gRnVuY3Rpb24sXG4gICAgICBldmVudCA9IGxvb2tzTGlrZUV2ZW50Q2FsbGJhY2ssXG4gICAgICBkZWZhdWx0OiBkZWZhdWx0VmFsdWUgPSB0eXBlID09PSBCb29sZWFuID8gZmFsc2UgOiB2b2lkIDBcbiAgICB9ID0gcmVzb2x2ZWREZXNjcmlwdGlvbjtcbiAgICBpZiAoYWxpYXMgPT0gbnVsbCkge1xuICAgICAgY29uc3QgbG93ZXJjYXNlUHJvcGVydHkgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJjYXNlUHJvcGVydHkgIT09IG5hbWUpIHtcbiAgICAgICAgYWxpYXMgPSBbbG93ZXJjYXNlUHJvcGVydHldO1xuICAgICAgfVxuICAgICAgaWYgKGxvb2tzTGlrZUV2ZW50Q2FsbGJhY2spIHtcbiAgICAgICAgYWxpYXMgPz8gKGFsaWFzID0gW10pO1xuICAgICAgICBhbGlhcy51bnNoaWZ0KFxcYF9cXCR7bmFtZX1cXGApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgYXR0cmlidXRlTmFtZTtcbiAgICBpZiAoYXR0cmlidXRlID09PSB0cnVlKSB7XG4gICAgICBhdHRyaWJ1dGVOYW1lID0gY2FtZWxUb0tlYmFiQ2FzZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhdHRyaWJ1dGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGU7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYnNlcnZlZEF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIG9ic2VydmVkQXR0cmlidXRlcy5wdXNoKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JzZXJ2ZWRBdHRyaWJ1dGVzLmFkZChhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH1cbiAgICAgIGF0dHJpYnV0ZVRvUHJvcGVydHlNYXAuc2V0KGF0dHJpYnV0ZU5hbWUsIG5hbWUpO1xuICAgIH1cbiAgICBsZXQgZXZlbnROYW1lO1xuICAgIGlmIChldmVudCA9PT0gdHJ1ZSkge1xuICAgICAgZXZlbnROYW1lID0gY2FtZWxUb0tlYmFiQ2FzZShsb29rc0xpa2VFdmVudENhbGxiYWNrID8gbmFtZS5zbGljZSgyKSA6IG5hbWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBldmVudE5hbWUgPSBldmVudDtcbiAgICB9XG4gICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgZXZlbnRUb1Byb3BlcnR5TWFwLnNldChldmVudE5hbWUsIG5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBkZWZpbml0aW9uID0ge1xuICAgICAgbmFtZSxcbiAgICAgIHR5cGUsXG4gICAgICBhbGlhcyxcbiAgICAgIGV2ZW50OiBldmVudE5hbWUsXG4gICAgICBhdHRyaWJ1dGU6IGF0dHJpYnV0ZU5hbWUsXG4gICAgICBkZWZhdWx0OiBkZWZhdWx0VmFsdWVcbiAgICB9O1xuICAgIHJlbW90ZVByb3BlcnR5RGVmaW5pdGlvbnMuc2V0KG5hbWUsIGRlZmluaXRpb24pO1xuICAgIGlmIChhbGlhcykge1xuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eUFsaWFzIG9mIGFsaWFzKSB7XG4gICAgICAgIHJlbW90ZVByb3BlcnR5RGVmaW5pdGlvbnMuc2V0KHByb3BlcnR5QWxpYXMsIGRlZmluaXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBjb252ZXJ0QXR0cmlidXRlVmFsdWVUb1Byb3BlcnR5KHZhbHVlLCB0eXBlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBcImZhbHNlXCI7XG4gICAgICBjYXNlIE9iamVjdDpcbiAgICAgIGNhc2UgQXJyYXk6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICBjYXNlIFN0cmluZzpcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIGNhc2UgRnVuY3Rpb246XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHJldHVybiB0eXBlLnBhcnNlPy4odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjYW1lbFRvS2ViYWJDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgXCIkMS0kMlwiKS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIGZ1bmN0aW9uIG5vb3BCdWJibGVzRXZlbnRMaXN0ZW5lcigpIHtcbiAgfVxuXG4gIC8vIC4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AcmVtb3RlLWRvbStjb3JlQDEuOC4xX0BwcmVhY3Qrc2lnbmFscy1jb3JlQDEuMTAuMC9ub2RlX21vZHVsZXMvQHJlbW90ZS1kb20vY29yZS9idWlsZC9lc20vZWxlbWVudHMvUmVtb3RlTXV0YXRpb25PYnNlcnZlci5tanNcbiAgdmFyIFJlbW90ZU11dGF0aW9uT2JzZXJ2ZXIgPSBjbGFzcyBleHRlbmRzIE11dGF0aW9uT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24pIHtcbiAgICAgIHN1cGVyKChyZWNvcmRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGFkZGVkTm9kZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVtb3RlUmVjb3JkcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiByZWNvcmRzKSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSByZW1vdGVJZChyZWNvcmQudGFyZ2V0KTtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcmVjb3JkLnByZXZpb3VzU2libGluZyA/IGluZGV4T2YocmVjb3JkLnByZXZpb3VzU2libGluZywgcmVjb3JkLnRhcmdldC5jaGlsZE5vZGVzKSArIDEgOiAwO1xuICAgICAgICAgICAgcmVjb3JkLnJlbW92ZWROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICAgIGRpc2Nvbm5lY3RSZW1vdGVOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICByZW1vdGVSZWNvcmRzLnB1c2goW01VVEFUSU9OX1RZUEVfUkVNT1ZFX0NISUxELCB0YXJnZXRJZCwgcG9zaXRpb25dKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVjb3JkLmFkZGVkTm9kZXMuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGFkZGVkTm9kZXMuc29tZSgoYWRkZWROb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZGVkTm9kZSA9PT0gbm9kZSB8fCBhZGRlZE5vZGUuY29udGFpbnMobm9kZSk7XG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFkZGVkTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgY29ubmVjdFJlbW90ZU5vZGUobm9kZSwgY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgIHJlbW90ZVJlY29yZHMucHVzaChbTVVUQVRJT05fVFlQRV9JTlNFUlRfQ0hJTEQsIHRhcmdldElkLCBzZXJpYWxpemVSZW1vdGVOb2RlKG5vZGUpLCBwb3NpdGlvbiArIGluZGV4XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcImNoYXJhY3RlckRhdGFcIikge1xuICAgICAgICAgICAgcmVtb3RlUmVjb3Jkcy5wdXNoKFtNVVRBVElPTl9UWVBFX1VQREFURV9URVhULCB0YXJnZXRJZCwgcmVjb3JkLnRhcmdldC50ZXh0Q29udGVudCA/PyBcIlwiXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIgJiYgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgIT0gbnVsbCAmJiByZWNvcmQudGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCAmJiAhcmVjb3JkLnRhcmdldC50YWdOYW1lLmluY2x1ZGVzKFwiLVwiKSkge1xuICAgICAgICAgICAgcmVtb3RlUmVjb3Jkcy5wdXNoKFtNVVRBVElPTl9UWVBFX1VQREFURV9QUk9QRVJUWSwgdGFyZ2V0SWQsIHJlY29yZC5hdHRyaWJ1dGVOYW1lLCByZWNvcmQudGFyZ2V0LmdldEF0dHJpYnV0ZShyZWNvcmQuYXR0cmlidXRlTmFtZSldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGlvbi5tdXRhdGUocmVtb3RlUmVjb3Jkcyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB3YXRjaGluZyBjaGFuZ2VzIHRvIHRoZSBlbGVtZW50LCBhbmQgY29tbXVuaWNhdGVzIGNoYW5nZXMgdG8gdGhlXG4gICAgICogaG9zdCBlbnZpcm9ubWVudC4gQnkgZGVmYXVsdCwgdGhpcyBtZXRob2Qgd2lsbCBhbHNvIGNvbW11bmljYXRlIGFueSBpbml0aWFsXG4gICAgICogY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnQgdG8gdGhlIGhvc3QgZW52aXJvbm1lbnQuXG4gICAgICovXG4gICAgb2JzZXJ2ZSh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIFJFTU9URV9JRFMuc2V0KHRhcmdldCwgUk9PVF9JRCk7XG4gICAgICBpZiAob3B0aW9ucz8uaW5pdGlhbCAhPT0gZmFsc2UgJiYgdGFyZ2V0LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCByZWNvcmRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gdGFyZ2V0LmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgY29ubmVjdFJlbW90ZU5vZGUobm9kZSwgdGhpcy5jb25uZWN0aW9uKTtcbiAgICAgICAgICByZWNvcmRzLnB1c2goW01VVEFUSU9OX1RZUEVfSU5TRVJUX0NISUxELCBST09UX0lELCBzZXJpYWxpemVSZW1vdGVOb2RlKG5vZGUpLCBpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm11dGF0ZShyZWNvcmRzKTtcbiAgICAgIH1cbiAgICAgIHN1cGVyLm9ic2VydmUodGFyZ2V0LCB7XG4gICAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBpbmRleE9mKG5vZGUsIGxpc3QpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBub2RlKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BxdWlsdGVkK3RocmVhZHNAMy4xLjNfQHByZWFjdCtzaWduYWxzLWNvcmVAMS4xMC4wL25vZGVfbW9kdWxlcy9AcXVpbHRlZC90aHJlYWRzL2J1aWxkL2VzbS9jb25zdGFudHMubWpzXG4gIHZhciBNRVNTQUdFX0NBTEwgPSAxO1xuICB2YXIgTUVTU0FHRV9DQUxMX1JFU1VMVCA9IDI7XG4gIHZhciBNRVNTQUdFX0ZVTkNUSU9OX0NBTEwgPSAzO1xuICB2YXIgTUVTU0FHRV9GVU5DVElPTl9SRVNVTFQgPSA0O1xuICB2YXIgTUVTU0FHRV9GVU5DVElPTl9SRUxFQVNFID0gNTtcbiAgdmFyIFNFUklBTElaRV9NRVRIT0QgPSBTeW1ib2wuZm9yKFwicXVpbHQudGhyZWFkcy5zZXJpYWxpemVcIik7XG4gIHZhciBUUkFOU0ZFUkFCTEUgPSBTeW1ib2wuZm9yKFwicXVpbHQudGhyZWFkcy50cmFuc2ZlcmFibGVcIik7XG5cbiAgLy8gLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BxdWlsdGVkK2V2ZW50c0AyLjEuMy9ub2RlX21vZHVsZXMvQHF1aWx0ZWQvZXZlbnRzL2J1aWxkL2VzbS9hYm9ydC9OZXN0ZWRBYm9ydENvbnRyb2xsZXIubWpzXG4gIHZhciBOZXN0ZWRBYm9ydENvbnRyb2xsZXIgPSBjbGFzcyBleHRlbmRzIEFib3J0Q29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IoLi4ucGFyZW50cykge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIGNvbnN0IGFib3J0ZWRTaWduYWwgPSBwYXJlbnRzLmZpbmQoKHNpZ25hbCkgPT4gc2lnbmFsLmFib3J0ZWQpO1xuICAgICAgaWYgKGFib3J0ZWRTaWduYWwpIHtcbiAgICAgICAgdGhpcy5hYm9ydChhYm9ydGVkU2lnbmFsLnJlYXNvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhYm9ydCA9IChldmVudCkgPT4gdGhpcy5hYm9ydChldmVudC50YXJnZXQucmVhc29uKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzaWduYWw6IHRoaXMuc2lnbmFsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3Qgc2lnbmFsIG9mIHBhcmVudHMpIHtcbiAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyAuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHF1aWx0ZWQrdGhyZWFkc0AzLjEuM19AcHJlYWN0K3NpZ25hbHMtY29yZUAxLjEwLjAvbm9kZV9tb2R1bGVzL0BxdWlsdGVkL3RocmVhZHMvYnVpbGQvZXNtL2Vycm9ycy5tanNcbiAgdmFyIFRocmVhZENsb3NlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcihcIllvdSBhdHRlbXB0ZWQgdG8gY2FsbCBhIGZ1bmN0aW9uIG9uIGEgY2xvc2VkIHRocmVhZC5cIik7XG4gICAgfVxuICB9O1xuXG4gIC8vIC4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AcXVpbHRlZCt0aHJlYWRzQDMuMS4zX0BwcmVhY3Qrc2lnbmFscy1jb3JlQDEuMTAuMC9ub2RlX21vZHVsZXMvQHF1aWx0ZWQvdGhyZWFkcy9idWlsZC9lc20vbmFub2lkLm1qc1xuICB2YXIgYSA9IFwidXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdFwiO1xuICBmdW5jdGlvbiBuYW5vaWQoZSA9IDIxKSB7XG4gICAgbGV0IHQgPSBcIlwiLCByID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShlKSk7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBlOyBuKyspIHQgKz0gYVs2MyAmIHJbbl1dO1xuICAgIHJldHVybiB0O1xuICB9XG5cbiAgLy8gLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BxdWlsdGVkK3RocmVhZHNAMy4xLjNfQHByZWFjdCtzaWduYWxzLWNvcmVAMS4xMC4wL25vZGVfbW9kdWxlcy9AcXVpbHRlZC90aHJlYWRzL2J1aWxkL2VzbS9mdW5jdGlvbnMvVGhyZWFkRnVuY3Rpb25zQXV0b21hdGljLm1qc1xuICB2YXIgX2Z1bmN0aW9uc1RvSWQsIF9pZHNUb0Z1bmN0aW9uLCBfaWRzVG9Qcm94eSwgX2ZpbmFsaXphdGlvbiwgX1RocmVhZEZ1bmN0aW9uc0F1dG9tYXRpY19pbnN0YW5jZXMsIGZpbmFsaXphdGlvblJlZ2lzdHJ5X2ZuO1xuICB2YXIgVGhyZWFkRnVuY3Rpb25zQXV0b21hdGljID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgX19wcml2YXRlQWRkKHRoaXMsIF9UaHJlYWRGdW5jdGlvbnNBdXRvbWF0aWNfaW5zdGFuY2VzKTtcbiAgICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZnVuY3Rpb25zVG9JZCwgLyogQF9fUFVSRV9fICovICgoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKSgpKTtcbiAgICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaWRzVG9GdW5jdGlvbiwgLyogQF9fUFVSRV9fICovICgoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKSgpKTtcbiAgICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaWRzVG9Qcm94eSwgLyogQF9fUFVSRV9fICovICgoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKSgpKTtcbiAgICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZmluYWxpemF0aW9uLCAvKiBAX19QVVJFX18gKi8gKCgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKSgpKTtcbiAgICB9XG4gICAgZ2V0KGlkMikge1xuICAgICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfaWRzVG9GdW5jdGlvbikuZ2V0KGlkMik7XG4gICAgfVxuICAgIHJlbGVhc2UoaWQyKSB7XG4gICAgICBjb25zdCBmdW5jID0gX19wcml2YXRlR2V0KHRoaXMsIF9pZHNUb0Z1bmN0aW9uKS5nZXQoaWQyKTtcbiAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfaWRzVG9GdW5jdGlvbikuZGVsZXRlKGlkMik7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfZnVuY3Rpb25zVG9JZCkuZGVsZXRlKGZ1bmMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJvb2xlYW4oZnVuYyk7XG4gICAgfVxuICAgIHNlcmlhbGl6ZShmdW5jKSB7XG4gICAgICBsZXQgaWQyID0gX19wcml2YXRlR2V0KHRoaXMsIF9mdW5jdGlvbnNUb0lkKS5nZXQoZnVuYyk7XG4gICAgICBpZiAoaWQyID09IG51bGwpIHtcbiAgICAgICAgaWQyID0gbmFub2lkKCk7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfZnVuY3Rpb25zVG9JZCkuc2V0KGZ1bmMsIGlkMik7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfaWRzVG9GdW5jdGlvbikuc2V0KGlkMiwgZnVuYyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaWQyO1xuICAgIH1cbiAgICBkZXNlcmlhbGl6ZShpZDIsIHRocmVhZCkge1xuICAgICAgbGV0IHByb3h5ID0gX19wcml2YXRlR2V0KHRoaXMsIF9pZHNUb1Byb3h5KS5nZXQoaWQyKT8uZGVyZWYoKTtcbiAgICAgIGlmIChwcm94eSkgcmV0dXJuIHByb3h5O1xuICAgICAgcHJveHkgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfaWRzVG9Qcm94eSkuaGFzKGlkMikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgYXR0ZW1wdGVkIHRvIGNhbGwgYSBmdW5jdGlvbiB0aGF0IHdhcyBhbHJlYWR5IHJldm9rZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aHJlYWQuY2FsbCgoY2FsbElELCBhcmdzMiwgdHJhbnNmZXJhYmxlKSA9PiB7XG4gICAgICAgICAgdGhyZWFkLm1lc3NhZ2VzLnNlbmQoW01FU1NBR0VfRlVOQ1RJT05fQ0FMTCwgY2FsbElELCBpZDIsIGFyZ3MyXSwgdHJhbnNmZXJhYmxlKTtcbiAgICAgICAgfSwgYXJncyk7XG4gICAgICB9O1xuICAgICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UaHJlYWRGdW5jdGlvbnNBdXRvbWF0aWNfaW5zdGFuY2VzLCBmaW5hbGl6YXRpb25SZWdpc3RyeV9mbikuY2FsbCh0aGlzLCB0aHJlYWQpPy5yZWdpc3Rlcihwcm94eSwgaWQyKTtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfaWRzVG9Qcm94eSkuc2V0KGlkMiwgbmV3IFdlYWtSZWYocHJveHkpKTtcbiAgICAgIHJldHVybiBwcm94eTtcbiAgICB9XG4gIH07XG4gIF9mdW5jdGlvbnNUb0lkID0gbmV3IFdlYWtNYXAoKTtcbiAgX2lkc1RvRnVuY3Rpb24gPSBuZXcgV2Vha01hcCgpO1xuICBfaWRzVG9Qcm94eSA9IG5ldyBXZWFrTWFwKCk7XG4gIF9maW5hbGl6YXRpb24gPSBuZXcgV2Vha01hcCgpO1xuICBfVGhyZWFkRnVuY3Rpb25zQXV0b21hdGljX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCk7XG4gIGZpbmFsaXphdGlvblJlZ2lzdHJ5X2ZuID0gZnVuY3Rpb24odGhyZWFkKSB7XG4gICAgbGV0IGZpbmFsaXphdGlvbiA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfZmluYWxpemF0aW9uKS5nZXQodGhyZWFkKTtcbiAgICBpZiAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoIWZpbmFsaXphdGlvbikge1xuICAgICAgZmluYWxpemF0aW9uID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KChpZDIpID0+IHtcbiAgICAgICAgdGhyZWFkLm1lc3NhZ2VzLnNlbmQoW01FU1NBR0VfRlVOQ1RJT05fUkVMRUFTRSwgaWQyXSk7XG4gICAgICB9KTtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfZmluYWxpemF0aW9uKS5zZXQodGhyZWFkLCBmaW5hbGl6YXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gZmluYWxpemF0aW9uO1xuICB9O1xuXG4gIC8vIC4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AcXVpbHRlZCt0aHJlYWRzQDMuMS4zX0BwcmVhY3Qrc2lnbmFscy1jb3JlQDEuMTAuMC9ub2RlX21vZHVsZXMvQHF1aWx0ZWQvdGhyZWFkcy9idWlsZC9lc20vc2VyaWFsaXphdGlvbi9zaGFyZWQubWpzXG4gIGZ1bmN0aW9uIGlzSXRlcmF0b3IodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gdmFsdWUgfHwgU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUubmV4dCA9PT0gXCJmdW5jdGlvblwiO1xuICB9XG4gIGZ1bmN0aW9uIGlzQmFzaWNPYmplY3QodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICAgIHJldHVybiBwcm90b3R5cGUgPT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG4gIH1cblxuICAvLyAuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHF1aWx0ZWQrdGhyZWFkc0AzLjEuM19AcHJlYWN0K3NpZ25hbHMtY29yZUAxLjEwLjAvbm9kZV9tb2R1bGVzL0BxdWlsdGVkL3RocmVhZHMvYnVpbGQvZXNtL3NlcmlhbGl6YXRpb24vVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZS5tanNcbiAgdmFyIEZVTkNUSU9OID0gXCJfQGZcIjtcbiAgdmFyIEFTWU5DX0lURVJBVE9SID0gXCJfQGlcIjtcbiAgdmFyIF9jdXN0b21TZXJpYWxpemVyLCBfY3VzdG9tRGVzZXJpYWxpemVyLCBfVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZV9pbnN0YW5jZXMsIHNlcmlhbGl6ZUludGVybmFsX2ZuLCBkZXNlcmlhbGl6ZUludGVybmFsX2ZuO1xuICB2YXIgVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZSA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICBfX3ByaXZhdGVBZGQodGhpcywgX1RocmVhZFNlcmlhbGl6YXRpb25TdHJ1Y3R1cmVkQ2xvbmVfaW5zdGFuY2VzKTtcbiAgICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfY3VzdG9tU2VyaWFsaXplcik7XG4gICAgICBfX3ByaXZhdGVBZGQodGhpcywgX2N1c3RvbURlc2VyaWFsaXplcik7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2N1c3RvbVNlcmlhbGl6ZXIsIG9wdGlvbnM/LnNlcmlhbGl6ZSk7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2N1c3RvbURlc2VyaWFsaXplciwgb3B0aW9ucz8uZGVzZXJpYWxpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIGEgdmFsdWUgaW50byBhIHN0cnVjdHVyZWQgY2xvbmluZy1jb21wYXRpYmxlIGZvcm1hdCB0aGF0IGNhbiBiZSB0cmFuc2ZlcnJlZCBiZXR3ZWVuIHRocmVhZHMuXG4gICAgICovXG4gICAgc2VyaWFsaXplKHZhbHVlLCB0aHJlYWQsIHRyYW5zZmVyYWJsZSkge1xuICAgICAgcmV0dXJuIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZV9pbnN0YW5jZXMsIHNlcmlhbGl6ZUludGVybmFsX2ZuKS5jYWxsKHRoaXMsIHZhbHVlLCB0aHJlYWQsIHRyYW5zZmVyYWJsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc2VyaWFsaXplcyBhIHN0cnVjdHVyZWQgY2xvbmluZy1jb21wYXRpYmxlIHZhbHVlIGZyb20gYW5vdGhlciB0aHJlYWQuXG4gICAgICovXG4gICAgZGVzZXJpYWxpemUodmFsdWUsIHRocmVhZCkge1xuICAgICAgcmV0dXJuIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZV9pbnN0YW5jZXMsIGRlc2VyaWFsaXplSW50ZXJuYWxfZm4pLmNhbGwodGhpcywgdmFsdWUsIHRocmVhZCk7XG4gICAgfVxuICB9O1xuICBfY3VzdG9tU2VyaWFsaXplciA9IG5ldyBXZWFrTWFwKCk7XG4gIF9jdXN0b21EZXNlcmlhbGl6ZXIgPSBuZXcgV2Vha01hcCgpO1xuICBfVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZV9pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpO1xuICBzZXJpYWxpemVJbnRlcm5hbF9mbiA9IGZ1bmN0aW9uKHZhbHVlLCB0aHJlYWQsIHRyYW5zZmVyYWJsZSwgc2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIGlzQXBwbHlpbmdEZWZhdWx0ID0gZmFsc2UpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHZhbHVlO1xuICAgIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHJldHVybiBzZWVuLmdldCh2YWx1ZSk7XG4gICAgc2Vlbi5zZXQodmFsdWUsIHZvaWQgMCk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfY3VzdG9tU2VyaWFsaXplcikgJiYgIWlzQXBwbHlpbmdEZWZhdWx0KSB7XG4gICAgICAgIGNvbnN0IGN1c3RvbVZhbHVlID0gX19wcml2YXRlR2V0KHRoaXMsIF9jdXN0b21TZXJpYWxpemVyKS5jYWxsKHRoaXMsIHZhbHVlLCAodmFsdWUyKSA9PiBfX3ByaXZhdGVNZXRob2QodGhpcywgX1RocmVhZFNlcmlhbGl6YXRpb25TdHJ1Y3R1cmVkQ2xvbmVfaW5zdGFuY2VzLCBzZXJpYWxpemVJbnRlcm5hbF9mbikuY2FsbCh0aGlzLCB2YWx1ZTIsIHRocmVhZCwgdHJhbnNmZXJhYmxlLCBzZWVuLCB0cnVlKSwgdGhyZWFkLCB0cmFuc2ZlcmFibGUpO1xuICAgICAgICBpZiAoY3VzdG9tVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHNlZW4uc2V0KHZhbHVlLCBjdXN0b21WYWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIGN1c3RvbVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVbVFJBTlNGRVJBQkxFXSkge1xuICAgICAgICB0cmFuc2ZlcmFibGU/LnB1c2godmFsdWUpO1xuICAgICAgICBzZWVuLnNldCh2YWx1ZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzZXJpYWxpemVWYWx1ZSA9ICh2YWx1ZTIpID0+IHtcbiAgICAgICAgcmV0dXJuIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZV9pbnN0YW5jZXMsIHNlcmlhbGl6ZUludGVybmFsX2ZuKS5jYWxsKHRoaXMsIHZhbHVlMiwgdGhyZWFkLCB0cmFuc2ZlcmFibGUsIHNlZW4pO1xuICAgICAgfTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVbU0VSSUFMSVpFX01FVEhPRF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZVtTRVJJQUxJWkVfTUVUSE9EXSh7XG4gICAgICAgICAgc2VyaWFsaXplOiBzZXJpYWxpemVWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgc2Vlbi5zZXQodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUubWFwKChpdGVtKSA9PiBzZXJpYWxpemVWYWx1ZShpdGVtKSk7XG4gICAgICAgIHNlZW4uc2V0KHZhbHVlLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBbLi4udmFsdWUuZW50cmllcygpXS5tYXAoKFtrZXksIHZhbHVlMl0pID0+IHtcbiAgICAgICAgICByZXR1cm4gW3NlcmlhbGl6ZVZhbHVlKGtleSksIHNlcmlhbGl6ZVZhbHVlKHZhbHVlMildO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcChlbnRyaWVzKTtcbiAgICAgICAgc2Vlbi5zZXQodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IFsuLi52YWx1ZV0ubWFwKChlbnRyeSkgPT4gc2VyaWFsaXplVmFsdWUoZW50cnkpKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldChlbnRyaWVzKTtcbiAgICAgICAgc2Vlbi5zZXQodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZUlzSXRlcmF0b3IgPSBpc0l0ZXJhdG9yKHZhbHVlKTtcbiAgICAgIGlmIChpc0Jhc2ljT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZUlzSXRlcmF0b3IpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gc2VyaWFsaXplVmFsdWUodmFsdWVba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlSXNJdGVyYXRvcikge1xuICAgICAgICAgIHJlc3VsdC5uZXh0ID8/IChyZXN1bHQubmV4dCA9IHNlcmlhbGl6ZVZhbHVlKHZhbHVlLm5leHQuYmluZCh2YWx1ZSkpKTtcbiAgICAgICAgICByZXN1bHQucmV0dXJuID8/IChyZXN1bHQucmV0dXJuID0gc2VyaWFsaXplVmFsdWUodmFsdWUucmV0dXJuLmJpbmQodmFsdWUpKSk7XG4gICAgICAgICAgcmVzdWx0LnRocm93ID8/IChyZXN1bHQudGhyb3cgPSBzZXJpYWxpemVWYWx1ZSh2YWx1ZS50aHJvdy5iaW5kKHZhbHVlKSkpO1xuICAgICAgICAgIHJlc3VsdFtBU1lOQ19JVEVSQVRPUl0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4uc2V0KHZhbHVlLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB0aHJlYWQuZnVuY3Rpb25zLnNlcmlhbGl6ZSh2YWx1ZSwgdGhyZWFkLCB0cmFuc2ZlcmFibGUpO1xuICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBbRlVOQ1RJT05dOiBzZXJpYWxpemVkXG4gICAgICB9O1xuICAgICAgc2Vlbi5zZXQodmFsdWUsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzZWVuLnNldCh2YWx1ZSwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgZGVzZXJpYWxpemVJbnRlcm5hbF9mbiA9IGZ1bmN0aW9uKHZhbHVlLCB0aHJlYWQsIGlzQXBwbHlpbmdEZWZhdWx0ID0gZmFsc2UpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX2N1c3RvbURlc2VyaWFsaXplcikgJiYgIWlzQXBwbHlpbmdEZWZhdWx0KSB7XG4gICAgICAgIGNvbnN0IGN1c3RvbVZhbHVlID0gX19wcml2YXRlR2V0KHRoaXMsIF9jdXN0b21EZXNlcmlhbGl6ZXIpLmNhbGwodGhpcywgdmFsdWUsICh2YWx1ZTIpID0+IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZV9pbnN0YW5jZXMsIGRlc2VyaWFsaXplSW50ZXJuYWxfZm4pLmNhbGwodGhpcywgdmFsdWUyLCB0aHJlYWQsIHRydWUpLCB0aHJlYWQpO1xuICAgICAgICBpZiAoY3VzdG9tVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBjdXN0b21WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHZhbHVlMikgPT4gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UaHJlYWRTZXJpYWxpemF0aW9uU3RydWN0dXJlZENsb25lX2luc3RhbmNlcywgZGVzZXJpYWxpemVJbnRlcm5hbF9mbikuY2FsbCh0aGlzLCB2YWx1ZTIsIHRocmVhZCkpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKFsuLi52YWx1ZV0ubWFwKChba2V5LCB2YWx1ZTJdKSA9PiBbX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UaHJlYWRTZXJpYWxpemF0aW9uU3RydWN0dXJlZENsb25lX2luc3RhbmNlcywgZGVzZXJpYWxpemVJbnRlcm5hbF9mbikuY2FsbCh0aGlzLCBrZXksIHRocmVhZCksIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZV9pbnN0YW5jZXMsIGRlc2VyaWFsaXplSW50ZXJuYWxfZm4pLmNhbGwodGhpcywgdmFsdWUyLCB0aHJlYWQpXSkpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2V0KFsuLi52YWx1ZV0ubWFwKChlbnRyeSkgPT4gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UaHJlYWRTZXJpYWxpemF0aW9uU3RydWN0dXJlZENsb25lX2luc3RhbmNlcywgZGVzZXJpYWxpemVJbnRlcm5hbF9mbikuY2FsbCh0aGlzLCBlbnRyeSwgdGhyZWFkKSkpO1xuICAgICAgfVxuICAgICAgaWYgKEZVTkNUSU9OIGluIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSB0aHJlYWQuZnVuY3Rpb25zLmRlc2VyaWFsaXplKHZhbHVlW0ZVTkNUSU9OXSwgdGhyZWFkKTtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQmFzaWNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModmFsdWUpKSB7XG4gICAgICAgIGlmIChrZXkgPT09IEFTWU5DX0lURVJBVE9SKSB7XG4gICAgICAgICAgcmVzdWx0W1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9ICgpID0+IHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZV9pbnN0YW5jZXMsIGRlc2VyaWFsaXplSW50ZXJuYWxfZm4pLmNhbGwodGhpcywgdmFsdWVba2V5XSwgdGhyZWFkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8vIC4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AcXVpbHRlZCt0aHJlYWRzQDMuMS4zX0BwcmVhY3Qrc2lnbmFscy1jb3JlQDEuMTAuMC9ub2RlX21vZHVsZXMvQHF1aWx0ZWQvdGhyZWFkcy9idWlsZC9lc20vVGhyZWFkLm1qc1xuICB2YXIgX2Fib3J0LCBfaWRzVG9SZXNvbHZlciwgX1RocmVhZF9pbnN0YW5jZXMsIGNhbGxMb2NhbF9mbiwgaGFuZGxlckZvckNhbGxfZm4sIHJlc29sdmVDYWxsX2ZuLCB3YWl0Rm9yUmVzdWx0X2ZuO1xuICB2YXIgVGhyZWFkID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2VzLCB7XG4gICAgICBpbXBvcnRzLFxuICAgICAgZXhwb3J0cyxcbiAgICAgIGZ1bmN0aW9ucyA9IG5ldyBUaHJlYWRGdW5jdGlvbnNBdXRvbWF0aWMoKSxcbiAgICAgIHNlcmlhbGl6YXRpb24gPSBuZXcgVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZSgpLFxuICAgICAgc2lnbmFsXG4gICAgfSA9IHt9KSB7XG4gICAgICBfX3ByaXZhdGVBZGQodGhpcywgX1RocmVhZF9pbnN0YW5jZXMpO1xuICAgICAgX19wcml2YXRlQWRkKHRoaXMsIF9hYm9ydCk7XG4gICAgICBfX3ByaXZhdGVBZGQodGhpcywgX2lkc1RvUmVzb2x2ZXIsIC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSkoKSk7XG4gICAgICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2Fib3J0LCBzaWduYWwgPyBuZXcgTmVzdGVkQWJvcnRDb250cm9sbGVyKHNpZ25hbCkgOiBuZXcgQWJvcnRDb250cm9sbGVyKCkpO1xuICAgICAgdGhpcy5leHBvcnRzID0gZXhwb3J0cyA/PyB7fTtcbiAgICAgIHRoaXMuaW1wb3J0cyA9IGNyZWF0ZVRocmVhZEltcG9ydHMoX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UaHJlYWRfaW5zdGFuY2VzLCBoYW5kbGVyRm9yQ2FsbF9mbikuYmluZCh0aGlzKSwgaW1wb3J0cyk7XG4gICAgICB0aGlzLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICAgIHRoaXMuc2VyaWFsaXphdGlvbiA9IHNlcmlhbGl6YXRpb247XG4gICAgICB0aGlzLmZ1bmN0aW9ucy5zdGFydD8uKHRoaXMpO1xuICAgICAgdGhpcy5zZXJpYWxpemF0aW9uLnN0YXJ0Py4odGhpcyk7XG4gICAgICB0aGlzLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGlkMiBvZiBfX3ByaXZhdGVHZXQodGhpcywgX2lkc1RvUmVzb2x2ZXIpLmtleXMoKSkge1xuICAgICAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVGhyZWFkX2luc3RhbmNlcywgcmVzb2x2ZUNhbGxfZm4pLmNhbGwodGhpcywgaWQyLCB2b2lkIDAsIG5ldyBUaHJlYWRDbG9zZWRFcnJvcigpKTtcbiAgICAgICAgfVxuICAgICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2lkc1RvUmVzb2x2ZXIpLmNsZWFyKCk7XG4gICAgICB9LCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgbWVzc2FnZXMubGlzdGVuKGFzeW5jIChyYXdEYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzVGhyZWFkTWVzc2FnZURhdGEgPSBBcnJheS5pc0FycmF5KHJhd0RhdGEpICYmIHR5cGVvZiByYXdEYXRhWzBdID09PSBcIm51bWJlclwiO1xuICAgICAgICBpZiAoIWlzVGhyZWFkTWVzc2FnZURhdGEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHJhd0RhdGE7XG4gICAgICAgIHN3aXRjaCAoZGF0YVswXSkge1xuICAgICAgICAgIGNhc2UgTUVTU0FHRV9DQUxMOiB7XG4gICAgICAgICAgICBjb25zdCBbLCBpZDIsIHByb3BlcnR5LCBhcmdzXSA9IGRhdGE7XG4gICAgICAgICAgICBjb25zdCBmdW5jID0gdGhpcy5leHBvcnRzW3Byb3BlcnR5XSA/PyAoKCkgPT4ge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxgTm8gJ1xcJHtwcm9wZXJ0eX0nIG1ldGhvZCBpcyBleHBvcnRlZCBmcm9tIHRoaXMgdGhyZWFkXFxgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UaHJlYWRfaW5zdGFuY2VzLCBjYWxsTG9jYWxfZm4pLmNhbGwodGhpcywgZnVuYywgYXJncywgKHZhbHVlLCBlcnJvciwgdHJhbnNmZXJhYmxlKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMubWVzc2FnZXMuc2VuZChbTUVTU0FHRV9DQUxMX1JFU1VMVCwgaWQyLCB2YWx1ZSwgZXJyb3JdLCB0cmFuc2ZlcmFibGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBNRVNTQUdFX0ZVTkNUSU9OX0NBTEw6IHtcbiAgICAgICAgICAgIGNvbnN0IFssIGNhbGxJRCwgZnVuY0lELCBhcmdzXSA9IGRhdGE7XG4gICAgICAgICAgICBjb25zdCBmdW5jID0gdGhpcy5mdW5jdGlvbnMuZ2V0KGZ1bmNJRCwgdGhpcykgPz8gbWlzc2luZ1RocmVhZEZ1bmN0aW9uO1xuICAgICAgICAgICAgYXdhaXQgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UaHJlYWRfaW5zdGFuY2VzLCBjYWxsTG9jYWxfZm4pLmNhbGwodGhpcywgZnVuYywgYXJncywgKHZhbHVlLCBlcnJvciwgdHJhbnNmZXJhYmxlKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMubWVzc2FnZXMuc2VuZChbTUVTU0FHRV9GVU5DVElPTl9SRVNVTFQsIGNhbGxJRCwgdmFsdWUsIGVycm9yXSwgdHJhbnNmZXJhYmxlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgTUVTU0FHRV9DQUxMX1JFU1VMVDpcbiAgICAgICAgICBjYXNlIE1FU1NBR0VfRlVOQ1RJT05fUkVTVUxUOiB7XG4gICAgICAgICAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX1RocmVhZF9pbnN0YW5jZXMsIHJlc29sdmVDYWxsX2ZuKS5jYWxsKHRoaXMsIC4uLmRhdGEuc2xpY2UoMSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgTUVTU0FHRV9GVU5DVElPTl9SRUxFQVNFOiB7XG4gICAgICAgICAgICBjb25zdCBpZDIgPSBkYXRhWzFdO1xuICAgICAgICAgICAgdGhpcy5mdW5jdGlvbnMucmVsZWFzZShpZDIsIHRoaXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbDogdGhpcy5zaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgdGhhdCBleHBvc2VzIHRoZSBtZXRob2RzIHRoYXQgY2FuIGJlIGNhbGxlZCBvbiB0aGUgcGFpcmVkIHRocmVhZC5cbiAgICAgKiBUaGlzIG9iamVjdCB3aWxsIGF1dG9tYXRpY2FsbHkgZW5jb2RlIGFuZCBkZWNvZGUgYXJndW1lbnRzIGFuZCByZXR1cm4gdmFsdWVzXG4gICAgICogYXMgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCB0aGF0IGV4cG9zZXMgdGhlIG1ldGhvZHMgdGhhdCBjYW4gYmUgY2FsbGVkIG9uIHRoaXMgdGhyZWFkIGJ5IHRoZVxuICAgICAqIHBhaXJlZCB0aHJlYWQuIFRvIHNldCB0aGVzZSBtZXRob2RzLCBwYXNzIHRoZSBcXGBleHBvcnRzXFxgIG9wdGlvbiB3aGVuIGNyZWF0aW5nXG4gICAgICogYSBuZXcgXFxgVGhyZWFkXFxgLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCB0aGF0IHByb3ZpZGVzIHRoZSBtZXNzYWdlLXBhc3NpbmcgaW50ZXJmYWNlIHRoYXQgYWxsb3dzIGNvbW11bmljYXRpb25cbiAgICAgKiB0byBmbG93IGJldHdlZW4gZW52aXJvbm1lbnRzLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCB0aGF0IG1hbmFnZXMgaG93IGZ1bmN0aW9ucyBhcmUgcHJveGllZCBiZXR3ZWVuIHRocmVhZHMuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHRoYXQgbWFuYWdlcyBob3cgdmFsdWVzIGFyZSBzZXJpYWxpemVkIGFuZCBkZXNlcmlhbGl6ZWQgYmV0d2VlbiB0aHJlYWRzLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEFuIFxcYEFib3J0U2lnbmFsXFxgIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNvbW11bmljYXRpb24gY2hhbm5lbCBpcyBzdGlsbCBvcGVuLlxuICAgICAqL1xuICAgIGdldCBzaWduYWwoKSB7XG4gICAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9hYm9ydCkuc2lnbmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjb21tdW5pY2F0aW9uIGNoYW5uZWwgaXMgc3RpbGwgb3Blbi5cbiAgICAgKi9cbiAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfYWJvcnQpLnNpZ25hbC5hYm9ydGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGNvbW11bmljYXRpb24gY2hhbm5lbCBiZXR3ZWVuIHRoZSB0d28gdGhyZWFkcy4gVGhpcyB3aWxsIHByZXZlbnRcbiAgICAgKiBhbnkgZnVydGhlciBjb21tdW5pY2F0aW9uIGJldHdlZW4gdGhlIHRocmVhZHMsIGFuZCB3aWxsIGNsZWFuIHVwIGFueSBtZW1vcnlcbiAgICAgKiBhc3NvY2lhdGVkIHdpdGggaW4tcHJvZ3Jlc3MgY29tbXVuaWNhdGlvbi4gSXQgd2lsbCBhbHNvIHJlamVjdCBhbnkgaW5mbGlnaHRcbiAgICAgKiBmdW5jdGlvbiBjYWxscyBiZXR3ZWVuIHRocmVhZHMgd2l0aCBhIFxcYFRocmVhZENsb3NlZEVycm9yXFxgLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9hYm9ydCkuYWJvcnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgdGhhdCB0aGUgdGhyZWFkIHByb3ZpZGUgdGhlIGNvbnRleHQgbmVlZGVkIHRvIG1ha2UgYSBmdW5jdGlvblxuICAgICAqIGNhbGwgYmV0d2VlbiB0aHJlYWRzLiBZb3UgcHJvdmlkZSB0aGlzIG1ldGhvZCBhIGZ1bmN0aW9uIHRvIGNhbGwgYW5kIHRoZVxuICAgICAqIHVuc2VyaWFsaXplZCBhcmd1bWVudHMgeW91IHdpc2ggdG8gY2FsbCBpdCB3aXRoLCBhbmQgdGhlIHRocmVhZCB3aWxsIGNhbGxcbiAgICAgKiB0aGUgZnVuY3Rpb24geW91IHByb3ZpZGVkIHdpdGggYSBzZXJpYWxpemVkIGNhbGwgSUQsIHRoZSBzZXJpYWxpemVkIGFyZ3VtZW50cyxcbiAgICAgKiBhbmQgYW55IHRyYW5zZmVyYWJsZSBvYmplY3RzIHRoYXQgbmVlZCB0byBiZSBwYXNzZWQgYmV0d2VlbiB0aHJlYWRzLlxuICAgICAqL1xuICAgIGNhbGwoZnVuYywgYXJncykge1xuICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVGhyZWFkQ2xvc2VkRXJyb3IoKSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2ZlcmFibGUgPSBbXTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB0aGlzLnNlcmlhbGl6YXRpb24uc2VyaWFsaXplKGFyZ3MsIHRoaXMsIHRyYW5zZmVyYWJsZSk7XG4gICAgICBjb25zdCBpZDIgPSBuYW5vaWQoKTtcbiAgICAgIGNvbnN0IGRvbmUgPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX1RocmVhZF9pbnN0YW5jZXMsIHdhaXRGb3JSZXN1bHRfZm4pLmNhbGwodGhpcywgaWQyKTtcbiAgICAgIGZ1bmMoaWQyLCBzZXJpYWxpemVkLCB0cmFuc2ZlcmFibGUpO1xuICAgICAgcmV0dXJuIGRvbmU7XG4gICAgfVxuICB9O1xuICBfYWJvcnQgPSBuZXcgV2Vha01hcCgpO1xuICBfaWRzVG9SZXNvbHZlciA9IG5ldyBXZWFrTWFwKCk7XG4gIF9UaHJlYWRfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKTtcbiAgY2FsbExvY2FsX2ZuID0gYXN5bmMgZnVuY3Rpb24oZnVuYywgYXJncywgd2l0aFJlc3VsdCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmZ1bmN0aW9ucy5jYWxsID8gYXdhaXQgdGhpcy5mdW5jdGlvbnMuY2FsbChmdW5jLCBhcmdzLCB0aGlzKSA6IGF3YWl0IGZ1bmMoLi4udGhpcy5zZXJpYWxpemF0aW9uLmRlc2VyaWFsaXplKGFyZ3MsIHRoaXMpKTtcbiAgICAgIGNvbnN0IHRyYW5zZmVyYWJsZSA9IFtdO1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHRoaXMuc2VyaWFsaXphdGlvbi5zZXJpYWxpemUocmVzdWx0LCB0aGlzLCB0cmFuc2ZlcmFibGUpO1xuICAgICAgd2l0aFJlc3VsdChzZXJpYWxpemVkLCB2b2lkIDAsIHRyYW5zZmVyYWJsZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHdpdGhSZXN1bHQodm9pZCAwLCB0aGlzLnNlcmlhbGl6YXRpb24uc2VyaWFsaXplKGVycm9yLCB0aGlzKSk7XG4gICAgfVxuICB9O1xuICBoYW5kbGVyRm9yQ2FsbF9mbiA9IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBwcm9wZXJ0eSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXGBDYW7igJl0IGNhbGwgYSBzeW1ib2wgbWV0aG9kIG9uIGEgdGhyZWFkOiBcXCR7cHJvcGVydHkudG9TdHJpbmcoKX1cXGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoKGlkMiwgc2VyaWFsaXplZEFyZ3MsIHRyYW5zZmVyYWJsZSkgPT4ge1xuICAgICAgICAgIHRoaXMubWVzc2FnZXMuc2VuZChbTUVTU0FHRV9DQUxMLCBpZDIsIHByb3BlcnR5LCBzZXJpYWxpemVkQXJnc10sIHRyYW5zZmVyYWJsZSk7XG4gICAgICAgIH0sIGFyZ3MpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICByZXNvbHZlQ2FsbF9mbiA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjYWxsSUQgPSBhcmdzWzBdO1xuICAgIGNvbnN0IHJlc29sdmVyID0gX19wcml2YXRlR2V0KHRoaXMsIF9pZHNUb1Jlc29sdmVyKS5nZXQoY2FsbElEKTtcbiAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgIHJlc29sdmVyKC4uLmFyZ3MpO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9pZHNUb1Jlc29sdmVyKS5kZWxldGUoY2FsbElEKTtcbiAgICB9XG4gIH07XG4gIHdhaXRGb3JSZXN1bHRfZm4gPSBmdW5jdGlvbihpZDIpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9pZHNUb1Jlc29sdmVyKS5zZXQoaWQyLCAoXywgdmFsdWUsIGVycm9yKSA9PiB7XG4gICAgICAgIGlmIChlcnJvciA9PSBudWxsKSB7XG4gICAgICAgICAgcmVzb2x2ZSh0aGlzLnNlcmlhbGl6YXRpb24uZGVzZXJpYWxpemUodmFsdWUsIHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QodGhpcy5zZXJpYWxpemF0aW9uLmRlc2VyaWFsaXplKGVycm9yLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBTeW1ib2wuYXN5bmNJdGVyYXRvciwge1xuICAgICAgYXN5bmMgKnZhbHVlKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBTeW1ib2wuYXN5bmNJdGVyYXRvciwge1xuICAgICAgICAgIHZhbHVlOiAoKSA9PiByZXN1bHRcbiAgICAgICAgfSk7XG4gICAgICAgIHlpZWxkKiByZXN1bHQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG4gIGZ1bmN0aW9uIGNyZWF0ZVRocmVhZEltcG9ydHMoaGFuZGxlckZvckltcG9ydCwgaW1wb3J0ZWQpIHtcbiAgICBsZXQgY2FsbDtcbiAgICBpZiAoaW1wb3J0ZWQgPT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBQcm94eSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXGBZb3UgbXVzdCBwYXNzIGFuIGFycmF5IG9mIGNhbGxhYmxlIG1ldGhvZHMgaW4gZW52aXJvbm1lbnRzIHdpdGhvdXQgUHJveGllcy5cXGApO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY2FsbCA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgICBnZXQoX3RhcmdldCwgcHJvcGVydHkpIHtcbiAgICAgICAgICBpZiAoY2FjaGUuaGFzKHByb3BlcnR5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmdldChwcm9wZXJ0eSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyRm9ySW1wb3J0KHByb3BlcnR5KTtcbiAgICAgICAgICBjYWNoZS5zZXQocHJvcGVydHksIGhhbmRsZXIpO1xuICAgICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBtZXRob2Qgb2YgaW1wb3J0ZWQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNhbGwsIG1ldGhvZCwge1xuICAgICAgICAgIHZhbHVlOiBoYW5kbGVyRm9ySW1wb3J0KG1ldGhvZCksXG4gICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuICBmdW5jdGlvbiBtaXNzaW5nVGhyZWFkRnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxcYFlvdSBhdHRlbXB0ZWQgdG8gY2FsbCBhIGZ1bmN0aW9uIHRoYXQgaXMgbm90IHN0b3JlZC4gSXQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbGVhc2VkLlxcYCk7XG4gIH1cblxuICAvLyAuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHF1aWx0ZWQrdGhyZWFkc0AzLjEuM19AcHJlYWN0K3NpZ25hbHMtY29yZUAxLjEwLjAvbm9kZV9tb2R1bGVzL0BxdWlsdGVkL3RocmVhZHMvYnVpbGQvZXNtL3RocmVhZHMvd2luZG93L3NoYXJlZC5tanNcbiAgdmFyIENIRUNLX01FU1NBR0UgPSBcInF1aWx0LnRocmVhZHMucGluZ1wiO1xuICB2YXIgUkVTUE9OU0VfTUVTU0FHRSA9IFwicXVpbHQudGhyZWFkcy5wb25nXCI7XG5cbiAgLy8gLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BxdWlsdGVkK3RocmVhZHNAMy4xLjNfQHByZWFjdCtzaWduYWxzLWNvcmVAMS4xMC4wL25vZGVfbW9kdWxlcy9AcXVpbHRlZC90aHJlYWRzL2J1aWxkL2VzbS90aHJlYWRzL3dpbmRvdy9UaHJlYWROZXN0ZWRXaW5kb3cubWpzXG4gIGZ1bmN0aW9uIG5lc3RlZFdpbmRvd1RvVGhyZWFkVGFyZ2V0KHBhcmVudCwge1xuICAgIHRhcmdldE9yaWdpbiA9IFwiKlwiXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlYWR5ID0gKCkgPT4ge1xuICAgICAgY29uc3QgcmVzcG9uZCA9ICgpID0+IHBhcmVudC5wb3N0TWVzc2FnZShSRVNQT05TRV9NRVNTQUdFLCB0YXJnZXRPcmlnaW4pO1xuICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoe1xuICAgICAgICBkYXRhLFxuICAgICAgICBzb3VyY2VcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gcGFyZW50KSByZXR1cm47XG4gICAgICAgIGlmIChkYXRhID09PSBDSEVDS19NRVNTQUdFKSByZXNwb25kKCk7XG4gICAgICB9KTtcbiAgICAgIHJlc3BvbmQoKTtcbiAgICB9O1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgIHJlYWR5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgIHJlYWR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2VuZChtZXNzYWdlLCB0cmFuc2Zlcikge1xuICAgICAgICByZXR1cm4gcGFyZW50LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRhcmdldE9yaWdpbiwgdHJhbnNmZXIpO1xuICAgICAgfSxcbiAgICAgIGxpc3RlbihsaXN0ZW4sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KSB7XG4gICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50LmRhdGEgPT09IENIRUNLX01FU1NBR0UpIHJldHVybjtcbiAgICAgICAgICBsaXN0ZW4oZXZlbnQuZGF0YSk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIC4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AcXVpbHRlZCt0aHJlYWRzQDMuMS4zX0BwcmVhY3Qrc2lnbmFscy1jb3JlQDEuMTAuMC9ub2RlX21vZHVsZXMvQHF1aWx0ZWQvdGhyZWFkcy9idWlsZC9lc20vdGhyZWFkcy9UaHJlYWROZXN0ZWRJZnJhbWUubWpzXG4gIHZhciBUaHJlYWROZXN0ZWRJZnJhbWUgPSBjbGFzcyBleHRlbmRzIFRocmVhZCB7XG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgcGFyZW50ID0gZ2xvYmFsVGhpcy5wYXJlbnQsXG4gICAgICB0YXJnZXRPcmlnaW4gPSBcIipcIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9ID0ge30pIHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiB8fCBwYXJlbnQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgYXJlIG5vdCBpbnNpZGUgYW4gaWZyYW1lLCBiZWNhdXNlIHRoZXJlIGlzIG5vIHBhcmVudCB3aW5kb3cuXCIpO1xuICAgICAgfVxuICAgICAgc3VwZXIobmVzdGVkV2luZG93VG9UaHJlYWRUYXJnZXQocGFyZW50LCB7XG4gICAgICAgIHRhcmdldE9yaWdpblxuICAgICAgfSksIG9wdGlvbnMpO1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICB9O1xuXG4gIC8vIHNjcmlwdHMvaWZyYW1lLWVudHJ5LmpzXG4gIG5ldyBUaHJlYWROZXN0ZWRJZnJhbWUoe1xuICAgIGV4cG9ydHM6IHtcbiAgICAgIGFzeW5jIHJlbmRlcihvcHRpb25zLCByZWNlaXZlciwgaG9zdEFwaSkge1xuICAgICAgICBpZiAob3B0aW9ucy5yZW1vdGVFbGVtZW50cykge1xuICAgICAgICAgIG9wdGlvbnMucmVtb3RlRWxlbWVudHMuZm9yRWFjaCgoZGVmKSA9PiB7XG4gICAgICAgICAgICBpZiAoY3VzdG9tRWxlbWVudHMuZ2V0KGRlZi50YWdOYW1lKSkgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgUmVtb3RlRWxlbWVudCB7XG4gICAgICAgICAgICAgIHN0YXRpYyBnZXQgcmVtb3RlQXR0cmlidXRlcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmLnJlbW90ZUF0dHJpYnV0ZXMgfHwgW107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdGljIGdldCByZW1vdGVFdmVudHMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZi5yZW1vdGVFdmVudHMgfHwgW107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVtb3RlRWxlbWVudCwgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IFxcYFJlbW90ZVxcJHtkZWYudGFnTmFtZS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIC8oXnd8LXcpL2csXG4gICAgICAgICAgICAgICAgKGMpID0+IGMucmVwbGFjZShcIi1cIiwgXCJcIikudG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgICApfVxcYFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoZGVmLnRhZ05hbWUsIHJlbW90ZUVsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvb3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3Jvb3RcIik7XG4gICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlbW90ZU11dGF0aW9uT2JzZXJ2ZXIocmVjZWl2ZXIpO1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHJvb3QpO1xuICAgICAgICBjb25zdCB7IGNvZGUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChjb2RlICYmIHJvb3QpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc2NyaXB0RnVuY3Rpb24gPSBuZXcgRnVuY3Rpb24oXCJyb290XCIsIFwiY29uc29sZVwiLCBjb2RlKTtcbiAgICAgICAgICAgIHNjcmlwdEZ1bmN0aW9uKHJvb3QsIGNvbnNvbGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBleGVjdXRpbmcgcmVtb3RlIHNjcmlwdDpcIiwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cbiAgPFxcL3NjcmlwdD5cbjwvYm9keT5cbjwvaHRtbD5gLCB2ZSA9IDEsIHllID0gMiwgTGUgPSAzLCBUZSA9IDQsIFVlID0gNSwgZ2UgPSBTeW1ib2wuZm9yKFwicXVpbHQudGhyZWFkcy5zZXJpYWxpemVcIiksIHl0ID0gU3ltYm9sLmZvcihcInF1aWx0LnRocmVhZHMudHJhbnNmZXJhYmxlXCIpO1xuY2xhc3MgVHQgZXh0ZW5kcyBBYm9ydENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvciguLi5lKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB0ID0gZS5maW5kKChuKSA9PiBuLmFib3J0ZWQpO1xuICAgIGlmICh0KVxuICAgICAgdGhpcy5hYm9ydCh0LnJlYXNvbik7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBuID0gKG8pID0+IHRoaXMuYWJvcnQoby50YXJnZXQucmVhc29uKSwgcyA9IHtcbiAgICAgICAgc2lnbmFsOiB0aGlzLnNpZ25hbFxuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3QgbyBvZiBlKVxuICAgICAgICBvLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBuLCBzKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFJlIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIllvdSBhdHRlbXB0ZWQgdG8gY2FsbCBhIGZ1bmN0aW9uIG9uIGEgY2xvc2VkIHRocmVhZC5cIik7XG4gIH1cbn1cbmxldCBndCA9IFwidXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdFwiO1xuZnVuY3Rpb24gemUociA9IDIxKSB7XG4gIGxldCBlID0gXCJcIiwgdCA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkocikpO1xuICBmb3IgKGxldCBuID0gMDsgbiA8IHI7IG4rKykgZSArPSBndFs2MyAmIHRbbl1dO1xuICByZXR1cm4gZTtcbn1cbnZhciBZLCB4LCBHLCBLLCBlZSwgeGU7XG5jbGFzcyBSdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIFModGhpcywgZWUpO1xuICAgIFModGhpcywgWSwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgUyh0aGlzLCB4LCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBTKHRoaXMsIEcsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIFModGhpcywgSywgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICB9XG4gIGdldChlKSB7XG4gICAgcmV0dXJuIGIodGhpcywgeCkuZ2V0KGUpO1xuICB9XG4gIHJlbGVhc2UoZSkge1xuICAgIGNvbnN0IHQgPSBiKHRoaXMsIHgpLmdldChlKTtcbiAgICByZXR1cm4gdCAmJiAoYih0aGlzLCB4KS5kZWxldGUoZSksIGIodGhpcywgWSkuZGVsZXRlKHQpKSwgISF0O1xuICB9XG4gIHNlcmlhbGl6ZShlKSB7XG4gICAgbGV0IHQgPSBiKHRoaXMsIFkpLmdldChlKTtcbiAgICByZXR1cm4gdCA9PSBudWxsICYmICh0ID0gemUoKSwgYih0aGlzLCBZKS5zZXQoZSwgdCksIGIodGhpcywgeCkuc2V0KHQsIGUpKSwgdDtcbiAgfVxuICBkZXNlcmlhbGl6ZShlLCB0KSB7XG4gICAgdmFyIHMsIG87XG4gICAgbGV0IG4gPSAocyA9IGIodGhpcywgRykuZ2V0KGUpKSA9PSBudWxsID8gdm9pZCAwIDogcy5kZXJlZigpO1xuICAgIHJldHVybiBuIHx8IChuID0gKC4uLmEpID0+IHtcbiAgICAgIGlmICghYih0aGlzLCBHKS5oYXMoZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBhdHRlbXB0ZWQgdG8gY2FsbCBhIGZ1bmN0aW9uIHRoYXQgd2FzIGFscmVhZHkgcmV2b2tlZC5cIik7XG4gICAgICByZXR1cm4gdC5jYWxsKCh1LCBsLCBmKSA9PiB7XG4gICAgICAgIHQubWVzc2FnZXMuc2VuZChbTGUsIHUsIGUsIGxdLCBmKTtcbiAgICAgIH0sIGEpO1xuICAgIH0sIChvID0geSh0aGlzLCBlZSwgeGUpLmNhbGwodGhpcywgdCkpID09IG51bGwgfHwgby5yZWdpc3RlcihuLCBlKSwgYih0aGlzLCBHKS5zZXQoZSwgbmV3IFdlYWtSZWYobikpLCBuKTtcbiAgfVxufVxuWSA9IG5ldyBXZWFrTWFwKCksIHggPSBuZXcgV2Vha01hcCgpLCBHID0gbmV3IFdlYWtNYXAoKSwgSyA9IG5ldyBXZWFrTWFwKCksIGVlID0gbmV3IFdlYWtTZXQoKSwgeGUgPSBmdW5jdGlvbihlKSB7XG4gIGxldCB0ID0gYih0aGlzLCBLKS5nZXQoZSk7XG4gIGlmICghKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA+IFwidVwiKSlcbiAgICByZXR1cm4gdCB8fCAodCA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgobikgPT4ge1xuICAgICAgZS5tZXNzYWdlcy5zZW5kKFtVZSwgbl0pO1xuICAgIH0pLCBiKHRoaXMsIEspLnNldChlLCB0KSksIHQ7XG59O1xuZnVuY3Rpb24gd3Qocikge1xuICByZXR1cm4gciAhPSBudWxsICYmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByIHx8IFN5bWJvbC5pdGVyYXRvciBpbiByKSAmJiB0eXBlb2Ygci5uZXh0ID09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIHdlKHIpIHtcbiAgaWYgKHIgPT0gbnVsbCB8fCB0eXBlb2YgciAhPSBcIm9iamVjdFwiKSByZXR1cm4gITE7XG4gIGNvbnN0IGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yocik7XG4gIHJldHVybiBlID09IG51bGwgfHwgZSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cbmNvbnN0IGllID0gXCJfQGZcIiwgU2UgPSBcIl9AaVwiO1xudmFyIFYsIFcsIHcsIFEsIE87XG5jbGFzcyBTdCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBTKHRoaXMsIHcpO1xuICAgIFModGhpcywgVik7XG4gICAgUyh0aGlzLCBXKTtcbiAgICBaKHRoaXMsIFYsIGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuc2VyaWFsaXplKSwgWih0aGlzLCBXLCBlID09IG51bGwgPyB2b2lkIDAgOiBlLmRlc2VyaWFsaXplKTtcbiAgfVxuICAvKipcbiAgICogU2VyaWFsaXplcyBhIHZhbHVlIGludG8gYSBzdHJ1Y3R1cmVkIGNsb25pbmctY29tcGF0aWJsZSBmb3JtYXQgdGhhdCBjYW4gYmUgdHJhbnNmZXJyZWQgYmV0d2VlbiB0aHJlYWRzLlxuICAgKi9cbiAgc2VyaWFsaXplKGUsIHQsIG4pIHtcbiAgICByZXR1cm4geSh0aGlzLCB3LCBRKS5jYWxsKHRoaXMsIGUsIHQsIG4pO1xuICB9XG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZXMgYSBzdHJ1Y3R1cmVkIGNsb25pbmctY29tcGF0aWJsZSB2YWx1ZSBmcm9tIGFub3RoZXIgdGhyZWFkLlxuICAgKi9cbiAgZGVzZXJpYWxpemUoZSwgdCkge1xuICAgIHJldHVybiB5KHRoaXMsIHcsIE8pLmNhbGwodGhpcywgZSwgdCk7XG4gIH1cbn1cblYgPSBuZXcgV2Vha01hcCgpLCBXID0gbmV3IFdlYWtNYXAoKSwgdyA9IG5ldyBXZWFrU2V0KCksIFEgPSBmdW5jdGlvbihlLCB0LCBuLCBzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgbyA9ICExKSB7XG4gIGlmIChlID09IG51bGwpIHJldHVybiBlO1xuICBpZiAocy5oYXMoZSkpIHJldHVybiBzLmdldChlKTtcbiAgaWYgKHMuc2V0KGUsIHZvaWQgMCksIHR5cGVvZiBlID09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoYih0aGlzLCBWKSAmJiAhbykge1xuICAgICAgY29uc3QgbCA9IGIodGhpcywgVikuY2FsbCh0aGlzLCBlLCAoZikgPT4geSh0aGlzLCB3LCBRKS5jYWxsKHRoaXMsIGYsIHQsIG4sIHMsICEwKSwgdCwgbik7XG4gICAgICBpZiAobCAhPT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gcy5zZXQoZSwgbCksIGw7XG4gICAgfVxuICAgIGlmIChlW3l0XSlcbiAgICAgIHJldHVybiBuID09IG51bGwgfHwgbi5wdXNoKGUpLCBzLnNldChlLCBlKSwgZTtcbiAgICBjb25zdCBhID0gKGwpID0+IHkodGhpcywgdywgUSkuY2FsbCh0aGlzLCBsLCB0LCBuLCBzKTtcbiAgICBpZiAodHlwZW9mIGVbZ2VdID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc3QgbCA9IGVbZ2VdKHtcbiAgICAgICAgc2VyaWFsaXplOiBhXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzLnNldChlLCBsKSwgbDtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGNvbnN0IGwgPSBlLm1hcCgoZikgPT4gYShmKSk7XG4gICAgICByZXR1cm4gcy5zZXQoZSwgbCksIGw7XG4gICAgfVxuICAgIGlmIChlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICBjb25zdCBsID0gWy4uLmUuZW50cmllcygpXS5tYXAoKFtpLCBtXSkgPT4gW2EoaSksIGEobSldKSwgZiA9IG5ldyBNYXAobCk7XG4gICAgICByZXR1cm4gcy5zZXQoZSwgZiksIGY7XG4gICAgfVxuICAgIGlmIChlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICBjb25zdCBsID0gWy4uLmVdLm1hcCgoaSkgPT4gYShpKSksIGYgPSBuZXcgU2V0KGwpO1xuICAgICAgcmV0dXJuIHMuc2V0KGUsIGYpLCBmO1xuICAgIH1cbiAgICBjb25zdCB1ID0gd3QoZSk7XG4gICAgaWYgKHdlKGUpIHx8IHUpIHtcbiAgICAgIGNvbnN0IGwgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgZiBvZiBPYmplY3Qua2V5cyhlKSlcbiAgICAgICAgbFtmXSA9IGEoZVtmXSk7XG4gICAgICByZXR1cm4gdSAmJiAobC5uZXh0ID8/IChsLm5leHQgPSBhKGUubmV4dC5iaW5kKGUpKSksIGwucmV0dXJuID8/IChsLnJldHVybiA9IGEoZS5yZXR1cm4uYmluZChlKSkpLCBsLnRocm93ID8/IChsLnRocm93ID0gYShlLnRocm93LmJpbmQoZSkpKSwgbFtTZV0gPSAhMCksIHMuc2V0KGUsIGwpLCBsO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3QgYSA9IHQuZnVuY3Rpb25zLnNlcmlhbGl6ZShlLCB0LCBuKSwgdSA9IHtcbiAgICAgIFtpZV06IGFcbiAgICB9O1xuICAgIHJldHVybiBzLnNldChlLCB1KSwgdTtcbiAgfVxuICByZXR1cm4gcy5zZXQoZSwgZSksIGU7XG59LCBPID0gZnVuY3Rpb24oZSwgdCwgbiA9ICExKSB7XG4gIGlmIChlID09IG51bGwpIHJldHVybiBlO1xuICBpZiAodHlwZW9mIGUgPT0gXCJvYmplY3RcIikge1xuICAgIGlmIChiKHRoaXMsIFcpICYmICFuKSB7XG4gICAgICBjb25zdCBvID0gYih0aGlzLCBXKS5jYWxsKHRoaXMsIGUsIChhKSA9PiB5KHRoaXMsIHcsIE8pLmNhbGwodGhpcywgYSwgdCwgITApLCB0KTtcbiAgICAgIGlmIChvICE9PSB2b2lkIDApXG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgICBpZiAoZSA9PSBudWxsKVxuICAgICAgcmV0dXJuIGU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpXG4gICAgICByZXR1cm4gZS5tYXAoKG8pID0+IHkodGhpcywgdywgTykuY2FsbCh0aGlzLCBvLCB0KSk7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBNYXApXG4gICAgICByZXR1cm4gbmV3IE1hcChbLi4uZV0ubWFwKChbbywgYV0pID0+IFt5KHRoaXMsIHcsIE8pLmNhbGwodGhpcywgbywgdCksIHkodGhpcywgdywgTykuY2FsbCh0aGlzLCBhLCB0KV0pKTtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFNldClcbiAgICAgIHJldHVybiBuZXcgU2V0KFsuLi5lXS5tYXAoKG8pID0+IHkodGhpcywgdywgTykuY2FsbCh0aGlzLCBvLCB0KSkpO1xuICAgIGlmIChpZSBpbiBlKVxuICAgICAgcmV0dXJuIHQuZnVuY3Rpb25zLmRlc2VyaWFsaXplKGVbaWVdLCB0KTtcbiAgICBpZiAoIXdlKGUpKVxuICAgICAgcmV0dXJuIGU7XG4gICAgY29uc3QgcyA9IHt9O1xuICAgIGZvciAoY29uc3QgbyBvZiBPYmplY3Qua2V5cyhlKSlcbiAgICAgIG8gPT09IFNlID8gc1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSAoKSA9PiBzIDogc1tvXSA9IHkodGhpcywgdywgTykuY2FsbCh0aGlzLCBlW29dLCB0KTtcbiAgICByZXR1cm4gcztcbiAgfVxuICByZXR1cm4gZTtcbn07XG52YXIgaywgRCwgTSwgYWUsIGtlLCBsZSwgamU7XG5jbGFzcyBNdCB7XG4gIGNvbnN0cnVjdG9yKGUsIHtcbiAgICBpbXBvcnRzOiB0LFxuICAgIGV4cG9ydHM6IG4sXG4gICAgZnVuY3Rpb25zOiBzID0gbmV3IFJ0KCksXG4gICAgc2VyaWFsaXphdGlvbjogbyA9IG5ldyBTdCgpLFxuICAgIHNpZ25hbDogYVxuICB9ID0ge30pIHtcbiAgICBTKHRoaXMsIE0pO1xuICAgIFModGhpcywgayk7XG4gICAgUyh0aGlzLCBELCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICB2YXIgdSwgbCwgZiwgaTtcbiAgICB0aGlzLm1lc3NhZ2VzID0gZSwgWih0aGlzLCBrLCBhID8gbmV3IFR0KGEpIDogbmV3IEFib3J0Q29udHJvbGxlcigpKSwgdGhpcy5leHBvcnRzID0gbiA/PyB7fSwgdGhpcy5pbXBvcnRzID0gQXQoeSh0aGlzLCBNLCBrZSkuYmluZCh0aGlzKSwgdCksIHRoaXMuZnVuY3Rpb25zID0gcywgdGhpcy5zZXJpYWxpemF0aW9uID0gbywgKGwgPSAodSA9IHRoaXMuZnVuY3Rpb25zKS5zdGFydCkgPT0gbnVsbCB8fCBsLmNhbGwodSwgdGhpcyksIChpID0gKGYgPSB0aGlzLnNlcmlhbGl6YXRpb24pLnN0YXJ0KSA9PSBudWxsIHx8IGkuY2FsbChmLCB0aGlzKSwgdGhpcy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBiKHRoaXMsIEQpLmtleXMoKSlcbiAgICAgICAgeSh0aGlzLCBNLCBsZSkuY2FsbCh0aGlzLCBtLCB2b2lkIDAsIG5ldyBSZSgpKTtcbiAgICAgIGIodGhpcywgRCkuY2xlYXIoKTtcbiAgICB9LCB7XG4gICAgICBvbmNlOiAhMFxuICAgIH0pLCBlLmxpc3Rlbihhc3luYyAobSkgPT4ge1xuICAgICAgaWYgKCEoQXJyYXkuaXNBcnJheShtKSAmJiB0eXBlb2YgbVswXSA9PSBcIm51bWJlclwiKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgYyA9IG07XG4gICAgICBzd2l0Y2ggKGNbMF0pIHtcbiAgICAgICAgY2FzZSB2ZToge1xuICAgICAgICAgIGNvbnN0IFssIHAsIGgsIEVdID0gYywgXyA9IHRoaXMuZXhwb3J0c1toXSA/PyAoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyAnJHtofScgbWV0aG9kIGlzIGV4cG9ydGVkIGZyb20gdGhpcyB0aHJlYWRgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhd2FpdCB5KHRoaXMsIE0sIGFlKS5jYWxsKHRoaXMsIF8sIEUsIChSLCBBLCBUKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VzLnNlbmQoW3llLCBwLCBSLCBBXSwgVCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBMZToge1xuICAgICAgICAgIGNvbnN0IFssIHAsIGgsIEVdID0gYywgXyA9IHRoaXMuZnVuY3Rpb25zLmdldChoLCB0aGlzKSA/PyBOdDtcbiAgICAgICAgICBhd2FpdCB5KHRoaXMsIE0sIGFlKS5jYWxsKHRoaXMsIF8sIEUsIChSLCBBLCBUKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VzLnNlbmQoW1RlLCBwLCBSLCBBXSwgVCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSB5ZTpcbiAgICAgICAgY2FzZSBUZToge1xuICAgICAgICAgIHkodGhpcywgTSwgbGUpLmNhbGwodGhpcywgLi4uYy5zbGljZSgxKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBVZToge1xuICAgICAgICAgIGNvbnN0IHAgPSBjWzFdO1xuICAgICAgICAgIHRoaXMuZnVuY3Rpb25zLnJlbGVhc2UocCwgdGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBzaWduYWw6IHRoaXMuc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFuIG9iamVjdCB0aGF0IGV4cG9zZXMgdGhlIG1ldGhvZHMgdGhhdCBjYW4gYmUgY2FsbGVkIG9uIHRoZSBwYWlyZWQgdGhyZWFkLlxuICAgKiBUaGlzIG9iamVjdCB3aWxsIGF1dG9tYXRpY2FsbHkgZW5jb2RlIGFuZCBkZWNvZGUgYXJndW1lbnRzIGFuZCByZXR1cm4gdmFsdWVzXG4gICAqIGFzIG5lY2Vzc2FyeS5cbiAgICovXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgdGhhdCBleHBvc2VzIHRoZSBtZXRob2RzIHRoYXQgY2FuIGJlIGNhbGxlZCBvbiB0aGlzIHRocmVhZCBieSB0aGVcbiAgICogcGFpcmVkIHRocmVhZC4gVG8gc2V0IHRoZXNlIG1ldGhvZHMsIHBhc3MgdGhlIGBleHBvcnRzYCBvcHRpb24gd2hlbiBjcmVhdGluZ1xuICAgKiBhIG5ldyBgVGhyZWFkYC5cbiAgICovXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgdGhhdCBwcm92aWRlcyB0aGUgbWVzc2FnZS1wYXNzaW5nIGludGVyZmFjZSB0aGF0IGFsbG93cyBjb21tdW5pY2F0aW9uXG4gICAqIHRvIGZsb3cgYmV0d2VlbiBlbnZpcm9ubWVudHMuXG4gICAqL1xuICAvKipcbiAgICogQW4gb2JqZWN0IHRoYXQgbWFuYWdlcyBob3cgZnVuY3Rpb25zIGFyZSBwcm94aWVkIGJldHdlZW4gdGhyZWFkcy5cbiAgICovXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgdGhhdCBtYW5hZ2VzIGhvdyB2YWx1ZXMgYXJlIHNlcmlhbGl6ZWQgYW5kIGRlc2VyaWFsaXplZCBiZXR3ZWVuIHRocmVhZHMuXG4gICAqL1xuICAvKipcbiAgICogQW4gYEFib3J0U2lnbmFsYCB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBjb21tdW5pY2F0aW9uIGNoYW5uZWwgaXMgc3RpbGwgb3Blbi5cbiAgICovXG4gIGdldCBzaWduYWwoKSB7XG4gICAgcmV0dXJuIGIodGhpcywgaykuc2lnbmFsO1xuICB9XG4gIC8qKlxuICAgKiBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjb21tdW5pY2F0aW9uIGNoYW5uZWwgaXMgc3RpbGwgb3Blbi5cbiAgICovXG4gIGdldCBjbG9zZWQoKSB7XG4gICAgcmV0dXJuIGIodGhpcywgaykuc2lnbmFsLmFib3J0ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgY29tbXVuaWNhdGlvbiBjaGFubmVsIGJldHdlZW4gdGhlIHR3byB0aHJlYWRzLiBUaGlzIHdpbGwgcHJldmVudFxuICAgKiBhbnkgZnVydGhlciBjb21tdW5pY2F0aW9uIGJldHdlZW4gdGhlIHRocmVhZHMsIGFuZCB3aWxsIGNsZWFuIHVwIGFueSBtZW1vcnlcbiAgICogYXNzb2NpYXRlZCB3aXRoIGluLXByb2dyZXNzIGNvbW11bmljYXRpb24uIEl0IHdpbGwgYWxzbyByZWplY3QgYW55IGluZmxpZ2h0XG4gICAqIGZ1bmN0aW9uIGNhbGxzIGJldHdlZW4gdGhyZWFkcyB3aXRoIGEgYFRocmVhZENsb3NlZEVycm9yYC5cbiAgICovXG4gIGNsb3NlKCkge1xuICAgIGIodGhpcywgaykuYWJvcnQoKTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgdGhhdCB0aGUgdGhyZWFkIHByb3ZpZGUgdGhlIGNvbnRleHQgbmVlZGVkIHRvIG1ha2UgYSBmdW5jdGlvblxuICAgKiBjYWxsIGJldHdlZW4gdGhyZWFkcy4gWW91IHByb3ZpZGUgdGhpcyBtZXRob2QgYSBmdW5jdGlvbiB0byBjYWxsIGFuZCB0aGVcbiAgICogdW5zZXJpYWxpemVkIGFyZ3VtZW50cyB5b3Ugd2lzaCB0byBjYWxsIGl0IHdpdGgsIGFuZCB0aGUgdGhyZWFkIHdpbGwgY2FsbFxuICAgKiB0aGUgZnVuY3Rpb24geW91IHByb3ZpZGVkIHdpdGggYSBzZXJpYWxpemVkIGNhbGwgSUQsIHRoZSBzZXJpYWxpemVkIGFyZ3VtZW50cyxcbiAgICogYW5kIGFueSB0cmFuc2ZlcmFibGUgb2JqZWN0cyB0aGF0IG5lZWQgdG8gYmUgcGFzc2VkIGJldHdlZW4gdGhyZWFkcy5cbiAgICovXG4gIGNhbGwoZSwgdCkge1xuICAgIGlmICh0aGlzLmNsb3NlZClcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgUmUoKSk7XG4gICAgY29uc3QgbiA9IFtdLCBzID0gdGhpcy5zZXJpYWxpemF0aW9uLnNlcmlhbGl6ZSh0LCB0aGlzLCBuKSwgbyA9IHplKCksIGEgPSB5KHRoaXMsIE0sIGplKS5jYWxsKHRoaXMsIG8pO1xuICAgIHJldHVybiBlKG8sIHMsIG4pLCBhO1xuICB9XG59XG5rID0gbmV3IFdlYWtNYXAoKSwgRCA9IG5ldyBXZWFrTWFwKCksIE0gPSBuZXcgV2Vha1NldCgpLCBhZSA9IGFzeW5jIGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzID0gdGhpcy5mdW5jdGlvbnMuY2FsbCA/IGF3YWl0IHRoaXMuZnVuY3Rpb25zLmNhbGwoZSwgdCwgdGhpcykgOiBhd2FpdCBlKC4uLnRoaXMuc2VyaWFsaXphdGlvbi5kZXNlcmlhbGl6ZSh0LCB0aGlzKSksIG8gPSBbXSwgYSA9IHRoaXMuc2VyaWFsaXphdGlvbi5zZXJpYWxpemUocywgdGhpcywgbyk7XG4gICAgbihhLCB2b2lkIDAsIG8pO1xuICB9IGNhdGNoIChzKSB7XG4gICAgbih2b2lkIDAsIHRoaXMuc2VyaWFsaXphdGlvbi5zZXJpYWxpemUocywgdGhpcykpO1xuICB9XG59LCBrZSA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuICguLi50KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgZSAhPSBcInN0cmluZ1wiICYmIHR5cGVvZiBlICE9IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fu4oCZdCBjYWxsIGEgc3ltYm9sIG1ldGhvZCBvbiBhIHRocmVhZDogJHtlLnRvU3RyaW5nKCl9YCk7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsKChuLCBzLCBvKSA9PiB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMuc2VuZChbdmUsIG4sIGUsIHNdLCBvKTtcbiAgICAgIH0sIHQpO1xuICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuKTtcbiAgICB9XG4gIH07XG59LCBsZSA9IGZ1bmN0aW9uKC4uLmUpIHtcbiAgY29uc3QgdCA9IGVbMF0sIG4gPSBiKHRoaXMsIEQpLmdldCh0KTtcbiAgbiAmJiAobiguLi5lKSwgYih0aGlzLCBEKS5kZWxldGUodCkpO1xufSwgamUgPSBmdW5jdGlvbihlKSB7XG4gIGNvbnN0IHQgPSBuZXcgUHJvbWlzZSgobiwgcykgPT4ge1xuICAgIGIodGhpcywgRCkuc2V0KGUsIChvLCBhLCB1KSA9PiB7XG4gICAgICB1ID09IG51bGwgPyBuKHRoaXMuc2VyaWFsaXphdGlvbi5kZXNlcmlhbGl6ZShhLCB0aGlzKSkgOiBzKHRoaXMuc2VyaWFsaXphdGlvbi5kZXNlcmlhbGl6ZSh1LCB0aGlzKSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFN5bWJvbC5hc3luY0l0ZXJhdG9yLCB7XG4gICAgYXN5bmMgKnZhbHVlKCkge1xuICAgICAgY29uc3QgbiA9IGF3YWl0IHQ7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgU3ltYm9sLmFzeW5jSXRlcmF0b3IsIHtcbiAgICAgICAgdmFsdWU6ICgpID0+IG5cbiAgICAgIH0pLCB5aWVsZCogbjtcbiAgICB9XG4gIH0pLCB0O1xufTtcbmZ1bmN0aW9uIEF0KHIsIGUpIHtcbiAgbGV0IHQ7XG4gIGlmIChlID09IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIFByb3h5ICE9IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgYW4gYXJyYXkgb2YgY2FsbGFibGUgbWV0aG9kcyBpbiBlbnZpcm9ubWVudHMgd2l0aG91dCBQcm94aWVzLlwiKTtcbiAgICBjb25zdCBuID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0ID0gbmV3IFByb3h5KHt9LCB7XG4gICAgICBnZXQocywgbykge1xuICAgICAgICBpZiAobi5oYXMobykpXG4gICAgICAgICAgcmV0dXJuIG4uZ2V0KG8pO1xuICAgICAgICBjb25zdCBhID0gcihvKTtcbiAgICAgICAgcmV0dXJuIG4uc2V0KG8sIGEpLCBhO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgZSlcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBuLCB7XG4gICAgICAgIHZhbHVlOiByKG4pLFxuICAgICAgICB3cml0YWJsZTogITEsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgIGVudW1lcmFibGU6ICEwXG4gICAgICB9KTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIE50KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgYXR0ZW1wdGVkIHRvIGNhbGwgYSBmdW5jdGlvbiB0aGF0IGlzIG5vdCBzdG9yZWQuIEl0IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZWxlYXNlZC5cIik7XG59XG5jb25zdCBJdCA9IFwicXVpbHQudGhyZWFkcy5waW5nXCIsIE1lID0gXCJxdWlsdC50aHJlYWRzLnBvbmdcIjtcbmZ1bmN0aW9uIFB0KHIsIHtcbiAgdGFyZ2V0T3JpZ2luOiBlID0gXCIqXCJcbn0gPSB7fSkge1xuICBsZXQgdCA9ICExO1xuICBjb25zdCBuID0gZnVuY3Rpb24oYSwgdSkge1xuICAgIHIucG9zdE1lc3NhZ2UoYSwgZSwgdSk7XG4gIH0sIHMgPSBuZXcgUHJvbWlzZSgobykgPT4ge1xuICAgIGNvbnN0IGEgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgZ2xvYmFsVGhpcy53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKHUpID0+IHtcbiAgICAgIHUuc291cmNlID09PSByICYmIHUuZGF0YSA9PT0gTWUgJiYgKHQgPSAhMCwgYS5hYm9ydCgpLCBvKCkpO1xuICAgIH0sIHtcbiAgICAgIHNpZ25hbDogYS5zaWduYWxcbiAgICB9KSwgYS5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IG8oKSwge1xuICAgICAgb25jZTogITBcbiAgICB9KSwgbihJdCk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHNlbmQobywgYSkge1xuICAgICAgcmV0dXJuIHQgPyBuKG8sIGEpIDogcy50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHQpIHJldHVybiBuKG8sIGEpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBsaXN0ZW4obywge1xuICAgICAgc2lnbmFsOiBhXG4gICAgfSkge1xuICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAodSkgPT4ge1xuICAgICAgICB1LnNvdXJjZSA9PT0gciAmJiB1LmRhdGEgIT09IE1lICYmIG8odS5kYXRhKTtcbiAgICAgIH0sIHtcbiAgICAgICAgc2lnbmFsOiBhXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5jbGFzcyBPdCBleHRlbmRzIE10IHtcbiAgY29uc3RydWN0b3IoZSwge1xuICAgIHRhcmdldE9yaWdpbjogdCA9IFwiKlwiLFxuICAgIC4uLm5cbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoUHQoZS5jb250ZW50V2luZG93LCB7XG4gICAgICB0YXJnZXRPcmlnaW46IHRcbiAgICB9KSwgbiksIHRoaXMuaWZyYW1lID0gZTtcbiAgfVxufVxuY29uc3QgRmUgPSByZS5mb3J3YXJkUmVmKCh7IGNvbnRlbnQ6IHIsIGNoaWxkcmVuOiBlLCAuLi50IH0sIG4pID0+IC8qIEBfX1BVUkVfXyAqLyB2KFwic3BhblwiLCB7IHJlZjogbiwgLi4udCwgY2hpbGRyZW46IHIgfHwgZSB9KSk7XG5GZS5kaXNwbGF5TmFtZSA9IFwiVUlUZXh0XCI7XG5jb25zdCBZZSA9IHJlLmZvcndhcmRSZWYoKHsgbGFiZWw6IHIsIG9uUHJlc3M6IGUsIG9uQ2xpY2s6IHQsIGNoaWxkcmVuOiBuLCAuLi5zIH0sIG8pID0+IC8qIEBfX1BVUkVfXyAqLyB2KFxuICBcImJ1dHRvblwiLFxuICB7XG4gICAgcmVmOiBvLFxuICAgIG9uQ2xpY2s6ICh1KSA9PiB7XG4gICAgICBlICYmIGUoKSwgdCAmJiB0KHUpO1xuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIHBhZGRpbmc6IFwiOHB4IDE2cHhcIixcbiAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMDA3YmZmXCIsXG4gICAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgIGJvcmRlclJhZGl1czogXCI0cHhcIixcbiAgICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgICB9LFxuICAgIC4uLnMsXG4gICAgY2hpbGRyZW46IHIgfHwgblxuICB9XG4pKTtcblllLmRpc3BsYXlOYW1lID0gXCJVSUJ1dHRvblwiO1xuY29uc3QgR2UgPSByZS5mb3J3YXJkUmVmKFxuICAoe1xuICAgIGRpcmVjdGlvbjogciA9IFwidmVydGljYWxcIixcbiAgICBzcGFjaW5nOiBlID0gXCI4XCIsXG4gICAgYWxpZ246IHQgPSBcInN0cmV0Y2hcIixcbiAgICBqdXN0aWZ5OiBuID0gXCJmbGV4LXN0YXJ0XCIsXG4gICAgY2hpbGRyZW46IHMsXG4gICAgLi4ub1xuICB9LCBhKSA9PiAvKiBAX19QVVJFX18gKi8gdihcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIHJlZjogYSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICBmbGV4RGlyZWN0aW9uOiByID09PSBcImhvcml6b250YWxcIiA/IFwicm93XCIgOiBcImNvbHVtblwiLFxuICAgICAgICBnYXA6IGAke2V9cHhgLFxuICAgICAgICBhbGlnbkl0ZW1zOiB0LFxuICAgICAgICBqdXN0aWZ5Q29udGVudDogblxuICAgICAgfSxcbiAgICAgIC4uLm8sXG4gICAgICBjaGlsZHJlbjogc1xuICAgIH1cbiAgKVxuKTtcbkdlLmRpc3BsYXlOYW1lID0gXCJVSVN0YWNrXCI7XG5jb25zdCBWZSA9IHJlLmZvcndhcmRSZWYoKHsgc3JjOiByLCBhbHQ6IGUsIHdpZHRoOiB0LCBoZWlnaHQ6IG4sIGNoaWxkcmVuOiBzLCAuLi5vIH0sIGEpID0+IC8qIEBfX1BVUkVfXyAqLyB2KFxuICBcImltZ1wiLFxuICB7XG4gICAgcmVmOiBhLFxuICAgIHNyYzogcixcbiAgICBhbHQ6IGUsXG4gICAgd2lkdGg6IHQsXG4gICAgaGVpZ2h0OiBuLFxuICAgIHN0eWxlOiB7XG4gICAgICBtYXhXaWR0aDogXCIxMDAlXCIsXG4gICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgICAgYm9yZGVyUmFkaXVzOiBcIjhweFwiLFxuICAgICAgYm94U2hhZG93OiBcIjAgMnB4IDhweCByZ2JhKDAsIDAsIDAsIDAuMSlcIlxuICAgIH0sXG4gICAgLi4ub1xuICB9XG4pKTtcblZlLmRpc3BsYXlOYW1lID0gXCJVSUltYWdlXCI7XG5jb25zdCBXZSA9IHtcbiAgbmFtZTogXCJiYXNpY1wiLFxuICBlbGVtZW50czogW1xuICAgIHtcbiAgICAgIHRhZ05hbWU6IFwidWktdGV4dFwiLFxuICAgICAgY29tcG9uZW50OiBGZSxcbiAgICAgIHByb3BNYXBwaW5nOiB7XG4gICAgICAgIGNvbnRlbnQ6IFwiY29udGVudFwiXG4gICAgICB9LFxuICAgICAgZXZlbnRNYXBwaW5nOiB7fVxuICAgIH0sXG4gICAge1xuICAgICAgdGFnTmFtZTogXCJ1aS1idXR0b25cIixcbiAgICAgIGNvbXBvbmVudDogWWUsXG4gICAgICBwcm9wTWFwcGluZzoge1xuICAgICAgICBsYWJlbDogXCJsYWJlbFwiXG4gICAgICB9LFxuICAgICAgZXZlbnRNYXBwaW5nOiB7XG4gICAgICAgIHByZXNzOiBcIm9uUHJlc3NcIlxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgdGFnTmFtZTogXCJ1aS1zdGFja1wiLFxuICAgICAgY29tcG9uZW50OiBHZSxcbiAgICAgIHByb3BNYXBwaW5nOiB7XG4gICAgICAgIGRpcmVjdGlvbjogXCJkaXJlY3Rpb25cIixcbiAgICAgICAgc3BhY2luZzogXCJzcGFjaW5nXCIsXG4gICAgICAgIGFsaWduOiBcImFsaWduXCIsXG4gICAgICAgIGp1c3RpZnk6IFwianVzdGlmeVwiXG4gICAgICB9LFxuICAgICAgZXZlbnRNYXBwaW5nOiB7fVxuICAgIH0sXG4gICAge1xuICAgICAgdGFnTmFtZTogXCJ1aS1pbWFnZVwiLFxuICAgICAgY29tcG9uZW50OiBWZSxcbiAgICAgIHByb3BNYXBwaW5nOiB7XG4gICAgICAgIHNyYzogXCJzcmNcIixcbiAgICAgICAgYWx0OiBcImFsdFwiLFxuICAgICAgICB3aWR0aDogXCJ3aWR0aFwiLFxuICAgICAgICBoZWlnaHQ6IFwiaGVpZ2h0XCJcbiAgICAgIH0sXG4gICAgICBldmVudE1hcHBpbmc6IHt9XG4gICAgfVxuICBdXG59LCBEdCA9ICh7IHJlY2VpdmVyOiByIH0pID0+IHtcbiAgY29uc3QgZSA9IEIobnVsbCk7XG4gIHJldHVybiBIKCgpID0+IHtcbiAgICBpZiAoZS5jdXJyZW50KVxuICAgICAgcmV0dXJuIHIuY29ubmVjdChlLmN1cnJlbnQpLCAoKSA9PiB7XG4gICAgICAgIHIuZGlzY29ubmVjdCgpO1xuICAgICAgfTtcbiAgfSwgW3JdKSwgLyogQF9fUFVSRV9fICovIHYoXCJkaXZcIiwgeyByZWY6IGUsIFwiZGF0YS10ZXN0aWRcIjogXCJzdGFuZGFyZC1kb20tcmVuZGVyZXItY29udGFpbmVyXCIgfSk7XG59LCBDdCA9ICh7XG4gIHJlc291cmNlOiByLFxuICBsaWJyYXJ5OiBlLFxuICByZW1vdGVFbGVtZW50czogdCA9IFtdLFxuICBvblVJQWN0aW9uOiBuXG59KSA9PiB7XG4gIGNvbnN0IHMgPSBCKG51bGwpLCBvID0gQihudWxsKSwgW2EsIHVdID0gQWUobnVsbCksIGwgPSB6KCgpID0+IChyLm1pbWVUeXBlIHx8IFwiXCIpLmluY2x1ZGVzKFwiZnJhbWV3b3JrPXJlYWN0XCIpID8gXCJyZWFjdFwiIDogXCJ3ZWJjb21wb25lbnRzXCIsIFtyLm1pbWVUeXBlXSksIGYgPSBgJHtlID09IG51bGwgPyB2b2lkIDAgOiBlLm5hbWV9LSR7bH1gLCB7IHJlY2VpdmVyOiBpLCBjb21wb25lbnRzOiBtIH0gPSB6KCgpID0+IHtcbiAgICBzd2l0Y2ggKGwpIHtcbiAgICAgIGNhc2UgXCJyZWFjdFwiOiB7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgZHQoKSwgcCA9IGUgfHwgV2UsIGggPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICByZXR1cm4gcCAmJiBwLmVsZW1lbnRzLmZvckVhY2goKEUpID0+IHtcbiAgICAgICAgICBjb25zdCBfID0gX3QoRS5jb21wb25lbnQpO1xuICAgICAgICAgIGguc2V0KEUudGFnTmFtZSwgXyk7XG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgcmVjZWl2ZXI6IGMsXG4gICAgICAgICAgY29tcG9uZW50czogaFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY2FzZSBcIndlYmNvbXBvbmVudHNcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVjZWl2ZXI6IG5ldyB1dCgpLFxuICAgICAgICAgIGNvbXBvbmVudHM6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG4gIH0sIFtyLCBlLCB0XSk7XG4gIEgoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIGMocCkge1xuICAgICAgdmFyIGg7XG4gICAgICBpZiAocy5jdXJyZW50ICYmIHAuc291cmNlID09PSBzLmN1cnJlbnQuY29udGVudFdpbmRvdykge1xuICAgICAgICBjb25zdCBFID0gcC5kYXRhO1xuICAgICAgICBpZiAoIUUpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICAoaCA9IG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4oRSkpID09IG51bGwgfHwgaC5jYXRjaCgoXykgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBoYW5kbGluZyBVSSBhY3Rpb24gcmVzdWx0IGluIFJlbW90ZURPTVJlc291cmNlUmVuZGVyZXI6XCIsIF8pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBjKSwgKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGMpO1xuICB9LCBbbl0pLCBIKCgpID0+IHtcbiAgICBjb25zdCBjID0gby5jdXJyZW50O1xuICAgIHJldHVybiBvLmN1cnJlbnQgPSBudWxsLCAoKSA9PiB7XG4gICAgICBjID09IG51bGwgfHwgYy5jbG9zZSgpO1xuICAgIH07XG4gIH0sIFtmXSk7XG4gIGNvbnN0IGQgPSAoKSA9PiB7XG4gICAgY29uc3QgYyA9IHMuY3VycmVudDtcbiAgICBpZiAoIWMgfHwgby5jdXJyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHAgPSBuZXcgT3QoYyk7XG4gICAgby5jdXJyZW50ID0gcDtcbiAgICBjb25zdCB7IGNvZGU6IGgsIGVycm9yOiBFIH0gPSB0dChyKTtcbiAgICBpZiAoRSkge1xuICAgICAgdShFKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGggJiYgKGkgIT0gbnVsbCAmJiBpLmNvbm5lY3Rpb24pKSB7XG4gICAgICBjb25zdCBfID0ge1xuICAgICAgICBjb2RlOiBoLFxuICAgICAgICByZW1vdGVFbGVtZW50czogdCxcbiAgICAgICAgdXNlUmVhY3RSZW5kZXJlcjogbCA9PT0gXCJyZWFjdFwiLFxuICAgICAgICBjb21wb25lbnRMaWJyYXJ5OiBlID09IG51bGwgPyB2b2lkIDAgOiBlLm5hbWVcbiAgICAgIH07XG4gICAgICBwLmltcG9ydHMucmVuZGVyKF8sIGkuY29ubmVjdGlvbikuY2F0Y2goKFIpID0+IGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjYWxsaW5nIHJlbW90ZSByZW5kZXI6XCIsIFIpKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBhID8gLyogQF9fUFVSRV9fICovIHYoXCJwXCIsIHsgY2xhc3NOYW1lOiBcInRleHQtcmVkLTUwMFwiLCBjaGlsZHJlbjogYSB9KSA6IC8qIEBfX1BVUkVfXyAqLyBjZSh0ZSwgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyB2KFxuICAgICAgXCJpZnJhbWVcIixcbiAgICAgIHtcbiAgICAgICAgcmVmOiBzLFxuICAgICAgICBzcmNEb2M6IHZ0LFxuICAgICAgICBzYW5kYm94OiBcImFsbG93LXNjcmlwdHNcIixcbiAgICAgICAgc3R5bGU6IHsgZGlzcGxheTogXCJub25lXCIgfSxcbiAgICAgICAgdGl0bGU6IFwiUmVtb3RlIERPTSBTYW5kYm94XCIsXG4gICAgICAgIG9uTG9hZDogZFxuICAgICAgfSxcbiAgICAgIGZcbiAgICApLFxuICAgIGwgPT09IFwicmVhY3RcIiAmJiBtID8gLyogQF9fUFVSRV9fICovIHYoYnQsIHsgcmVjZWl2ZXI6IGksIGNvbXBvbmVudHM6IG0gfSkgOiAvKiBAX19QVVJFX18gKi8gdihEdCwgeyByZWNlaXZlcjogaSB9KVxuICBdIH0pO1xufTtcbmZ1bmN0aW9uIEx0KHIpIHtcbiAgdmFyIGU7XG4gIGlmIChyLmNvbnRlbnRUeXBlKVxuICAgIHJldHVybiByLmNvbnRlbnRUeXBlO1xuICBpZiAoci5taW1lVHlwZSA9PT0gXCJ0ZXh0L2h0bWxcIilcbiAgICByZXR1cm4gXCJyYXdIdG1sXCI7XG4gIGlmIChyLm1pbWVUeXBlID09PSBcInRleHQvdXJpLWxpc3RcIilcbiAgICByZXR1cm4gXCJleHRlcm5hbFVybFwiO1xuICBpZiAoKGUgPSByLm1pbWVUeXBlKSAhPSBudWxsICYmIGUuc3RhcnRzV2l0aChcImFwcGxpY2F0aW9uL3ZuZC5tY3AtdWkucmVtb3RlLWRvbVwiKSlcbiAgICByZXR1cm4gXCJyZW1vdGVEb21cIjtcbn1cbmNvbnN0IFV0ID0gKHIpID0+IHtcbiAgY29uc3QgeyByZXNvdXJjZTogZSwgb25VSUFjdGlvbjogdCwgc3VwcG9ydGVkQ29udGVudFR5cGVzOiBuLCBodG1sUHJvcHM6IHMsIHJlbW90ZURvbVByb3BzOiBvIH0gPSByLCBhID0gTHQoZSk7XG4gIGlmIChuICYmIGEgJiYgIW4uaW5jbHVkZXMoYSkpXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjZShcInBcIiwgeyBjbGFzc05hbWU6IFwidGV4dC1yZWQtNTAwXCIsIGNoaWxkcmVuOiBbXG4gICAgICBcIlVuc3VwcG9ydGVkIGNvbnRlbnQgdHlwZTogXCIsXG4gICAgICBhLFxuICAgICAgXCIuXCJcbiAgICBdIH0pO1xuICBzd2l0Y2ggKGEpIHtcbiAgICBjYXNlIFwicmF3SHRtbFwiOlxuICAgIGNhc2UgXCJleHRlcm5hbFVybFwiOlxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB2KE5lLCB7IHJlc291cmNlOiBlLCBvblVJQWN0aW9uOiB0LCAuLi5zIH0pO1xuICAgIGNhc2UgXCJyZW1vdGVEb21cIjpcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gdihcbiAgICAgICAgQ3QsXG4gICAgICAgIHtcbiAgICAgICAgICByZXNvdXJjZTogZSxcbiAgICAgICAgICBvblVJQWN0aW9uOiB0LFxuICAgICAgICAgIGxpYnJhcnk6IChvID09IG51bGwgPyB2b2lkIDAgOiBvLmxpYnJhcnkpIHx8IFdlLFxuICAgICAgICAgIC4uLm9cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB2KFwicFwiLCB7IGNsYXNzTmFtZTogXCJ0ZXh0LXJlZC01MDBcIiwgY2hpbGRyZW46IFwiVW5zdXBwb3J0ZWQgcmVzb3VyY2UgdHlwZS5cIiB9KTtcbiAgfVxufTtcblV0LmRpc3BsYXlOYW1lID0gXCJVSVJlc291cmNlUmVuZGVyZXJcIjtcbmZ1bmN0aW9uIGp0KHIpIHtcbiAgdmFyIGUsIHQ7XG4gIHJldHVybiAoci50eXBlID09PSBcInJlc291cmNlXCIgJiYgKCh0ID0gKGUgPSByLnJlc291cmNlKSA9PSBudWxsID8gdm9pZCAwIDogZS51cmkpID09IG51bGwgPyB2b2lkIDAgOiB0LnN0YXJ0c1dpdGgoXCJ1aTovL1wiKSkpID8/ICExO1xufVxuY29uc3QgRnQgPSB7XG4gIHRhZ05hbWU6IFwidWktY2FyZFwiXG59LCBZdCA9IHtcbiAgdGFnTmFtZTogXCJ1aS1idXR0b25cIixcbiAgcmVtb3RlQXR0cmlidXRlczogW1wibGFiZWxcIl0sXG4gIHJlbW90ZUV2ZW50czogW1wiY2xpY2tcIiwgXCJwcmVzc1wiXVxufSwgR3QgPSB7XG4gIHRhZ05hbWU6IFwidWktdGV4dFwiLFxuICByZW1vdGVBdHRyaWJ1dGVzOiBbXCJjb250ZW50XCJdXG59LCBWdCA9IHtcbiAgdGFnTmFtZTogXCJ1aS1zdGFja1wiLFxuICByZW1vdGVBdHRyaWJ1dGVzOiBbXCJkaXJlY3Rpb25cIiwgXCJzcGFjaW5nXCIsIFwiYWxpZ25cIiwgXCJqdXN0aWZ5XCJdXG59LCBXdCA9IHtcbiAgdGFnTmFtZTogXCJ1aS1pbWFnZVwiLFxuICByZW1vdGVBdHRyaWJ1dGVzOiBbXCJzcmNcIiwgXCJhbHRcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiXVxufTtcbmV4cG9ydCB7XG4gIFV0IGFzIFVJUmVzb3VyY2VSZW5kZXJlcixcbiAgV2UgYXMgYmFzaWNDb21wb25lbnRMaWJyYXJ5LFxuICBydCBhcyBnZXRSZXNvdXJjZU1ldGFkYXRhLFxuICBudCBhcyBnZXRVSVJlc291cmNlTWV0YWRhdGEsXG4gIGp0IGFzIGlzVUlSZXNvdXJjZSxcbiAgWXQgYXMgcmVtb3RlQnV0dG9uRGVmaW5pdGlvbixcbiAgRnQgYXMgcmVtb3RlQ2FyZERlZmluaXRpb24sXG4gIFd0IGFzIHJlbW90ZUltYWdlRGVmaW5pdGlvbixcbiAgVnQgYXMgcmVtb3RlU3RhY2tEZWZpbml0aW9uLFxuICBHdCBhcyByZW1vdGVUZXh0RGVmaW5pdGlvblxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@mcp-ui/client/dist/index.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CAsus%5C%5CDownloads%5C%5Cmcp%5C%5Cclient%5C%5Csrc%5C%5Capp%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);