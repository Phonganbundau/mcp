"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@mcp-ui";
exports.ids = ["vendor-chunks/@mcp-ui"];
exports.modules = {

/***/ "(ssr)/./node_modules/@mcp-ui/client/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@mcp-ui/client/dist/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UIResourceRenderer: () => (/* binding */ Ut),\n/* harmony export */   basicComponentLibrary: () => (/* binding */ We),\n/* harmony export */   getResourceMetadata: () => (/* binding */ rt),\n/* harmony export */   getUIResourceMetadata: () => (/* binding */ nt),\n/* harmony export */   isUIResource: () => (/* binding */ jt),\n/* harmony export */   remoteButtonDefinition: () => (/* binding */ Yt),\n/* harmony export */   remoteCardDefinition: () => (/* binding */ Ft),\n/* harmony export */   remoteImageDefinition: () => (/* binding */ Wt),\n/* harmony export */   remoteStackDefinition: () => (/* binding */ Vt),\n/* harmony export */   remoteTextDefinition: () => (/* binding */ Gt)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar Be = Object.defineProperty;\nvar pe = (r) => {\n  throw TypeError(r);\n};\nvar $e = (r, e, t) => e in r ? Be(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;\nvar L = (r, e, t) => $e(r, typeof e != \"symbol\" ? e + \"\" : e, t), oe = (r, e, t) => e.has(r) || pe(\"Cannot \" + t);\nvar b = (r, e, t) => (oe(r, e, \"read from private field\"), t ? t.call(r) : e.get(r)), S = (r, e, t) => e.has(r) ? pe(\"Cannot add the same private member more than once\") : e instanceof WeakSet ? e.add(r) : e.set(r, t), Z = (r, e, t, n) => (oe(r, e, \"write to private field\"), n ? n.call(r, t) : e.set(r, t), t), y = (r, e, t) => (oe(r, e, \"access private method\"), t);\n\n\nconst fe = {\n  PREFERRED_FRAME_SIZE: \"preferred-frame-size\",\n  INITIAL_RENDER_DATA: \"initial-render-data\"\n}, he = \"mcpui.dev/ui-\";\nfunction Qe(r) {\n  let e;\n  try {\n    e = new URL(r);\n  } catch (t) {\n    return console.error(\"Error parsing URL:\", t), !1;\n  }\n  return e.protocol === \"http:\" || e.protocol === \"https:\";\n}\nfunction et(r, e) {\n  if (r.mimeType !== \"text/html\" && r.mimeType !== \"text/uri-list\")\n    return {\n      error: \"Resource must be of type text/html (for HTML content) or text/uri-list (for URL content).\"\n    };\n  if (r.mimeType === \"text/uri-list\") {\n    let t = \"\";\n    if (typeof r.text == \"string\" && r.text.trim() !== \"\")\n      t = r.text;\n    else if (typeof r.blob == \"string\")\n      try {\n        t = new TextDecoder().decode(\n          Uint8Array.from(atob(r.blob), (o) => o.charCodeAt(0))\n        );\n      } catch (o) {\n        return console.error(\"Error decoding base64 blob for URL content:\", o), {\n          error: \"Error decoding URL from blob.\"\n        };\n      }\n    else\n      return {\n        error: \"URL resource expects a non-empty text or blob field containing the URL.\"\n      };\n    if (t.trim() === \"\")\n      return {\n        error: \"URL content is empty.\"\n      };\n    const n = t.split(`\n`).map((o) => o.trim()).filter((o) => o && !o.startsWith(\"#\") && Qe(o));\n    if (n.length === 0)\n      return {\n        error: \"No valid URLs found in uri-list content.\"\n      };\n    n.length > 1 && console.warn(\n      `Multiple URLs found in uri-list content. Using the first URL: \"${n[0]}\". Other URLs ignored:`,\n      n.slice(1)\n    );\n    const s = n[0];\n    if (e && e.trim() !== \"\")\n      try {\n        const o = new URL(e);\n        if (typeof window < \"u\" && o.host === window.location.host)\n          console.error(\n            \"For security, the proxy origin must not be the same as the host origin. Using original URL instead.\"\n          );\n        else\n          return o.searchParams.set(\"url\", s), {\n            iframeSrc: o.toString(),\n            iframeRenderMode: \"src\"\n          };\n      } catch (o) {\n        console.error(\n          `Invalid proxy URL provided: \"${e}\". Falling back to direct URL.`,\n          o instanceof Error ? o.message : String(o)\n        );\n      }\n    return {\n      iframeSrc: s,\n      iframeRenderMode: \"src\"\n    };\n  } else if (r.mimeType === \"text/html\") {\n    let t = \"\";\n    if (typeof r.text == \"string\")\n      t = r.text;\n    else if (typeof r.blob == \"string\")\n      try {\n        t = new TextDecoder().decode(\n          Uint8Array.from(atob(r.blob), (n) => n.charCodeAt(0))\n        );\n      } catch (n) {\n        return console.error(\"Error decoding base64 blob for HTML content:\", n), {\n          error: \"Error decoding HTML content from blob.\"\n        };\n      }\n    else\n      return {\n        error: \"HTML resource requires text or blob content.\"\n      };\n    if (e && e.trim() !== \"\")\n      try {\n        const n = new URL(e);\n        if (typeof window < \"u\" && n.host === window.location.host)\n          console.error(\n            \"For security, the proxy origin must not be the same as the host origin. Using srcDoc rendering instead.\"\n          );\n        else\n          return n.searchParams.set(\"contentType\", \"rawhtml\"), {\n            iframeSrc: n.toString(),\n            iframeRenderMode: \"src\",\n            htmlString: t\n            // Pass HTML so it can be sent to the proxy via postMessage\n          };\n      } catch (n) {\n        console.error(\n          `Invalid proxy URL provided: \"${e}\". Falling back to srcDoc rendering.`,\n          n instanceof Error ? n.message : String(n)\n        );\n      }\n    return {\n      htmlString: t,\n      iframeRenderMode: \"srcDoc\"\n    };\n  } else\n    return {\n      error: \"Unsupported mimeType. Expected text/html or text/uri-list.\"\n    };\n}\nfunction tt(r) {\n  if (typeof r.text == \"string\" && r.text.trim() !== \"\")\n    return {\n      code: r.text\n    };\n  if (typeof r.blob == \"string\")\n    try {\n      return {\n        code: new TextDecoder().decode(\n          Uint8Array.from(atob(r.blob), (t) => t.charCodeAt(0))\n        )\n      };\n    } catch (e) {\n      return console.error(\"Error decoding base64 blob for remote DOM content:\", e), {\n        error: \"Error decoding remote DOM content from blob.\"\n      };\n    }\n  return {\n    error: \"Remote DOM resource requires non-empty text or blob content.\"\n  };\n}\nfunction rt(r) {\n  return r._meta ?? {};\n}\nfunction nt(r) {\n  const e = rt(r), t = {};\n  return Object.entries(e).forEach(([n, s]) => {\n    n.startsWith(he) && (t[n.slice(he.length)] = s);\n  }), t;\n}\nconst N = {\n  UI_MESSAGE_RECEIVED: \"ui-message-received\",\n  UI_MESSAGE_RESPONSE: \"ui-message-response\",\n  UI_SIZE_CHANGE: \"ui-size-change\",\n  UI_LIFECYCLE_IFRAME_READY: \"ui-lifecycle-iframe-ready\",\n  UI_LIFECYCLE_IFRAME_RENDER_DATA: \"ui-lifecycle-iframe-render-data\",\n  UI_REQUEST_RENDER_DATA: \"ui-request-render-data\",\n  // Proxy-only lifecycle for outer iframe (distinct from widget readiness)\n  UI_PROXY_IFRAME_READY: \"ui-proxy-iframe-ready\",\n  // Content transport for raw HTML when using proxy\n  UI_HTML_CONTENT: \"ui-html-content\"\n}, ot = {\n  WAIT_FOR_RENDER_DATA: \"waitForRenderData\"\n}, Ne = ({\n  resource: r,\n  onUIAction: e,\n  style: t,\n  proxy: n,\n  iframeRenderData: s,\n  autoResizeIframe: o,\n  sandboxPermissions: a,\n  iframeProps: u\n}) => {\n  const l = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(u == null ? void 0 : u.ref, () => l.current);\n  const { error: f, iframeSrc: i, iframeRenderMode: m, htmlString: d } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(\n    () => et(r, n),\n    [r, n]\n  ), c = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => nt(r), [r]), p = c[fe.PREFERRED_FRAME_SIZE] ?? [\"100%\", \"100%\"], h = c[fe.INITIAL_RENDER_DATA] ?? void 0, E = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    if (!(!s && !h))\n      return {\n        ...h,\n        ...s\n      };\n  }, [s, h]), _ = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    if (i && E) {\n      const T = new URL(i);\n      return T.searchParams.set(ot.WAIT_FOR_RENDER_DATA, \"true\"), T.toString();\n    }\n    return i;\n  }, [i, E]), R = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (T) => {\n      var j;\n      if (E) {\n        const I = T.currentTarget.contentWindow, P = _ ? new URL(_).origin : \"*\";\n        U(\n          N.UI_LIFECYCLE_IFRAME_RENDER_DATA,\n          I,\n          P,\n          void 0,\n          {\n            renderData: E\n          }\n        );\n      }\n      (j = u == null ? void 0 : u.onLoad) == null || j.call(u, T);\n    },\n    [E, _, u == null ? void 0 : u.onLoad]\n  ), A = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => m === \"srcDoc\" ? _e(a ?? \"\", \"allow-scripts\") : _e(a ?? \"\", \"allow-scripts allow-same-origin\"), [a, m]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    async function T(j) {\n      const { source: I, origin: P, data: g } = j;\n      if (l.current && I === l.current.contentWindow) {\n        if ((g == null ? void 0 : g.type) === N.UI_PROXY_IFRAME_READY) {\n          m === \"src\" && d && (_ != null && _.includes(\"contentType=rawhtml\")) && U(\n            N.UI_HTML_CONTENT,\n            I,\n            P,\n            void 0,\n            {\n              html: d,\n              sandbox: A\n            }\n          );\n          return;\n        }\n        if ((g == null ? void 0 : g.type) === N.UI_LIFECYCLE_IFRAME_READY) {\n          E && U(\n            N.UI_LIFECYCLE_IFRAME_RENDER_DATA,\n            I,\n            P,\n            void 0,\n            {\n              renderData: E\n            }\n          );\n          return;\n        }\n        if ((g == null ? void 0 : g.type) === N.UI_REQUEST_RENDER_DATA) {\n          U(\n            N.UI_LIFECYCLE_IFRAME_RENDER_DATA,\n            I,\n            P,\n            g.messageId,\n            {\n              renderData: E\n            }\n          );\n          return;\n        }\n        if ((g == null ? void 0 : g.type) === N.UI_SIZE_CHANGE) {\n          const { width: F, height: C } = g.payload;\n          if (o && l.current) {\n            const He = (typeof o == \"boolean\" || o.height) && C, qe = (typeof o == \"boolean\" || o.width) && F;\n            He && (l.current.style.height = `${C}px`), qe && (l.current.style.width = `${F}px`);\n          }\n          return;\n        }\n        const ne = g;\n        if (!ne)\n          return;\n        if (e) {\n          const F = ne.messageId;\n          U(N.UI_MESSAGE_RECEIVED, I, P, F);\n          try {\n            const C = await e(ne);\n            U(N.UI_MESSAGE_RESPONSE, I, P, F, {\n              response: C\n            });\n          } catch (C) {\n            console.error(\"Error handling UI action result in HTMLResourceRenderer:\", C), U(N.UI_MESSAGE_RESPONSE, I, P, F, {\n              error: C\n            });\n          }\n        }\n      }\n    }\n    return window.addEventListener(\"message\", T), () => window.removeEventListener(\"message\", T);\n  }, [e, E, m, d, _, A]), f ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", { className: \"text-red-500\", children: f }) : m === \"srcDoc\" ? d == null ? f ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", { className: \"text-orange-500\", children: \"No HTML content to display.\" }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    \"iframe\",\n    {\n      srcDoc: d,\n      sandbox: A,\n      style: { width: p[0], height: p[1], ...t },\n      title: \"MCP HTML Resource (Embedded Content)\",\n      ...u,\n      ref: l,\n      onLoad: R\n    }\n  ) : m === \"src\" ? _ == null ? f ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", { className: \"text-orange-500\", children: \"No URL provided for HTML resource.\" }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    \"iframe\",\n    {\n      src: _,\n      sandbox: A,\n      style: { width: p[0], height: p[1], ...t },\n      title: \"MCP HTML Resource (URL)\",\n      ...u,\n      ref: l,\n      onLoad: R\n    }\n  ) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", { className: \"text-gray-500\", children: \"Initializing HTML resource display...\" });\n};\nNe.displayName = \"HTMLResourceRenderer\";\nfunction U(r, e, t, n, s) {\n  const o = t && t !== \"null\" ? t : \"*\";\n  e == null || e.postMessage(\n    {\n      type: r,\n      messageId: n ?? void 0,\n      payload: s\n    },\n    o\n  );\n}\nfunction _e(r, e) {\n  return [.../* @__PURE__ */ new Set([...r.split(\" \"), ...e.split(\" \")])].filter(Boolean).map((t) => t.trim()).join(\" \");\n}\nconst Ie = 1, Pe = 3, Oe = 8, it = 9, st = 0, at = 1, lt = 2, ct = 3, $ = 1, de = 2, ue = 3, q = \"~\";\nfunction De({\n  call: r,\n  insertChild: e,\n  removeChild: t,\n  updateText: n,\n  updateProperty: s\n}) {\n  const o = {\n    [st]: e,\n    [at]: t,\n    [lt]: n,\n    [ct]: s\n  };\n  return {\n    call: r,\n    mutate(a) {\n      for (const [u, ...l] of a)\n        o[u](...l);\n    }\n  };\n}\nclass dt {\n  constructor({\n    retain: e,\n    release: t,\n    methods: n\n  } = {}) {\n    /**\n     * Represents the root node of the remote tree. This node is always defined,\n     * and you will likely be most interested in its `children` property, which\n     * contains the top-level elements of the remote tree.\n     */\n    L(this, \"root\", {\n      id: q,\n      type: it,\n      children: [],\n      version: 0,\n      properties: {},\n      attributes: {},\n      eventListeners: {}\n    });\n    /**\n     * An object that can synchronize a tree of elements between two JavaScript\n     * environments. This object acts as a “thin waist”, allowing for efficient\n     * communication of changes between a “remote” environment (usually, a JavaScript\n     * sandbox, such as an `iframe` or Web Worker) and a “host” environment\n     * (usually, a top-level browser page).\n     */\n    L(this, \"attached\", /* @__PURE__ */ new Map([[q, this.root]]));\n    L(this, \"subscribers\", /* @__PURE__ */ new Map());\n    L(this, \"parents\", /* @__PURE__ */ new Map());\n    L(this, \"implementations\", /* @__PURE__ */ new Map());\n    const {\n      attached: s,\n      parents: o,\n      subscribers: a\n    } = this;\n    this.connection = De({\n      call: (i, m, ...d) => {\n        const c = this.implementations.get(i), p = c == null ? void 0 : c[m];\n        if (typeof p != \"function\")\n          throw new Error(`Node ${i} does not implement the ${m}() method`);\n        return p(...d);\n      },\n      insertChild: (i, m, d) => {\n        const c = s.get(i), {\n          children: p\n        } = c, h = l(m, c);\n        d === p.length ? p.push(h) : p.splice(d, 0, h), c.version += 1, this.parents.set(m.id, c.id), u(c);\n      },\n      removeChild: (i, m) => {\n        const d = s.get(i), {\n          children: c\n        } = d, [p] = c.splice(m, 1);\n        p && (d.version += 1, u(d), f(p));\n      },\n      updateProperty: (i, m, d, c = $) => {\n        const p = s.get(i);\n        e == null || e(d);\n        let h;\n        switch (c) {\n          case $:\n            h = p.properties;\n            break;\n          case de:\n            h = p.attributes;\n            break;\n          case ue:\n            h = p.eventListeners;\n            break;\n        }\n        const E = h[m];\n        h[m] = d, p.version += 1;\n        let _;\n        if (m === \"slot\") {\n          const R = this.parents.get(i);\n          _ = R == null ? R : s.get(R), _ && (_.version += 1);\n        }\n        u(p), _ && u(_), t == null || t(E);\n      },\n      updateText: (i, m) => {\n        const d = s.get(i);\n        d.data = m, d.version += 1, u(d);\n      }\n    }), n && this.implement(this.root, n);\n    function u(i) {\n      const m = a.get(i.id);\n      if (m)\n        for (const d of m)\n          d(i);\n    }\n    function l(i, m) {\n      let d;\n      switch (i.type) {\n        case Pe:\n        case Oe: {\n          const {\n            id: c,\n            type: p,\n            data: h\n          } = i;\n          d = {\n            id: c,\n            type: p,\n            data: h,\n            version: 0\n          };\n          break;\n        }\n        case Ie: {\n          const {\n            id: c,\n            type: p,\n            element: h,\n            children: E,\n            properties: _,\n            attributes: R,\n            eventListeners: A\n          } = i;\n          e == null || e(_), e == null || e(A);\n          const T = [];\n          d = {\n            id: c,\n            type: p,\n            element: h,\n            version: 0,\n            children: T,\n            properties: {\n              ..._\n            },\n            attributes: {\n              ...R\n            },\n            eventListeners: {\n              ...A\n            }\n          };\n          for (const j of E)\n            T.push(l(j, d));\n          break;\n        }\n        default:\n          throw new Error(`Unknown node type: ${JSON.stringify(i)}`);\n      }\n      return s.set(d.id, d), o.set(d.id, m.id), d;\n    }\n    function f(i) {\n      if (s.delete(i.id), o.delete(i.id), t && (\"properties\" in i && t(i.properties), \"eventListeners\" in i && t(i.eventListeners)), \"children\" in i)\n        for (const m of i.children)\n          f(m);\n    }\n  }\n  /**\n   * Fetches the latest state of a remote element that has been\n   * received from the remote environment.\n   *\n   * @param node The remote node to fetch.\n   * @returns The current state of the remote node, or `undefined` if the node is not connected to the remote tree.\n   *\n   * @example\n   * import {RemoteReceiver} from '@remote-dom/core/receivers';\n   *\n   * const receiver = new RemoteReceiver();\n   *\n   * receiver.get(receiver.root) === receiver.root; // true\n   */\n  get({\n    id: e\n  }) {\n    return this.attached.get(e);\n  }\n  /**\n   * Lets you define how [remote methods](https://github.com/Shopify/remote-dom/blob/main/packages/core#remotemethods)\n   * are implemented for a particular element in the tree.\n   *\n   * @param node The remote node to subscribe for changes.\n   * @param implementation A record containing the methods to expose for the passed node.\n   *\n   * @example\n   * // In the host environment:\n   * import {RemoteReceiver} from '@remote-dom/core/receivers';\n   *\n   * const receiver = new RemoteReceiver();\n   *\n   * receiver.implement(receiver.root, {\n   *   alert(message) {\n   *     window.alert(message);\n   *   },\n   * });\n   *\n   * // In the remote environment:\n   * import {RemoteRootElement} from '@remote-dom/core/elements';\n   *\n   * customElements.define('remote-root', RemoteRootElement);\n   *\n   * const root = document.createElement('remote-root');\n   * root.connect(receiver.connection);\n   *\n   * root.callRemoteMethod('alert', 'Hello, world!');\n   */\n  implement({\n    id: e\n  }, t) {\n    t == null ? this.implementations.delete(e) : this.implementations.set(e, t);\n  }\n  /**\n   * Allows you to subscribe to changes in a remote element. This includes\n   * changes to the remote element’s properties and list of children, but\n   * note that you will not receive updates for properties or children of\n   * _nested_ elements.\n   *\n   * @param node The remote node to subscribe for changes.\n   * @param subscriber A function that will be called with the updated node on each change.\n   *\n   * @example\n   * import {RemoteReceiver} from '@remote-dom/core/receivers';\n   *\n   * const abort = new AbortController();\n   * const receiver = new RemoteReceiver();\n   *\n   * // Subscribe to all changes in the top-level children, attached\n   * // directly to the remote “root”.\n   * receiver.subscribe(\n   *   receiver.root,\n   *   (root) => {\n   *     console.log('Root changed!', root);\n   *   },\n   *   {signal: abort.signal},\n   * );\n   */\n  subscribe({\n    id: e\n  }, t, {\n    signal: n\n  } = {}) {\n    let s = this.subscribers.get(e);\n    s == null && (s = /* @__PURE__ */ new Set(), this.subscribers.set(e, s)), s.add(t), n == null || n.addEventListener(\"abort\", () => {\n      s.delete(t), s.size === 0 && this.subscribers.delete(e);\n    });\n  }\n}\nconst Ee = /* @__PURE__ */ new WeakMap(), X = /* @__PURE__ */ new WeakMap(), Ce = /* @__PURE__ */ new WeakMap();\nclass ut {\n  constructor({\n    root: e,\n    retain: t,\n    release: n,\n    call: s,\n    cache: o\n  } = {}) {\n    /**\n     * The root element that will contain the host implementations of\n     * all nodes attached to the remote tree. To connect the receiver to\n     * a new element, call the `connect()` method.\n     */\n    /**\n     * An object that can synchronize a tree of elements between two JavaScript\n     * environments. This object acts as a “thin waist”, allowing for efficient\n     * communication of changes between a “remote” environment (usually, a JavaScript\n     * sandbox, such as an `iframe` or Web Worker) and a “host” environment\n     * (usually, a top-level browser page).\n     */\n    L(this, \"attached\", /* @__PURE__ */ new Map());\n    this.root = e ?? document.createDocumentFragment();\n    const {\n      attached: a\n    } = this, u = /* @__PURE__ */ new Map();\n    this.connection = De({\n      call: (i, m, ...d) => {\n        const c = i === q && this.root.nodeType !== 11 ? this.root : a.get(i);\n        return s ? s(c, m, ...d) : c[m](...d);\n      },\n      insertChild: (i, m, d) => {\n        const c = i === q ? this.root : a.get(i), p = u.get(i);\n        p && clearTimeout(p), c.insertBefore(l(m), c.childNodes[d] || null);\n      },\n      removeChild: (i, m) => {\n        const c = (i === q ? this.root : a.get(i)).childNodes[m];\n        if (c.remove(), o != null && o.maxAge) {\n          const p = u.get(i);\n          p && clearTimeout(p);\n          const h = setTimeout(() => {\n            f(c);\n          }, o.maxAge);\n          u.set(i, h);\n        } else\n          f(c);\n      },\n      updateProperty: (i, m, d, c = $) => {\n        const p = a.get(i);\n        t == null || t(d);\n        const h = X.get(p), E = h[m];\n        h[m] = d, J(p, m, d, c), n == null || n(E);\n      },\n      updateText: (i, m) => {\n        const d = a.get(i);\n        d.data = m;\n      }\n    });\n    function l(i) {\n      const m = a.get(i.id);\n      if (m) return m;\n      let d;\n      switch (i.type) {\n        case Ie: {\n          if (d = document.createElement(i.element), i.properties) {\n            X.set(d, i.properties);\n            for (const c of Object.keys(i.properties)) {\n              const p = i.properties[c];\n              t == null || t(p), J(d, c, p, $);\n            }\n          } else\n            X.set(d, {});\n          if (i.attributes)\n            for (const c of Object.keys(i.attributes)) {\n              const p = i.attributes[c];\n              t == null || t(p), J(d, c, p, de);\n            }\n          if (Ce.set(d, {}), i.eventListeners)\n            for (const c of Object.keys(i.eventListeners)) {\n              const p = i.eventListeners[c];\n              t == null || t(p), J(d, c, p, ue);\n            }\n          for (const c of i.children)\n            d.appendChild(l(c));\n          break;\n        }\n        case Pe: {\n          d = document.createTextNode(i.data);\n          break;\n        }\n        case Oe: {\n          d = document.createComment(i.data);\n          break;\n        }\n        default:\n          throw new Error(`Unknown node type: ${JSON.stringify(i)}`);\n      }\n      return Ee.set(d, i.id), a.set(i.id, d), d;\n    }\n    function f(i) {\n      const m = Ee.get(i);\n      m && a.delete(m);\n      const d = X.get(i);\n      if (d && n && n(d), i instanceof Element)\n        for (const c of i.childNodes)\n          f(c);\n    }\n  }\n  /**\n   * Connects the receiver to a new root element. The representation of\n   * any child elements of the remote root will be appended to this node\n   * as children, and the `root` property will be updated to point to the\n   * new element.\n   */\n  connect(e) {\n    const t = this.root;\n    this.root = e, t.childNodes.forEach((n) => {\n      e.appendChild(n);\n    });\n  }\n  /**\n   * Disconnects the receiver from its current root element. Any current\n   * children of the root element will be moved to a `DocumentFragment`\n   * instead, so they can be re-attached to a new element later.\n   */\n  disconnect() {\n    if (this.root.nodeType === 11) return this.root;\n    const e = this.root, t = new DocumentFragment();\n    return this.root = t, e.childNodes.forEach((n) => {\n      t.appendChild(n);\n    }), t;\n  }\n}\nfunction J(r, e, t, n) {\n  switch (n) {\n    case $: {\n      r[e] = t;\n      break;\n    }\n    case de: {\n      t == null ? r.removeAttribute(e) : r.setAttribute(e, t);\n      break;\n    }\n    case ue: {\n      const s = Ce.get(r), o = s == null ? void 0 : s[e];\n      if (o && r.removeEventListener(e, o), t != null) {\n        const a = (u) => {\n          var f;\n          if (u.target !== r) return;\n          const l = t(u.detail);\n          (f = u.resolve) == null || f.call(u, l);\n        };\n        s && (s[e] = a), r.addEventListener(e, a);\n      }\n      break;\n    }\n  }\n}\nfunction me(r, e) {\n  const [t, n] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(() => {\n    const o = e.get(r);\n    return {\n      id: r.id,\n      version: o == null ? void 0 : o.version,\n      value: o,\n      receiver: e\n    };\n  });\n  let s = t.value;\n  if (t.receiver !== e || t.id !== r.id) {\n    const o = e.get(r);\n    s = o, n({\n      receiver: e,\n      id: r.id,\n      version: o == null ? void 0 : o.version,\n      value: s\n    });\n  }\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useDebugValue)(s), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const o = new AbortController(), a = () => {\n      o.signal.aborted || n((u) => {\n        const {\n          id: l,\n          version: f,\n          receiver: i\n        } = u, {\n          id: m\n        } = r;\n        if (i !== e || l !== m)\n          return u;\n        const d = e.get(r), c = d == null ? void 0 : d.version;\n        return f === c ? u : {\n          receiver: e,\n          value: d,\n          id: m,\n          version: c\n        };\n      });\n    };\n    return e.subscribe(r, a, {\n      signal: o.signal\n    }), a(), () => {\n      o.abort();\n    };\n  }, [e, r.id]), s;\n}\nfunction mt({\n  remote: r,\n  receiver: e\n}) {\n  const t = me(r, e);\n  return t ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n    children: t.data\n  }) : null;\n}\nfunction se(r, {\n  receiver: e,\n  components: t\n}) {\n  switch (r.type) {\n    case 1: {\n      const n = t.get(r.element);\n      if (n == null)\n        throw new Error(`No component found for remote element: ${r.element}`);\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(n, {\n        element: r,\n        receiver: e,\n        components: t\n      }, r.id);\n    }\n    case 3:\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(mt, {\n        remote: r,\n        receiver: e\n      }, r.id);\n    case 8:\n      return null;\n    default:\n      throw new Error(`Unknown remote node type: ${String(r)}`);\n  }\n}\nfunction pt(r, e) {\n  if (!r) return;\n  const {\n    children: t,\n    properties: n,\n    attributes: s,\n    eventListeners: o\n  } = r, a = [], u = {\n    ...n,\n    ...s,\n    children: a\n  };\n  if (e.eventProps)\n    for (const [l, f] of Object.entries(e.eventProps)) {\n      const i = f == null ? void 0 : f.event;\n      if (i == null) continue;\n      const m = o[i];\n      m && (u[l] = be(m));\n    }\n  else\n    for (const [l, f] of Object.entries(o))\n      u[`on${l[0].toUpperCase()}${l.slice(1)}`] = be(f);\n  for (const l of t)\n    if (l.type === 1 && typeof l.attributes.slot == \"string\") {\n      const f = l.attributes.slot, i = se(l, e);\n      u[f] = u[f] ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [u[f], i]\n      }) : i;\n    } else\n      a.push(se(l, e));\n  return u;\n}\nfunction be(r) {\n  return function(...t) {\n    if (t.length === 1 && t[0] instanceof Event) {\n      const n = t[0];\n      return n.target !== n.currentTarget ? void 0 : \"detail\" in n ? r(n.detail) : r();\n    }\n    return r(...t);\n  };\n}\nconst ft = Symbol.for(\"remote-dom.element\"), ht = Symbol.for(\"remote-dom.element.attached\");\nfunction _t(r, {\n  name: e,\n  eventProps: t\n} = {}) {\n  const n = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(function({\n    element: o,\n    receiver: a,\n    components: u\n  }) {\n    const l = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(), f = me(o, a), i = f ?? o, m = i.id, d = pt(i, {\n      receiver: a,\n      components: u,\n      eventProps: t\n    });\n    if (d[ft] = i, d[ht] = f != null, l.current == null) {\n      const c = {\n        id: m,\n        receiver: a\n      };\n      c.instanceRef = Et(c), l.current = c;\n    }\n    return l.current.id = m, l.current.receiver = a, (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n      var p;\n      const c = {\n        id: m\n      };\n      return a.implement(c, (p = l.current) == null ? void 0 : p.instanceRef.current), () => {\n        a.implement(c, null);\n      };\n    }, [m, a]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(r, {\n      ref: l.current.instanceRef,\n      ...d\n    });\n  });\n  return n.displayName = e ?? `RemoteComponentRenderer(${r.displayName ?? r.name ?? \"Component\"})`, n;\n}\nfunction Et(r) {\n  let e = null;\n  return {\n    get current() {\n      return e;\n    },\n    set current(t) {\n      e = t, r.receiver.implement(r, t);\n    }\n  };\n}\nfunction bt(r) {\n  const {\n    receiver: e\n  } = r, {\n    children: t\n  } = me(e.root, e);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n    children: t.map((n) => se(n, r))\n  });\n}\nconst vt = `<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n</head>\n<body>\n  <div id=\"root\"></div>\n  <script>\n\"use strict\";\n(() => {\n  var __defProp = Object.defineProperty;\n  var __typeError = (msg) => {\n    throw TypeError(msg);\n  };\n  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\n  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\n  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\n  var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n  var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\n  var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\n\n  // ../../../node_modules/.pnpm/@remote-dom+core@1.8.1_@preact+signals-core@1.10.0/node_modules/@remote-dom/core/build/esm/elements/RemoteEvent.mjs\n  var RemoteEvent = class extends CustomEvent {\n    /**\n     * The last value received from a \\`respondWith()\\` call.\n     */\n    /**\n     * Provides the \\`response\\` value to be sent as the return value for\n     * the remote property function that triggered this event.\n     */\n    respondWith(response) {\n      this.response = response;\n    }\n  };\n\n  // ../../../node_modules/.pnpm/@remote-dom+core@1.8.1_@preact+signals-core@1.10.0/node_modules/@remote-dom/core/build/esm/constants.mjs\n  var MUTATION_TYPE_INSERT_CHILD = 0;\n  var MUTATION_TYPE_REMOVE_CHILD = 1;\n  var MUTATION_TYPE_UPDATE_TEXT = 2;\n  var MUTATION_TYPE_UPDATE_PROPERTY = 3;\n  var UPDATE_PROPERTY_TYPE_PROPERTY = 1;\n  var UPDATE_PROPERTY_TYPE_ATTRIBUTE = 2;\n  var UPDATE_PROPERTY_TYPE_EVENT_LISTENER = 3;\n  var ROOT_ID = \"~\";\n\n  // ../../../node_modules/.pnpm/@remote-dom+core@1.8.1_@preact+signals-core@1.10.0/node_modules/@remote-dom/core/build/esm/elements/internals.mjs\n  var REMOTE_CONNECTIONS = /* @__PURE__ */ new WeakMap();\n  var REMOTE_IDS = /* @__PURE__ */ new WeakMap();\n  var id = 0;\n  function remoteId(node) {\n    let remoteID = REMOTE_IDS.get(node);\n    if (remoteID == null) {\n      remoteID = String(id++);\n      REMOTE_IDS.set(node, remoteID);\n    }\n    return remoteID;\n  }\n  var REMOTE_PROPERTIES = /* @__PURE__ */ new WeakMap();\n  function remoteProperties(node) {\n    return REMOTE_PROPERTIES.get(node);\n  }\n  var REMOTE_ATTRIBUTES = /* @__PURE__ */ new WeakMap();\n  function remoteAttributes(node) {\n    let attributes = REMOTE_ATTRIBUTES.get(node);\n    if (attributes != null) return attributes;\n    if (!(node instanceof Element) || node.tagName.includes(\"-\")) return void 0;\n    attributes = {};\n    for (const {\n      name,\n      value\n    } of node.attributes) {\n      attributes[name] = value;\n    }\n    return attributes;\n  }\n  var REMOTE_EVENT_LISTENERS = /* @__PURE__ */ new WeakMap();\n  function remoteEventListeners(node) {\n    return REMOTE_EVENT_LISTENERS.get(node);\n  }\n  function updateRemoteElementProperty(node, property, value) {\n    let properties = REMOTE_PROPERTIES.get(node);\n    if (properties == null) {\n      properties = {};\n      REMOTE_PROPERTIES.set(node, properties);\n    }\n    if (properties[property] === value) return;\n    properties[property] = value;\n    const connection = REMOTE_CONNECTIONS.get(node);\n    if (connection == null) return;\n    connection.mutate([[MUTATION_TYPE_UPDATE_PROPERTY, remoteId(node), property, value, UPDATE_PROPERTY_TYPE_PROPERTY]]);\n  }\n  function updateRemoteElementAttribute(node, attribute, value) {\n    let attributes = REMOTE_ATTRIBUTES.get(node);\n    if (attributes == null) {\n      attributes = {};\n      REMOTE_ATTRIBUTES.set(node, attributes);\n    }\n    if (attributes[attribute] === value) return;\n    if (value == null) {\n      delete attributes[attribute];\n    } else {\n      attributes[attribute] = String(value);\n    }\n    const connection = REMOTE_CONNECTIONS.get(node);\n    if (connection == null) return;\n    connection.mutate([[MUTATION_TYPE_UPDATE_PROPERTY, remoteId(node), attribute, value, UPDATE_PROPERTY_TYPE_ATTRIBUTE]]);\n  }\n  function updateRemoteElementEventListener(node, event, listener) {\n    let eventListeners = REMOTE_EVENT_LISTENERS.get(node);\n    if (eventListeners == null) {\n      eventListeners = {};\n      REMOTE_EVENT_LISTENERS.set(node, eventListeners);\n    }\n    if (eventListeners[event] === listener) return;\n    if (listener == null) {\n      delete eventListeners[event];\n    } else {\n      eventListeners[event] = listener;\n    }\n    const connection = REMOTE_CONNECTIONS.get(node);\n    if (connection == null) return;\n    connection.mutate([[MUTATION_TYPE_UPDATE_PROPERTY, remoteId(node), event, listener, UPDATE_PROPERTY_TYPE_EVENT_LISTENER]]);\n  }\n  function connectRemoteNode(node, connection) {\n    const existingConnection = REMOTE_CONNECTIONS.get(node);\n    if (existingConnection === connection) return;\n    REMOTE_CONNECTIONS.set(node, connection);\n    if (node.childNodes) {\n      for (let i = 0; i < node.childNodes.length; i++) {\n        connectRemoteNode(node.childNodes[i], connection);\n      }\n    }\n  }\n  function disconnectRemoteNode(node) {\n    const existingConnection = REMOTE_CONNECTIONS.get(node);\n    if (existingConnection == null) return;\n    REMOTE_CONNECTIONS.delete(node);\n    if (node.childNodes) {\n      for (let i = 0; i < node.childNodes.length; i++) {\n        disconnectRemoteNode(node.childNodes[i]);\n      }\n    }\n  }\n  function serializeRemoteNode(node) {\n    const {\n      nodeType\n    } = node;\n    switch (nodeType) {\n      // Element\n      case 1: {\n        return {\n          id: remoteId(node),\n          type: nodeType,\n          element: node.localName,\n          properties: cloneMaybeObject(remoteProperties(node)),\n          attributes: cloneMaybeObject(remoteAttributes(node)),\n          eventListeners: cloneMaybeObject(remoteEventListeners(node)),\n          children: Array.from(node.childNodes).map(serializeRemoteNode)\n        };\n      }\n      // TextNode\n      case 3:\n      // Comment\n      // eslint-disable-next-line no-fallthrough\n      case 8: {\n        return {\n          id: remoteId(node),\n          type: nodeType,\n          data: node.data\n        };\n      }\n      default: {\n        throw new Error(\\`Cannot serialize node of type \\${node.nodeType} (\\${typeof node.nodeType})\\`);\n      }\n    }\n  }\n  function cloneMaybeObject(maybeObject) {\n    return maybeObject ? {\n      ...maybeObject\n    } : void 0;\n  }\n  function callRemoteElementMethod(node, method, ...args) {\n    const id2 = REMOTE_IDS.get(node);\n    const connection = REMOTE_CONNECTIONS.get(node);\n    if (id2 == null || connection == null) {\n      throw new Error(\\`Cannot call method \\${method} on an unconnected node\\`);\n    }\n    return connection.call(id2, method, ...args);\n  }\n\n  // ../../../node_modules/.pnpm/@remote-dom+core@1.8.1_@preact+signals-core@1.10.0/node_modules/@remote-dom/core/build/esm/elements/RemoteElement.mjs\n  var EMPTY_DEFINITION = Object.freeze({});\n  var RemoteElement = class extends HTMLElement {\n    static get observedAttributes() {\n      return this.finalize().__observedAttributes;\n    }\n    /**\n     * The resolved property definitions for this remote element.\n     */\n    static get remotePropertyDefinitions() {\n      return this.finalize().__remotePropertyDefinitions;\n    }\n    /**\n     * The resolved attribute definitions for this remote element.\n     */\n    static get remoteAttributeDefinitions() {\n      return this.finalize().__remoteAttributeDefinitions;\n    }\n    /**\n     * The resolved event listener definitions for this remote element.\n     */\n    static get remoteEventDefinitions() {\n      return this.finalize().__remoteEventDefinitions;\n    }\n    /**\n     * The resolved slot definitions for this remote element.\n     */\n    static get remoteSlotDefinitions() {\n      return this.finalize().__remoteSlotDefinitions;\n    }\n    /**\n     * Creates a new definition for a property that will be synchronized between\n     * this remote element and its host representation.\n     */\n    static createProperty(name, definition) {\n      saveRemoteProperty(name, definition, this.observedAttributes, this.remotePropertyDefinitions, this.__attributeToPropertyMap, this.__eventToPropertyMap);\n    }\n    /**\n     * Consumes all the static members defined on the class and converts them\n     * into the internal representation used to handle properties, attributes,\n     * and event listeners.\n     */\n    static finalize() {\n      if (this.hasOwnProperty(\"__finalized\")) {\n        return this;\n      }\n      this.__finalized = true;\n      const {\n        slottable,\n        remoteSlots,\n        remoteProperties: remoteProperties2,\n        remoteAttributes: remoteAttributes2,\n        remoteEvents,\n        remoteMethods\n      } = this;\n      const SuperConstructor = Object.getPrototypeOf(this);\n      const observedAttributes = /* @__PURE__ */ new Set();\n      if (slottable) observedAttributes.add(\"slot\");\n      const attributeToPropertyMap = /* @__PURE__ */ new Map();\n      const eventToPropertyMap = /* @__PURE__ */ new Map();\n      const remoteSlotDefinitions = /* @__PURE__ */ new Map();\n      const remotePropertyDefinitions = /* @__PURE__ */ new Map();\n      const remoteAttributeDefinitions = /* @__PURE__ */ new Map();\n      const remoteEventDefinitions = /* @__PURE__ */ new Map();\n      if (typeof SuperConstructor.finalize === \"function\") {\n        SuperConstructor.finalize();\n        SuperConstructor.observedAttributes.forEach((attribute) => {\n          observedAttributes.add(attribute);\n        });\n        SuperConstructor.remotePropertyDefinitions.forEach((definition, property) => {\n          remotePropertyDefinitions.set(property, definition);\n        });\n        SuperConstructor.remoteAttributeDefinitions.forEach((definition, event) => {\n          remoteAttributeDefinitions.set(event, definition);\n        });\n        SuperConstructor.remoteEventDefinitions.forEach((definition, event) => {\n          remoteEventDefinitions.set(event, definition);\n        });\n        SuperConstructor.remoteSlotDefinitions.forEach((definition, slot) => {\n          remoteSlotDefinitions.set(slot, definition);\n        });\n      }\n      if (remoteSlots != null) {\n        const slotNames = Array.isArray(remoteSlots) ? remoteSlots : Object.keys(remoteSlots);\n        slotNames.forEach((slotName) => {\n          remoteSlotDefinitions.set(slotName, EMPTY_DEFINITION);\n        });\n      }\n      if (remoteProperties2 != null) {\n        if (Array.isArray(remoteProperties2)) {\n          remoteProperties2.forEach((propertyName) => {\n            saveRemoteProperty(propertyName, void 0, observedAttributes, remotePropertyDefinitions, attributeToPropertyMap, eventToPropertyMap);\n          });\n        } else {\n          Object.keys(remoteProperties2).forEach((propertyName) => {\n            saveRemoteProperty(propertyName, remoteProperties2[propertyName], observedAttributes, remotePropertyDefinitions, attributeToPropertyMap, eventToPropertyMap);\n          });\n        }\n      }\n      if (remoteAttributes2 != null) {\n        remoteAttributes2.forEach((attribute) => {\n          remoteAttributeDefinitions.set(attribute, EMPTY_DEFINITION);\n          observedAttributes.add(attribute);\n        });\n      }\n      if (remoteEvents != null) {\n        if (Array.isArray(remoteEvents)) {\n          remoteEvents.forEach((event) => {\n            remoteEventDefinitions.set(event, EMPTY_DEFINITION);\n          });\n        } else {\n          Object.keys(remoteEvents).forEach((event) => {\n            remoteEventDefinitions.set(event, remoteEvents[event]);\n          });\n        }\n      }\n      if (remoteMethods != null) {\n        if (Array.isArray(remoteMethods)) {\n          for (const method of remoteMethods) {\n            this.prototype[method] = function(...args) {\n              return this.callRemoteMethod(method, ...args);\n            };\n          }\n        } else {\n          Object.assign(this, remoteMethods);\n        }\n      }\n      Object.defineProperties(this, {\n        __observedAttributes: {\n          value: [...observedAttributes],\n          enumerable: false\n        },\n        __remoteSlotDefinitions: {\n          value: remoteSlotDefinitions,\n          enumerable: false\n        },\n        __remotePropertyDefinitions: {\n          value: remotePropertyDefinitions,\n          enumerable: false\n        },\n        __remoteAttributeDefinitions: {\n          value: remoteAttributeDefinitions,\n          enumerable: false\n        },\n        __remoteEventDefinitions: {\n          value: remoteEventDefinitions,\n          enumerable: false\n        },\n        __attributeToPropertyMap: {\n          value: attributeToPropertyMap,\n          enumerable: false\n        },\n        __eventToPropertyMap: {\n          value: eventToPropertyMap,\n          enumerable: false\n        }\n      });\n      return this;\n    }\n    // Just need to use these types so TS doesn’t lose track of them.\n    /** @internal */\n    /** @internal */\n    /** @internal */\n    /** @internal */\n    constructor() {\n      super();\n      this.constructor.finalize();\n      const propertyDescriptors = {};\n      const initialPropertiesToSet = {};\n      const prototype = Object.getPrototypeOf(this);\n      const ThisClass = this.constructor;\n      for (const [property, description] of ThisClass.remotePropertyDefinitions.entries()) {\n        const aliasedName = description.name;\n        if (prototype.hasOwnProperty(property)) {\n          continue;\n        }\n        if (property === aliasedName) {\n          initialPropertiesToSet[property] = description.default;\n        }\n        const propertyDescriptor = {\n          configurable: true,\n          enumerable: property === aliasedName,\n          get: () => {\n            return remoteProperties(this)?.[aliasedName];\n          },\n          set: (value) => {\n            updateRemoteElementProperty(this, aliasedName, value);\n          }\n        };\n        propertyDescriptors[property] = propertyDescriptor;\n      }\n      for (const [event, definition] of ThisClass.remoteEventDefinitions.entries()) {\n        const propertyFromDefinition = definition.property ?? true;\n        if (!propertyFromDefinition) continue;\n        const property = propertyFromDefinition === true ? \\`on\\${event}\\` : propertyFromDefinition;\n        propertyDescriptors[property] = {\n          configurable: true,\n          enumerable: true,\n          get: () => {\n            return getRemoteEvents(this).properties.get(property) ?? null;\n          },\n          set: (value) => {\n            const remoteEvents = getRemoteEvents(this);\n            const currentListener = remoteEvents.properties.get(property);\n            if (typeof value === \"function\") {\n              let handler = function(...args) {\n                return value.call(this, ...args);\n              };\n              remoteEvents.properties.set(property, handler);\n              this.addEventListener(event, handler);\n            } else {\n              remoteEvents.properties.delete(property);\n            }\n            if (currentListener) {\n              this.removeEventListener(event, currentListener);\n            }\n          }\n        };\n      }\n      Object.defineProperties(this, propertyDescriptors);\n      Object.assign(this, initialPropertiesToSet);\n    }\n    attributeChangedCallback(attribute, _oldValue, newValue) {\n      if (attribute === \"slot\" && this.constructor.slottable) {\n        updateRemoteElementAttribute(this, attribute, newValue ? String(newValue) : void 0);\n        return;\n      }\n      const {\n        remotePropertyDefinitions,\n        remoteAttributeDefinitions,\n        __attributeToPropertyMap: attributeToPropertyMap\n      } = this.constructor;\n      if (remoteAttributeDefinitions.has(attribute)) {\n        updateRemoteElementAttribute(this, attribute, newValue);\n        return;\n      }\n      const property = attributeToPropertyMap.get(attribute);\n      const propertyDefinition = property == null ? property : remotePropertyDefinitions.get(property);\n      if (propertyDefinition == null) return;\n      this[property] = convertAttributeValueToProperty(newValue, propertyDefinition.type);\n    }\n    connectedCallback() {\n      for (const [event, descriptor] of this.constructor.remoteEventDefinitions.entries()) {\n        if (descriptor.bubbles) {\n          this.addEventListener(event, noopBubblesEventListener);\n        }\n      }\n    }\n    disconnectedCallback() {\n      for (const [event, descriptor] of this.constructor.remoteEventDefinitions.entries()) {\n        if (descriptor.bubbles) {\n          this.removeEventListener(event, noopBubblesEventListener);\n        }\n      }\n    }\n    addEventListener(type, listener, options) {\n      const {\n        remoteEventDefinitions,\n        __eventToPropertyMap: eventToPropertyMap\n      } = this.constructor;\n      const listenerDefinition = remoteEventDefinitions.get(type);\n      const property = eventToPropertyMap.get(type);\n      if (listenerDefinition == null && property == null) {\n        return super.addEventListener(type, listener, options);\n      }\n      const remoteEvents = getRemoteEvents(this);\n      const remoteEvent = getRemoteEventRecord.call(this, type, {\n        property,\n        definition: listenerDefinition\n      });\n      const normalizedListener = typeof options === \"object\" && options?.once ? (...args) => {\n        const result = typeof listener === \"object\" ? listener.handleEvent(...args) : listener.call(this, ...args);\n        removeRemoteListener.call(this, type, listener, listenerRecord);\n        return result;\n      } : listener;\n      const listenerRecord = [normalizedListener, remoteEvent];\n      remoteEvent.listeners.add(listener);\n      remoteEvents.listeners.set(listener, listenerRecord);\n      super.addEventListener(type, normalizedListener, options);\n      if (typeof options === \"object\" && options.signal) {\n        options.signal.addEventListener(\"abort\", () => {\n          removeRemoteListener.call(this, type, listener, listenerRecord);\n        }, {\n          once: true\n        });\n      }\n      if (listenerDefinition) {\n        updateRemoteElementEventListener(this, type, remoteEvent.dispatch);\n      } else {\n        updateRemoteElementProperty(this, property, remoteEvent.dispatch);\n      }\n    }\n    removeEventListener(type, listener, options) {\n      const listenerRecord = REMOTE_EVENTS.get(this)?.listeners.get(listener);\n      const normalizedListener = listenerRecord ? listenerRecord[0] : listener;\n      super.removeEventListener(type, normalizedListener, options);\n      if (listenerRecord == null) return;\n      removeRemoteListener.call(this, type, listener, listenerRecord);\n    }\n    /**\n     * Updates a single remote property on an element node. If the element is\n     * connected to a remote root, this function will also make a \\`mutate()\\` call\n     * to communicate the change to the host.\n     */\n    updateRemoteProperty(name, value) {\n      updateRemoteElementProperty(this, name, value);\n    }\n    /**\n     * Updates a single remote attribute on an element node. If the element is\n     * connected to a remote root, this function will also make a \\`mutate()\\` call\n     * to communicate the change to the host.\n     */\n    updateRemoteAttribute(name, value) {\n      updateRemoteElementAttribute(this, name, value);\n    }\n    /**\n     * Performs a method through \\`RemoteConnection.call()\\`, using the remote ID and\n     * connection for the provided node.\n     */\n    callRemoteMethod(method, ...args) {\n      return callRemoteElementMethod(this, method, ...args);\n    }\n  };\n  __publicField(RemoteElement, \"slottable\", true);\n  __publicField(RemoteElement, \"__finalized\", true);\n  __publicField(RemoteElement, \"__observedAttributes\", []);\n  __publicField(RemoteElement, \"__attributeToPropertyMap\", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());\n  __publicField(RemoteElement, \"__eventToPropertyMap\", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());\n  __publicField(RemoteElement, \"__remotePropertyDefinitions\", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());\n  __publicField(RemoteElement, \"__remoteAttributeDefinitions\", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());\n  __publicField(RemoteElement, \"__remoteEventDefinitions\", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());\n  __publicField(RemoteElement, \"__remoteSlotDefinitions\", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());\n  var REMOTE_EVENTS = /* @__PURE__ */ new WeakMap();\n  function getRemoteEvents(element) {\n    let events = REMOTE_EVENTS.get(element);\n    if (events) return events;\n    events = {\n      events: /* @__PURE__ */ new Map(),\n      properties: /* @__PURE__ */ new Map(),\n      listeners: /* @__PURE__ */ new WeakMap()\n    };\n    REMOTE_EVENTS.set(element, events);\n    return events;\n  }\n  function getRemoteEventRecord(type, {\n    property,\n    definition\n  }) {\n    const remoteEvents = getRemoteEvents(this);\n    let remoteEvent = remoteEvents.events.get(type);\n    if (remoteEvent == null) {\n      remoteEvent = {\n        name: type,\n        property,\n        definition,\n        listeners: /* @__PURE__ */ new Set(),\n        dispatch: (arg) => {\n          const event = definition?.dispatchEvent?.call(this, arg) ?? new RemoteEvent(type, {\n            detail: arg,\n            bubbles: definition?.bubbles\n          });\n          this.dispatchEvent(event);\n          return event.response;\n        }\n      };\n      remoteEvents.events.set(type, remoteEvent);\n    }\n    return remoteEvent;\n  }\n  function removeRemoteListener(type, listener, listenerRecord) {\n    const remoteEvents = getRemoteEvents(this);\n    const remoteEvent = listenerRecord[1];\n    remoteEvent.listeners.delete(listener);\n    remoteEvents.listeners.delete(listener);\n    if (remoteEvent.listeners.size > 0) return;\n    remoteEvents.events.delete(type);\n    if (remoteEvent.property) {\n      if (remoteProperties(this)?.[remoteEvent.property] === remoteEvent.dispatch) {\n        updateRemoteElementProperty(this, remoteEvent.property, void 0);\n      }\n    } else {\n      if (remoteEventListeners(this)?.[type] === remoteEvent.dispatch) {\n        updateRemoteElementEventListener(this, type, void 0);\n      }\n    }\n  }\n  function saveRemoteProperty(name, description, observedAttributes, remotePropertyDefinitions, attributeToPropertyMap, eventToPropertyMap) {\n    if (remotePropertyDefinitions.has(name)) {\n      return remotePropertyDefinitions.get(name);\n    }\n    const looksLikeEventCallback = name[0] === \"o\" && name[1] === \"n\";\n    const resolvedDescription = description ?? {};\n    let {\n      alias\n    } = resolvedDescription;\n    const {\n      type = looksLikeEventCallback ? Function : String,\n      attribute = type !== Function,\n      event = looksLikeEventCallback,\n      default: defaultValue = type === Boolean ? false : void 0\n    } = resolvedDescription;\n    if (alias == null) {\n      const lowercaseProperty = name.toLowerCase();\n      if (lowercaseProperty !== name) {\n        alias = [lowercaseProperty];\n      }\n      if (looksLikeEventCallback) {\n        alias ?? (alias = []);\n        alias.unshift(\\`_\\${name}\\`);\n      }\n    }\n    let attributeName;\n    if (attribute === true) {\n      attributeName = camelToKebabCase(name);\n    } else if (typeof attribute === \"string\") {\n      attributeName = attribute;\n    }\n    if (attributeName) {\n      if (Array.isArray(observedAttributes)) {\n        observedAttributes.push(attributeName);\n      } else {\n        observedAttributes.add(attributeName);\n      }\n      attributeToPropertyMap.set(attributeName, name);\n    }\n    let eventName;\n    if (event === true) {\n      eventName = camelToKebabCase(looksLikeEventCallback ? name.slice(2) : name);\n    } else if (typeof event === \"string\") {\n      eventName = event;\n    }\n    if (eventName) {\n      eventToPropertyMap.set(eventName, name);\n    }\n    const definition = {\n      name,\n      type,\n      alias,\n      event: eventName,\n      attribute: attributeName,\n      default: defaultValue\n    };\n    remotePropertyDefinitions.set(name, definition);\n    if (alias) {\n      for (const propertyAlias of alias) {\n        remotePropertyDefinitions.set(propertyAlias, definition);\n      }\n    }\n    return definition;\n  }\n  function convertAttributeValueToProperty(value, type) {\n    if (value == null) return void 0;\n    switch (type) {\n      case Boolean:\n        return value != null && value !== \"false\";\n      case Object:\n      case Array:\n        try {\n          return JSON.parse(value);\n        } catch {\n          return void 0;\n        }\n      case String:\n        return String(value);\n      case Number:\n        return Number.parseFloat(value);\n      case Function:\n        return void 0;\n      default: {\n        return type.parse?.(value);\n      }\n    }\n  }\n  function camelToKebabCase(str) {\n    return str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n  }\n  function noopBubblesEventListener() {\n  }\n\n  // ../../../node_modules/.pnpm/@remote-dom+core@1.8.1_@preact+signals-core@1.10.0/node_modules/@remote-dom/core/build/esm/elements/RemoteMutationObserver.mjs\n  var RemoteMutationObserver = class extends MutationObserver {\n    constructor(connection) {\n      super((records) => {\n        const addedNodes = [];\n        const remoteRecords = [];\n        for (const record of records) {\n          const targetId = remoteId(record.target);\n          if (record.type === \"childList\") {\n            const position = record.previousSibling ? indexOf(record.previousSibling, record.target.childNodes) + 1 : 0;\n            record.removedNodes.forEach((node) => {\n              disconnectRemoteNode(node);\n              remoteRecords.push([MUTATION_TYPE_REMOVE_CHILD, targetId, position]);\n            });\n            record.addedNodes.forEach((node, index) => {\n              if (addedNodes.some((addedNode) => {\n                return addedNode === node || addedNode.contains(node);\n              })) {\n                return;\n              }\n              addedNodes.push(node);\n              connectRemoteNode(node, connection);\n              remoteRecords.push([MUTATION_TYPE_INSERT_CHILD, targetId, serializeRemoteNode(node), position + index]);\n            });\n          } else if (record.type === \"characterData\") {\n            remoteRecords.push([MUTATION_TYPE_UPDATE_TEXT, targetId, record.target.textContent ?? \"\"]);\n          } else if (record.type === \"attributes\" && record.attributeName != null && record.target instanceof Element && !record.target.tagName.includes(\"-\")) {\n            remoteRecords.push([MUTATION_TYPE_UPDATE_PROPERTY, targetId, record.attributeName, record.target.getAttribute(record.attributeName)]);\n          }\n        }\n        connection.mutate(remoteRecords);\n      });\n      this.connection = connection;\n    }\n    /**\n     * Starts watching changes to the element, and communicates changes to the\n     * host environment. By default, this method will also communicate any initial\n     * children of the element to the host environment.\n     */\n    observe(target, options) {\n      REMOTE_IDS.set(target, ROOT_ID);\n      if (options?.initial !== false && target.childNodes.length > 0) {\n        const records = [];\n        for (let i = 0; i < target.childNodes.length; i++) {\n          const node = target.childNodes[i];\n          connectRemoteNode(node, this.connection);\n          records.push([MUTATION_TYPE_INSERT_CHILD, ROOT_ID, serializeRemoteNode(node), i]);\n        }\n        this.connection.mutate(records);\n      }\n      super.observe(target, {\n        subtree: true,\n        childList: true,\n        attributes: true,\n        characterData: true,\n        ...options\n      });\n    }\n  };\n  function indexOf(node, list) {\n    for (let i = 0; i < list.length; i++) {\n      if (list[i] === node) return i;\n    }\n    return -1;\n  }\n\n  // ../../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/constants.mjs\n  var MESSAGE_CALL = 1;\n  var MESSAGE_CALL_RESULT = 2;\n  var MESSAGE_FUNCTION_CALL = 3;\n  var MESSAGE_FUNCTION_RESULT = 4;\n  var MESSAGE_FUNCTION_RELEASE = 5;\n  var SERIALIZE_METHOD = Symbol.for(\"quilt.threads.serialize\");\n  var TRANSFERABLE = Symbol.for(\"quilt.threads.transferable\");\n\n  // ../../../node_modules/.pnpm/@quilted+events@2.1.3/node_modules/@quilted/events/build/esm/abort/NestedAbortController.mjs\n  var NestedAbortController = class extends AbortController {\n    constructor(...parents) {\n      super();\n      const abortedSignal = parents.find((signal) => signal.aborted);\n      if (abortedSignal) {\n        this.abort(abortedSignal.reason);\n      } else {\n        const abort = (event) => this.abort(event.target.reason);\n        const options = {\n          signal: this.signal\n        };\n        for (const signal of parents) {\n          signal.addEventListener(\"abort\", abort, options);\n        }\n      }\n    }\n  };\n\n  // ../../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/errors.mjs\n  var ThreadClosedError = class extends Error {\n    constructor() {\n      super(\"You attempted to call a function on a closed thread.\");\n    }\n  };\n\n  // ../../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/nanoid.mjs\n  var a = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\n  function nanoid(e = 21) {\n    let t = \"\", r = crypto.getRandomValues(new Uint8Array(e));\n    for (let n = 0; n < e; n++) t += a[63 & r[n]];\n    return t;\n  }\n\n  // ../../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/functions/ThreadFunctionsAutomatic.mjs\n  var _functionsToId, _idsToFunction, _idsToProxy, _finalization, _ThreadFunctionsAutomatic_instances, finalizationRegistry_fn;\n  var ThreadFunctionsAutomatic = class {\n    constructor() {\n      __privateAdd(this, _ThreadFunctionsAutomatic_instances);\n      __privateAdd(this, _functionsToId, /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());\n      __privateAdd(this, _idsToFunction, /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());\n      __privateAdd(this, _idsToProxy, /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());\n      __privateAdd(this, _finalization, /* @__PURE__ */ (() => /* @__PURE__ */ new WeakMap())());\n    }\n    get(id2) {\n      return __privateGet(this, _idsToFunction).get(id2);\n    }\n    release(id2) {\n      const func = __privateGet(this, _idsToFunction).get(id2);\n      if (func) {\n        __privateGet(this, _idsToFunction).delete(id2);\n        __privateGet(this, _functionsToId).delete(func);\n      }\n      return Boolean(func);\n    }\n    serialize(func) {\n      let id2 = __privateGet(this, _functionsToId).get(func);\n      if (id2 == null) {\n        id2 = nanoid();\n        __privateGet(this, _functionsToId).set(func, id2);\n        __privateGet(this, _idsToFunction).set(id2, func);\n      }\n      return id2;\n    }\n    deserialize(id2, thread) {\n      let proxy = __privateGet(this, _idsToProxy).get(id2)?.deref();\n      if (proxy) return proxy;\n      proxy = (...args) => {\n        if (!__privateGet(this, _idsToProxy).has(id2)) {\n          throw new Error(\"You attempted to call a function that was already revoked.\");\n        }\n        return thread.call((callID, args2, transferable) => {\n          thread.messages.send([MESSAGE_FUNCTION_CALL, callID, id2, args2], transferable);\n        }, args);\n      };\n      __privateMethod(this, _ThreadFunctionsAutomatic_instances, finalizationRegistry_fn).call(this, thread)?.register(proxy, id2);\n      __privateGet(this, _idsToProxy).set(id2, new WeakRef(proxy));\n      return proxy;\n    }\n  };\n  _functionsToId = new WeakMap();\n  _idsToFunction = new WeakMap();\n  _idsToProxy = new WeakMap();\n  _finalization = new WeakMap();\n  _ThreadFunctionsAutomatic_instances = new WeakSet();\n  finalizationRegistry_fn = function(thread) {\n    let finalization = __privateGet(this, _finalization).get(thread);\n    if (typeof FinalizationRegistry === \"undefined\") {\n      return void 0;\n    }\n    if (!finalization) {\n      finalization = new FinalizationRegistry((id2) => {\n        thread.messages.send([MESSAGE_FUNCTION_RELEASE, id2]);\n      });\n      __privateGet(this, _finalization).set(thread, finalization);\n    }\n    return finalization;\n  };\n\n  // ../../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/serialization/shared.mjs\n  function isIterator(value) {\n    return value != null && (Symbol.asyncIterator in value || Symbol.iterator in value) && typeof value.next === \"function\";\n  }\n  function isBasicObject(value) {\n    if (value == null || typeof value !== \"object\") return false;\n    const prototype = Object.getPrototypeOf(value);\n    return prototype == null || prototype === Object.prototype;\n  }\n\n  // ../../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/serialization/ThreadSerializationStructuredClone.mjs\n  var FUNCTION = \"_@f\";\n  var ASYNC_ITERATOR = \"_@i\";\n  var _customSerializer, _customDeserializer, _ThreadSerializationStructuredClone_instances, serializeInternal_fn, deserializeInternal_fn;\n  var ThreadSerializationStructuredClone = class {\n    constructor(options) {\n      __privateAdd(this, _ThreadSerializationStructuredClone_instances);\n      __privateAdd(this, _customSerializer);\n      __privateAdd(this, _customDeserializer);\n      __privateSet(this, _customSerializer, options?.serialize);\n      __privateSet(this, _customDeserializer, options?.deserialize);\n    }\n    /**\n     * Serializes a value into a structured cloning-compatible format that can be transferred between threads.\n     */\n    serialize(value, thread, transferable) {\n      return __privateMethod(this, _ThreadSerializationStructuredClone_instances, serializeInternal_fn).call(this, value, thread, transferable);\n    }\n    /**\n     * Deserializes a structured cloning-compatible value from another thread.\n     */\n    deserialize(value, thread) {\n      return __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, value, thread);\n    }\n  };\n  _customSerializer = new WeakMap();\n  _customDeserializer = new WeakMap();\n  _ThreadSerializationStructuredClone_instances = new WeakSet();\n  serializeInternal_fn = function(value, thread, transferable, seen = /* @__PURE__ */ new Map(), isApplyingDefault = false) {\n    if (value == null) return value;\n    if (seen.has(value)) return seen.get(value);\n    seen.set(value, void 0);\n    if (typeof value === \"object\") {\n      if (__privateGet(this, _customSerializer) && !isApplyingDefault) {\n        const customValue = __privateGet(this, _customSerializer).call(this, value, (value2) => __privateMethod(this, _ThreadSerializationStructuredClone_instances, serializeInternal_fn).call(this, value2, thread, transferable, seen, true), thread, transferable);\n        if (customValue !== void 0) {\n          seen.set(value, customValue);\n          return customValue;\n        }\n      }\n      if (value[TRANSFERABLE]) {\n        transferable?.push(value);\n        seen.set(value, value);\n        return value;\n      }\n      const serializeValue = (value2) => {\n        return __privateMethod(this, _ThreadSerializationStructuredClone_instances, serializeInternal_fn).call(this, value2, thread, transferable, seen);\n      };\n      if (typeof value[SERIALIZE_METHOD] === \"function\") {\n        const result = value[SERIALIZE_METHOD]({\n          serialize: serializeValue\n        });\n        seen.set(value, result);\n        return result;\n      }\n      if (Array.isArray(value)) {\n        const result = value.map((item) => serializeValue(item));\n        seen.set(value, result);\n        return result;\n      }\n      if (value instanceof Map) {\n        const entries = [...value.entries()].map(([key, value2]) => {\n          return [serializeValue(key), serializeValue(value2)];\n        });\n        const result = new Map(entries);\n        seen.set(value, result);\n        return result;\n      }\n      if (value instanceof Set) {\n        const entries = [...value].map((entry) => serializeValue(entry));\n        const result = new Set(entries);\n        seen.set(value, result);\n        return result;\n      }\n      const valueIsIterator = isIterator(value);\n      if (isBasicObject(value) || valueIsIterator) {\n        const result = {};\n        for (const key of Object.keys(value)) {\n          result[key] = serializeValue(value[key]);\n        }\n        if (valueIsIterator) {\n          result.next ?? (result.next = serializeValue(value.next.bind(value)));\n          result.return ?? (result.return = serializeValue(value.return.bind(value)));\n          result.throw ?? (result.throw = serializeValue(value.throw.bind(value)));\n          result[ASYNC_ITERATOR] = true;\n        }\n        seen.set(value, result);\n        return result;\n      }\n    }\n    if (typeof value === \"function\") {\n      const serialized = thread.functions.serialize(value, thread, transferable);\n      const result = {\n        [FUNCTION]: serialized\n      };\n      seen.set(value, result);\n      return result;\n    }\n    seen.set(value, value);\n    return value;\n  };\n  deserializeInternal_fn = function(value, thread, isApplyingDefault = false) {\n    if (value == null) return value;\n    if (typeof value === \"object\") {\n      if (__privateGet(this, _customDeserializer) && !isApplyingDefault) {\n        const customValue = __privateGet(this, _customDeserializer).call(this, value, (value2) => __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, value2, thread, true), thread);\n        if (customValue !== void 0) {\n          return customValue;\n        }\n      }\n      if (value == null) {\n        return value;\n      }\n      if (Array.isArray(value)) {\n        return value.map((value2) => __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, value2, thread));\n      }\n      if (value instanceof Map) {\n        return new Map([...value].map(([key, value2]) => [__privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, key, thread), __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, value2, thread)]));\n      }\n      if (value instanceof Set) {\n        return new Set([...value].map((entry) => __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, entry, thread)));\n      }\n      if (FUNCTION in value) {\n        const func = thread.functions.deserialize(value[FUNCTION], thread);\n        return func;\n      }\n      if (!isBasicObject(value)) {\n        return value;\n      }\n      const result = {};\n      for (const key of Object.keys(value)) {\n        if (key === ASYNC_ITERATOR) {\n          result[Symbol.asyncIterator] = () => result;\n        } else {\n          result[key] = __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, value[key], thread);\n        }\n      }\n      return result;\n    }\n    return value;\n  };\n\n  // ../../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/Thread.mjs\n  var _abort, _idsToResolver, _Thread_instances, callLocal_fn, handlerForCall_fn, resolveCall_fn, waitForResult_fn;\n  var Thread = class {\n    constructor(messages, {\n      imports,\n      exports,\n      functions = new ThreadFunctionsAutomatic(),\n      serialization = new ThreadSerializationStructuredClone(),\n      signal\n    } = {}) {\n      __privateAdd(this, _Thread_instances);\n      __privateAdd(this, _abort);\n      __privateAdd(this, _idsToResolver, /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());\n      this.messages = messages;\n      __privateSet(this, _abort, signal ? new NestedAbortController(signal) : new AbortController());\n      this.exports = exports ?? {};\n      this.imports = createThreadImports(__privateMethod(this, _Thread_instances, handlerForCall_fn).bind(this), imports);\n      this.functions = functions;\n      this.serialization = serialization;\n      this.functions.start?.(this);\n      this.serialization.start?.(this);\n      this.signal.addEventListener(\"abort\", () => {\n        for (const id2 of __privateGet(this, _idsToResolver).keys()) {\n          __privateMethod(this, _Thread_instances, resolveCall_fn).call(this, id2, void 0, new ThreadClosedError());\n        }\n        __privateGet(this, _idsToResolver).clear();\n      }, {\n        once: true\n      });\n      messages.listen(async (rawData) => {\n        const isThreadMessageData = Array.isArray(rawData) && typeof rawData[0] === \"number\";\n        if (!isThreadMessageData) {\n          return;\n        }\n        const data = rawData;\n        switch (data[0]) {\n          case MESSAGE_CALL: {\n            const [, id2, property, args] = data;\n            const func = this.exports[property] ?? (() => {\n              throw new Error(\\`No '\\${property}' method is exported from this thread\\`);\n            });\n            await __privateMethod(this, _Thread_instances, callLocal_fn).call(this, func, args, (value, error, transferable) => {\n              this.messages.send([MESSAGE_CALL_RESULT, id2, value, error], transferable);\n            });\n            break;\n          }\n          case MESSAGE_FUNCTION_CALL: {\n            const [, callID, funcID, args] = data;\n            const func = this.functions.get(funcID, this) ?? missingThreadFunction;\n            await __privateMethod(this, _Thread_instances, callLocal_fn).call(this, func, args, (value, error, transferable) => {\n              this.messages.send([MESSAGE_FUNCTION_RESULT, callID, value, error], transferable);\n            });\n            break;\n          }\n          case MESSAGE_CALL_RESULT:\n          case MESSAGE_FUNCTION_RESULT: {\n            __privateMethod(this, _Thread_instances, resolveCall_fn).call(this, ...data.slice(1));\n            break;\n          }\n          case MESSAGE_FUNCTION_RELEASE: {\n            const id2 = data[1];\n            this.functions.release(id2, this);\n            break;\n          }\n        }\n      }, {\n        signal: this.signal\n      });\n    }\n    /**\n     * An object that exposes the methods that can be called on the paired thread.\n     * This object will automatically encode and decode arguments and return values\n     * as necessary.\n     */\n    /**\n     * An object that exposes the methods that can be called on this thread by the\n     * paired thread. To set these methods, pass the \\`exports\\` option when creating\n     * a new \\`Thread\\`.\n     */\n    /**\n     * An object that provides the message-passing interface that allows communication\n     * to flow between environments.\n     */\n    /**\n     * An object that manages how functions are proxied between threads.\n     */\n    /**\n     * An object that manages how values are serialized and deserialized between threads.\n     */\n    /**\n     * An \\`AbortSignal\\` that indicates whether the communication channel is still open.\n     */\n    get signal() {\n      return __privateGet(this, _abort).signal;\n    }\n    /**\n     * A boolean indicating whether the communication channel is still open.\n     */\n    get closed() {\n      return __privateGet(this, _abort).signal.aborted;\n    }\n    /**\n     * Closes the communication channel between the two threads. This will prevent\n     * any further communication between the threads, and will clean up any memory\n     * associated with in-progress communication. It will also reject any inflight\n     * function calls between threads with a \\`ThreadClosedError\\`.\n     */\n    close() {\n      __privateGet(this, _abort).abort();\n    }\n    /**\n     * Requests that the thread provide the context needed to make a function\n     * call between threads. You provide this method a function to call and the\n     * unserialized arguments you wish to call it with, and the thread will call\n     * the function you provided with a serialized call ID, the serialized arguments,\n     * and any transferable objects that need to be passed between threads.\n     */\n    call(func, args) {\n      if (this.closed) {\n        return Promise.reject(new ThreadClosedError());\n      }\n      const transferable = [];\n      const serialized = this.serialization.serialize(args, this, transferable);\n      const id2 = nanoid();\n      const done = __privateMethod(this, _Thread_instances, waitForResult_fn).call(this, id2);\n      func(id2, serialized, transferable);\n      return done;\n    }\n  };\n  _abort = new WeakMap();\n  _idsToResolver = new WeakMap();\n  _Thread_instances = new WeakSet();\n  callLocal_fn = async function(func, args, withResult) {\n    try {\n      const result = this.functions.call ? await this.functions.call(func, args, this) : await func(...this.serialization.deserialize(args, this));\n      const transferable = [];\n      const serialized = this.serialization.serialize(result, this, transferable);\n      withResult(serialized, void 0, transferable);\n    } catch (error) {\n      withResult(void 0, this.serialization.serialize(error, this));\n    }\n  };\n  handlerForCall_fn = function(property) {\n    return (...args) => {\n      try {\n        if (typeof property !== \"string\" && typeof property !== \"number\") {\n          throw new Error(\\`Can’t call a symbol method on a thread: \\${property.toString()}\\`);\n        }\n        return this.call((id2, serializedArgs, transferable) => {\n          this.messages.send([MESSAGE_CALL, id2, property, serializedArgs], transferable);\n        }, args);\n      } catch (error) {\n        return Promise.reject(error);\n      }\n    };\n  };\n  resolveCall_fn = function(...args) {\n    const callID = args[0];\n    const resolver = __privateGet(this, _idsToResolver).get(callID);\n    if (resolver) {\n      resolver(...args);\n      __privateGet(this, _idsToResolver).delete(callID);\n    }\n  };\n  waitForResult_fn = function(id2) {\n    const promise = new Promise((resolve, reject) => {\n      __privateGet(this, _idsToResolver).set(id2, (_, value, error) => {\n        if (error == null) {\n          resolve(this.serialization.deserialize(value, this));\n        } else {\n          reject(this.serialization.deserialize(error, this));\n        }\n      });\n    });\n    Object.defineProperty(promise, Symbol.asyncIterator, {\n      async *value() {\n        const result = await promise;\n        Object.defineProperty(result, Symbol.asyncIterator, {\n          value: () => result\n        });\n        yield* result;\n      }\n    });\n    return promise;\n  };\n  function createThreadImports(handlerForImport, imported) {\n    let call;\n    if (imported == null) {\n      if (typeof Proxy !== \"function\") {\n        throw new Error(\\`You must pass an array of callable methods in environments without Proxies.\\`);\n      }\n      const cache = /* @__PURE__ */ new Map();\n      call = new Proxy({}, {\n        get(_target, property) {\n          if (cache.has(property)) {\n            return cache.get(property);\n          }\n          const handler = handlerForImport(property);\n          cache.set(property, handler);\n          return handler;\n        }\n      });\n    } else {\n      call = {};\n      for (const method of imported) {\n        Object.defineProperty(call, method, {\n          value: handlerForImport(method),\n          writable: false,\n          configurable: true,\n          enumerable: true\n        });\n      }\n    }\n    return call;\n  }\n  function missingThreadFunction() {\n    throw new Error(\\`You attempted to call a function that is not stored. It may have already been released.\\`);\n  }\n\n  // ../../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/threads/window/shared.mjs\n  var CHECK_MESSAGE = \"quilt.threads.ping\";\n  var RESPONSE_MESSAGE = \"quilt.threads.pong\";\n\n  // ../../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/threads/window/ThreadNestedWindow.mjs\n  function nestedWindowToThreadTarget(parent, {\n    targetOrigin = \"*\"\n  } = {}) {\n    const ready = () => {\n      const respond = () => parent.postMessage(RESPONSE_MESSAGE, targetOrigin);\n      self.addEventListener(\"message\", ({\n        data,\n        source\n      }) => {\n        if (source !== parent) return;\n        if (data === CHECK_MESSAGE) respond();\n      });\n      respond();\n    };\n    if (document.readyState === \"complete\") {\n      ready();\n    } else {\n      document.addEventListener(\"readystatechange\", () => {\n        if (document.readyState === \"complete\") {\n          ready();\n        }\n      });\n    }\n    return {\n      send(message, transfer) {\n        return parent.postMessage(message, targetOrigin, transfer);\n      },\n      listen(listen, {\n        signal\n      }) {\n        self.addEventListener(\"message\", (event) => {\n          if (event.data === CHECK_MESSAGE) return;\n          listen(event.data);\n        }, {\n          signal\n        });\n      }\n    };\n  }\n\n  // ../../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/threads/ThreadNestedIframe.mjs\n  var ThreadNestedIframe = class extends Thread {\n    constructor({\n      parent = globalThis.parent,\n      targetOrigin = \"*\",\n      ...options\n    } = {}) {\n      if (typeof self === \"undefined\" || parent == null) {\n        throw new Error(\"You are not inside an iframe, because there is no parent window.\");\n      }\n      super(nestedWindowToThreadTarget(parent, {\n        targetOrigin\n      }), options);\n      this.parent = parent;\n    }\n  };\n\n  // scripts/iframe-entry.js\n  new ThreadNestedIframe({\n    exports: {\n      async render(options, receiver, hostApi) {\n        if (options.remoteElements) {\n          options.remoteElements.forEach((def) => {\n            if (customElements.get(def.tagName)) return;\n            const remoteElement = class extends RemoteElement {\n              static get remoteAttributes() {\n                return def.remoteAttributes || [];\n              }\n              static get remoteEvents() {\n                return def.remoteEvents || [];\n              }\n            };\n            Object.defineProperty(remoteElement, \"name\", {\n              value: \\`Remote\\${def.tagName.replace(\n                /(^w|-w)/g,\n                (c) => c.replace(\"-\", \"\").toUpperCase()\n              )}\\`\n            });\n            customElements.define(def.tagName, remoteElement);\n          });\n        }\n        const root = document.querySelector(\"#root\");\n        const observer = new RemoteMutationObserver(receiver);\n        observer.observe(root);\n        const { code } = options;\n        if (code && root) {\n          try {\n            const scriptFunction = new Function(\"root\", \"console\", code);\n            scriptFunction(root, console);\n          } catch (e) {\n            console.error(\"Error executing remote script:\", e);\n          }\n        }\n      }\n    }\n  });\n})();\n\n  <\\/script>\n</body>\n</html>`, ve = 1, ye = 2, Le = 3, Te = 4, Ue = 5, ge = Symbol.for(\"quilt.threads.serialize\"), yt = Symbol.for(\"quilt.threads.transferable\");\nclass Tt extends AbortController {\n  constructor(...e) {\n    super();\n    const t = e.find((n) => n.aborted);\n    if (t)\n      this.abort(t.reason);\n    else {\n      const n = (o) => this.abort(o.target.reason), s = {\n        signal: this.signal\n      };\n      for (const o of e)\n        o.addEventListener(\"abort\", n, s);\n    }\n  }\n}\nclass Re extends Error {\n  constructor() {\n    super(\"You attempted to call a function on a closed thread.\");\n  }\n}\nlet gt = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nfunction ze(r = 21) {\n  let e = \"\", t = crypto.getRandomValues(new Uint8Array(r));\n  for (let n = 0; n < r; n++) e += gt[63 & t[n]];\n  return e;\n}\nvar Y, x, G, K, ee, xe;\nclass Rt {\n  constructor() {\n    S(this, ee);\n    S(this, Y, /* @__PURE__ */ new Map());\n    S(this, x, /* @__PURE__ */ new Map());\n    S(this, G, /* @__PURE__ */ new Map());\n    S(this, K, /* @__PURE__ */ new WeakMap());\n  }\n  get(e) {\n    return b(this, x).get(e);\n  }\n  release(e) {\n    const t = b(this, x).get(e);\n    return t && (b(this, x).delete(e), b(this, Y).delete(t)), !!t;\n  }\n  serialize(e) {\n    let t = b(this, Y).get(e);\n    return t == null && (t = ze(), b(this, Y).set(e, t), b(this, x).set(t, e)), t;\n  }\n  deserialize(e, t) {\n    var s, o;\n    let n = (s = b(this, G).get(e)) == null ? void 0 : s.deref();\n    return n || (n = (...a) => {\n      if (!b(this, G).has(e))\n        throw new Error(\"You attempted to call a function that was already revoked.\");\n      return t.call((u, l, f) => {\n        t.messages.send([Le, u, e, l], f);\n      }, a);\n    }, (o = y(this, ee, xe).call(this, t)) == null || o.register(n, e), b(this, G).set(e, new WeakRef(n)), n);\n  }\n}\nY = new WeakMap(), x = new WeakMap(), G = new WeakMap(), K = new WeakMap(), ee = new WeakSet(), xe = function(e) {\n  let t = b(this, K).get(e);\n  if (!(typeof FinalizationRegistry > \"u\"))\n    return t || (t = new FinalizationRegistry((n) => {\n      e.messages.send([Ue, n]);\n    }), b(this, K).set(e, t)), t;\n};\nfunction wt(r) {\n  return r != null && (Symbol.asyncIterator in r || Symbol.iterator in r) && typeof r.next == \"function\";\n}\nfunction we(r) {\n  if (r == null || typeof r != \"object\") return !1;\n  const e = Object.getPrototypeOf(r);\n  return e == null || e === Object.prototype;\n}\nconst ie = \"_@f\", Se = \"_@i\";\nvar V, W, w, Q, O;\nclass St {\n  constructor(e) {\n    S(this, w);\n    S(this, V);\n    S(this, W);\n    Z(this, V, e == null ? void 0 : e.serialize), Z(this, W, e == null ? void 0 : e.deserialize);\n  }\n  /**\n   * Serializes a value into a structured cloning-compatible format that can be transferred between threads.\n   */\n  serialize(e, t, n) {\n    return y(this, w, Q).call(this, e, t, n);\n  }\n  /**\n   * Deserializes a structured cloning-compatible value from another thread.\n   */\n  deserialize(e, t) {\n    return y(this, w, O).call(this, e, t);\n  }\n}\nV = new WeakMap(), W = new WeakMap(), w = new WeakSet(), Q = function(e, t, n, s = /* @__PURE__ */ new Map(), o = !1) {\n  if (e == null) return e;\n  if (s.has(e)) return s.get(e);\n  if (s.set(e, void 0), typeof e == \"object\") {\n    if (b(this, V) && !o) {\n      const l = b(this, V).call(this, e, (f) => y(this, w, Q).call(this, f, t, n, s, !0), t, n);\n      if (l !== void 0)\n        return s.set(e, l), l;\n    }\n    if (e[yt])\n      return n == null || n.push(e), s.set(e, e), e;\n    const a = (l) => y(this, w, Q).call(this, l, t, n, s);\n    if (typeof e[ge] == \"function\") {\n      const l = e[ge]({\n        serialize: a\n      });\n      return s.set(e, l), l;\n    }\n    if (Array.isArray(e)) {\n      const l = e.map((f) => a(f));\n      return s.set(e, l), l;\n    }\n    if (e instanceof Map) {\n      const l = [...e.entries()].map(([i, m]) => [a(i), a(m)]), f = new Map(l);\n      return s.set(e, f), f;\n    }\n    if (e instanceof Set) {\n      const l = [...e].map((i) => a(i)), f = new Set(l);\n      return s.set(e, f), f;\n    }\n    const u = wt(e);\n    if (we(e) || u) {\n      const l = {};\n      for (const f of Object.keys(e))\n        l[f] = a(e[f]);\n      return u && (l.next ?? (l.next = a(e.next.bind(e))), l.return ?? (l.return = a(e.return.bind(e))), l.throw ?? (l.throw = a(e.throw.bind(e))), l[Se] = !0), s.set(e, l), l;\n    }\n  }\n  if (typeof e == \"function\") {\n    const a = t.functions.serialize(e, t, n), u = {\n      [ie]: a\n    };\n    return s.set(e, u), u;\n  }\n  return s.set(e, e), e;\n}, O = function(e, t, n = !1) {\n  if (e == null) return e;\n  if (typeof e == \"object\") {\n    if (b(this, W) && !n) {\n      const o = b(this, W).call(this, e, (a) => y(this, w, O).call(this, a, t, !0), t);\n      if (o !== void 0)\n        return o;\n    }\n    if (e == null)\n      return e;\n    if (Array.isArray(e))\n      return e.map((o) => y(this, w, O).call(this, o, t));\n    if (e instanceof Map)\n      return new Map([...e].map(([o, a]) => [y(this, w, O).call(this, o, t), y(this, w, O).call(this, a, t)]));\n    if (e instanceof Set)\n      return new Set([...e].map((o) => y(this, w, O).call(this, o, t)));\n    if (ie in e)\n      return t.functions.deserialize(e[ie], t);\n    if (!we(e))\n      return e;\n    const s = {};\n    for (const o of Object.keys(e))\n      o === Se ? s[Symbol.asyncIterator] = () => s : s[o] = y(this, w, O).call(this, e[o], t);\n    return s;\n  }\n  return e;\n};\nvar k, D, M, ae, ke, le, je;\nclass Mt {\n  constructor(e, {\n    imports: t,\n    exports: n,\n    functions: s = new Rt(),\n    serialization: o = new St(),\n    signal: a\n  } = {}) {\n    S(this, M);\n    S(this, k);\n    S(this, D, /* @__PURE__ */ new Map());\n    var u, l, f, i;\n    this.messages = e, Z(this, k, a ? new Tt(a) : new AbortController()), this.exports = n ?? {}, this.imports = At(y(this, M, ke).bind(this), t), this.functions = s, this.serialization = o, (l = (u = this.functions).start) == null || l.call(u, this), (i = (f = this.serialization).start) == null || i.call(f, this), this.signal.addEventListener(\"abort\", () => {\n      for (const m of b(this, D).keys())\n        y(this, M, le).call(this, m, void 0, new Re());\n      b(this, D).clear();\n    }, {\n      once: !0\n    }), e.listen(async (m) => {\n      if (!(Array.isArray(m) && typeof m[0] == \"number\"))\n        return;\n      const c = m;\n      switch (c[0]) {\n        case ve: {\n          const [, p, h, E] = c, _ = this.exports[h] ?? (() => {\n            throw new Error(`No '${h}' method is exported from this thread`);\n          });\n          await y(this, M, ae).call(this, _, E, (R, A, T) => {\n            this.messages.send([ye, p, R, A], T);\n          });\n          break;\n        }\n        case Le: {\n          const [, p, h, E] = c, _ = this.functions.get(h, this) ?? Nt;\n          await y(this, M, ae).call(this, _, E, (R, A, T) => {\n            this.messages.send([Te, p, R, A], T);\n          });\n          break;\n        }\n        case ye:\n        case Te: {\n          y(this, M, le).call(this, ...c.slice(1));\n          break;\n        }\n        case Ue: {\n          const p = c[1];\n          this.functions.release(p, this);\n          break;\n        }\n      }\n    }, {\n      signal: this.signal\n    });\n  }\n  /**\n   * An object that exposes the methods that can be called on the paired thread.\n   * This object will automatically encode and decode arguments and return values\n   * as necessary.\n   */\n  /**\n   * An object that exposes the methods that can be called on this thread by the\n   * paired thread. To set these methods, pass the `exports` option when creating\n   * a new `Thread`.\n   */\n  /**\n   * An object that provides the message-passing interface that allows communication\n   * to flow between environments.\n   */\n  /**\n   * An object that manages how functions are proxied between threads.\n   */\n  /**\n   * An object that manages how values are serialized and deserialized between threads.\n   */\n  /**\n   * An `AbortSignal` that indicates whether the communication channel is still open.\n   */\n  get signal() {\n    return b(this, k).signal;\n  }\n  /**\n   * A boolean indicating whether the communication channel is still open.\n   */\n  get closed() {\n    return b(this, k).signal.aborted;\n  }\n  /**\n   * Closes the communication channel between the two threads. This will prevent\n   * any further communication between the threads, and will clean up any memory\n   * associated with in-progress communication. It will also reject any inflight\n   * function calls between threads with a `ThreadClosedError`.\n   */\n  close() {\n    b(this, k).abort();\n  }\n  /**\n   * Requests that the thread provide the context needed to make a function\n   * call between threads. You provide this method a function to call and the\n   * unserialized arguments you wish to call it with, and the thread will call\n   * the function you provided with a serialized call ID, the serialized arguments,\n   * and any transferable objects that need to be passed between threads.\n   */\n  call(e, t) {\n    if (this.closed)\n      return Promise.reject(new Re());\n    const n = [], s = this.serialization.serialize(t, this, n), o = ze(), a = y(this, M, je).call(this, o);\n    return e(o, s, n), a;\n  }\n}\nk = new WeakMap(), D = new WeakMap(), M = new WeakSet(), ae = async function(e, t, n) {\n  try {\n    const s = this.functions.call ? await this.functions.call(e, t, this) : await e(...this.serialization.deserialize(t, this)), o = [], a = this.serialization.serialize(s, this, o);\n    n(a, void 0, o);\n  } catch (s) {\n    n(void 0, this.serialization.serialize(s, this));\n  }\n}, ke = function(e) {\n  return (...t) => {\n    try {\n      if (typeof e != \"string\" && typeof e != \"number\")\n        throw new Error(`Can’t call a symbol method on a thread: ${e.toString()}`);\n      return this.call((n, s, o) => {\n        this.messages.send([ve, n, e, s], o);\n      }, t);\n    } catch (n) {\n      return Promise.reject(n);\n    }\n  };\n}, le = function(...e) {\n  const t = e[0], n = b(this, D).get(t);\n  n && (n(...e), b(this, D).delete(t));\n}, je = function(e) {\n  const t = new Promise((n, s) => {\n    b(this, D).set(e, (o, a, u) => {\n      u == null ? n(this.serialization.deserialize(a, this)) : s(this.serialization.deserialize(u, this));\n    });\n  });\n  return Object.defineProperty(t, Symbol.asyncIterator, {\n    async *value() {\n      const n = await t;\n      Object.defineProperty(n, Symbol.asyncIterator, {\n        value: () => n\n      }), yield* n;\n    }\n  }), t;\n};\nfunction At(r, e) {\n  let t;\n  if (e == null) {\n    if (typeof Proxy != \"function\")\n      throw new Error(\"You must pass an array of callable methods in environments without Proxies.\");\n    const n = /* @__PURE__ */ new Map();\n    t = new Proxy({}, {\n      get(s, o) {\n        if (n.has(o))\n          return n.get(o);\n        const a = r(o);\n        return n.set(o, a), a;\n      }\n    });\n  } else {\n    t = {};\n    for (const n of e)\n      Object.defineProperty(t, n, {\n        value: r(n),\n        writable: !1,\n        configurable: !0,\n        enumerable: !0\n      });\n  }\n  return t;\n}\nfunction Nt() {\n  throw new Error(\"You attempted to call a function that is not stored. It may have already been released.\");\n}\nconst It = \"quilt.threads.ping\", Me = \"quilt.threads.pong\";\nfunction Pt(r, {\n  targetOrigin: e = \"*\"\n} = {}) {\n  let t = !1;\n  const n = function(a, u) {\n    r.postMessage(a, e, u);\n  }, s = new Promise((o) => {\n    const a = new AbortController();\n    globalThis.window.addEventListener(\"message\", (u) => {\n      u.source === r && u.data === Me && (t = !0, a.abort(), o());\n    }, {\n      signal: a.signal\n    }), a.signal.addEventListener(\"abort\", () => o(), {\n      once: !0\n    }), n(It);\n  });\n  return {\n    send(o, a) {\n      return t ? n(o, a) : s.then(() => {\n        if (t) return n(o, a);\n      });\n    },\n    listen(o, {\n      signal: a\n    }) {\n      self.addEventListener(\"message\", (u) => {\n        u.source === r && u.data !== Me && o(u.data);\n      }, {\n        signal: a\n      });\n    }\n  };\n}\nclass Ot extends Mt {\n  constructor(e, {\n    targetOrigin: t = \"*\",\n    ...n\n  } = {}) {\n    super(Pt(e.contentWindow, {\n      targetOrigin: t\n    }), n), this.iframe = e;\n  }\n}\nconst Fe = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ content: r, children: e, ...t }, n) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { ref: n, ...t, children: r || e }));\nFe.displayName = \"UIText\";\nconst Ye = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ label: r, onPress: e, onClick: t, children: n, ...s }, o) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n  \"button\",\n  {\n    ref: o,\n    onClick: (u) => {\n      e && e(), t && t(u);\n    },\n    style: {\n      padding: \"8px 16px\",\n      backgroundColor: \"#007bff\",\n      color: \"white\",\n      border: \"none\",\n      borderRadius: \"4px\",\n      cursor: \"pointer\"\n    },\n    ...s,\n    children: r || n\n  }\n));\nYe.displayName = \"UIButton\";\nconst Ge = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({\n    direction: r = \"vertical\",\n    spacing: e = \"8\",\n    align: t = \"stretch\",\n    justify: n = \"flex-start\",\n    children: s,\n    ...o\n  }, a) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    \"div\",\n    {\n      ref: a,\n      style: {\n        display: \"flex\",\n        flexDirection: r === \"horizontal\" ? \"row\" : \"column\",\n        gap: `${e}px`,\n        alignItems: t,\n        justifyContent: n\n      },\n      ...o,\n      children: s\n    }\n  )\n);\nGe.displayName = \"UIStack\";\nconst Ve = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ src: r, alt: e, width: t, height: n, children: s, ...o }, a) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n  \"img\",\n  {\n    ref: a,\n    src: r,\n    alt: e,\n    width: t,\n    height: n,\n    style: {\n      maxWidth: \"100%\",\n      height: \"auto\",\n      borderRadius: \"8px\",\n      boxShadow: \"0 2px 8px rgba(0, 0, 0, 0.1)\"\n    },\n    ...o\n  }\n));\nVe.displayName = \"UIImage\";\nconst We = {\n  name: \"basic\",\n  elements: [\n    {\n      tagName: \"ui-text\",\n      component: Fe,\n      propMapping: {\n        content: \"content\"\n      },\n      eventMapping: {}\n    },\n    {\n      tagName: \"ui-button\",\n      component: Ye,\n      propMapping: {\n        label: \"label\"\n      },\n      eventMapping: {\n        press: \"onPress\"\n      }\n    },\n    {\n      tagName: \"ui-stack\",\n      component: Ge,\n      propMapping: {\n        direction: \"direction\",\n        spacing: \"spacing\",\n        align: \"align\",\n        justify: \"justify\"\n      },\n      eventMapping: {}\n    },\n    {\n      tagName: \"ui-image\",\n      component: Ve,\n      propMapping: {\n        src: \"src\",\n        alt: \"alt\",\n        width: \"width\",\n        height: \"height\"\n      },\n      eventMapping: {}\n    }\n  ]\n}, Dt = ({ receiver: r }) => {\n  const e = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (e.current)\n      return r.connect(e.current), () => {\n        r.disconnect();\n      };\n  }, [r]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: e, \"data-testid\": \"standard-dom-renderer-container\" });\n}, Ct = ({\n  resource: r,\n  library: e,\n  remoteElements: t = [],\n  onUIAction: n\n}) => {\n  const s = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), o = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), [a, u] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), l = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => (r.mimeType || \"\").includes(\"framework=react\") ? \"react\" : \"webcomponents\", [r.mimeType]), f = `${e == null ? void 0 : e.name}-${l}`, { receiver: i, components: m } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    switch (l) {\n      case \"react\": {\n        const c = new dt(), p = e || We, h = /* @__PURE__ */ new Map();\n        return p && p.elements.forEach((E) => {\n          const _ = _t(E.component);\n          h.set(E.tagName, _);\n        }), {\n          receiver: c,\n          components: h\n        };\n      }\n      case \"webcomponents\":\n      default:\n        return {\n          receiver: new ut(),\n          components: null\n        };\n    }\n  }, [r, e, t]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    function c(p) {\n      var h;\n      if (s.current && p.source === s.current.contentWindow) {\n        const E = p.data;\n        if (!E)\n          return;\n        (h = n == null ? void 0 : n(E)) == null || h.catch((_) => {\n          console.error(\"Error handling UI action result in RemoteDOMResourceRenderer:\", _);\n        });\n      }\n    }\n    return window.addEventListener(\"message\", c), () => window.removeEventListener(\"message\", c);\n  }, [n]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const c = o.current;\n    return o.current = null, () => {\n      c == null || c.close();\n    };\n  }, [f]);\n  const d = () => {\n    const c = s.current;\n    if (!c || o.current)\n      return;\n    const p = new Ot(c);\n    o.current = p;\n    const { code: h, error: E } = tt(r);\n    if (E) {\n      u(E);\n      return;\n    }\n    if (h && (i != null && i.connection)) {\n      const _ = {\n        code: h,\n        remoteElements: t,\n        useReactRenderer: l === \"react\",\n        componentLibrary: e == null ? void 0 : e.name\n      };\n      p.imports.render(_, i.connection).catch((R) => console.error(\"Error calling remote render:\", R));\n    }\n  };\n  return a ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", { className: \"text-red-500\", children: a }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      \"iframe\",\n      {\n        ref: s,\n        srcDoc: vt,\n        sandbox: \"allow-scripts\",\n        style: { display: \"none\" },\n        title: \"Remote DOM Sandbox\",\n        onLoad: d\n      },\n      f\n    ),\n    l === \"react\" && m ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(bt, { receiver: i, components: m }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Dt, { receiver: i })\n  ] });\n};\nfunction Lt(r) {\n  var e;\n  if (r.contentType)\n    return r.contentType;\n  if (r.mimeType === \"text/html\")\n    return \"rawHtml\";\n  if (r.mimeType === \"text/uri-list\")\n    return \"externalUrl\";\n  if ((e = r.mimeType) != null && e.startsWith(\"application/vnd.mcp-ui.remote-dom\"))\n    return \"remoteDom\";\n}\nconst Ut = (r) => {\n  const { resource: e, onUIAction: t, supportedContentTypes: n, htmlProps: s, remoteDomProps: o } = r, a = Lt(e);\n  if (n && a && !n.includes(a))\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", { className: \"text-red-500\", children: [\n      \"Unsupported content type: \",\n      a,\n      \".\"\n    ] });\n  switch (a) {\n    case \"rawHtml\":\n    case \"externalUrl\":\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Ne, { resource: e, onUIAction: t, ...s });\n    case \"remoteDom\":\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n        Ct,\n        {\n          resource: e,\n          onUIAction: t,\n          library: (o == null ? void 0 : o.library) || We,\n          ...o\n        }\n      );\n    default:\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", { className: \"text-red-500\", children: \"Unsupported resource type.\" });\n  }\n};\nUt.displayName = \"UIResourceRenderer\";\nfunction jt(r) {\n  var e, t;\n  return (r.type === \"resource\" && ((t = (e = r.resource) == null ? void 0 : e.uri) == null ? void 0 : t.startsWith(\"ui://\"))) ?? !1;\n}\nconst Ft = {\n  tagName: \"ui-card\"\n}, Yt = {\n  tagName: \"ui-button\",\n  remoteAttributes: [\"label\"],\n  remoteEvents: [\"click\", \"press\"]\n}, Gt = {\n  tagName: \"ui-text\",\n  remoteAttributes: [\"content\"]\n}, Vt = {\n  tagName: \"ui-stack\",\n  remoteAttributes: [\"direction\", \"spacing\", \"align\", \"justify\"]\n}, Wt = {\n  tagName: \"ui-image\",\n  remoteAttributes: [\"src\", \"alt\", \"width\", \"height\"]\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1jcC11aS9jbGllbnQvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMERBQTBEO0FBQ3BHO0FBQ0E7QUFDeUU7QUFDNEY7QUFDcks7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxLQUFLO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLDBDQUEwQyxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwwQ0FBMEMsRUFBRTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZUFBZSxJQUFJLHFCQUFxQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLE1BQU07QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRCxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxvQkFBb0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsRUFBRTtBQUNyQyxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFL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LFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzREFBQyxPQUFPLGtDQUFrQztBQUN2RTtBQUNBLDZCQUE2QixzREFBQztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0RBQUMsUUFBUSxtRUFBbUU7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBWUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tY3AtdWkvLi9ub2RlX21vZHVsZXMvQG1jcC11aS9jbGllbnQvZGlzdC9pbmRleC5tanM/Nzc1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQmUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgcGUgPSAocikgPT4ge1xuICB0aHJvdyBUeXBlRXJyb3Iocik7XG59O1xudmFyICRlID0gKHIsIGUsIHQpID0+IGUgaW4gciA/IEJlKHIsIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiByW2VdID0gdDtcbnZhciBMID0gKHIsIGUsIHQpID0+ICRlKHIsIHR5cGVvZiBlICE9IFwic3ltYm9sXCIgPyBlICsgXCJcIiA6IGUsIHQpLCBvZSA9IChyLCBlLCB0KSA9PiBlLmhhcyhyKSB8fCBwZShcIkNhbm5vdCBcIiArIHQpO1xudmFyIGIgPSAociwgZSwgdCkgPT4gKG9lKHIsIGUsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIiksIHQgPyB0LmNhbGwocikgOiBlLmdldChyKSksIFMgPSAociwgZSwgdCkgPT4gZS5oYXMocikgPyBwZShcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIikgOiBlIGluc3RhbmNlb2YgV2Vha1NldCA/IGUuYWRkKHIpIDogZS5zZXQociwgdCksIFogPSAociwgZSwgdCwgbikgPT4gKG9lKHIsIGUsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKSwgbiA/IG4uY2FsbChyLCB0KSA6IGUuc2V0KHIsIHQpLCB0KSwgeSA9IChyLCBlLCB0KSA9PiAob2UociwgZSwgXCJhY2Nlc3MgcHJpdmF0ZSBtZXRob2RcIiksIHQpO1xuaW1wb3J0IHsganN4IGFzIHYsIEZyYWdtZW50IGFzIHRlLCBqc3hzIGFzIGNlIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgcmUsIHsgdXNlUmVmIGFzIEIsIHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgS2UsIHVzZU1lbW8gYXMgeiwgdXNlQ2FsbGJhY2sgYXMgWmUsIHVzZUVmZmVjdCBhcyBILCB1c2VTdGF0ZSBhcyBBZSwgdXNlRGVidWdWYWx1ZSBhcyBYZSwgbWVtbyBhcyBKZSB9IGZyb20gXCJyZWFjdFwiO1xuY29uc3QgZmUgPSB7XG4gIFBSRUZFUlJFRF9GUkFNRV9TSVpFOiBcInByZWZlcnJlZC1mcmFtZS1zaXplXCIsXG4gIElOSVRJQUxfUkVOREVSX0RBVEE6IFwiaW5pdGlhbC1yZW5kZXItZGF0YVwiXG59LCBoZSA9IFwibWNwdWkuZGV2L3VpLVwiO1xuZnVuY3Rpb24gUWUocikge1xuICBsZXQgZTtcbiAgdHJ5IHtcbiAgICBlID0gbmV3IFVSTChyKTtcbiAgfSBjYXRjaCAodCkge1xuICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiRXJyb3IgcGFyc2luZyBVUkw6XCIsIHQpLCAhMTtcbiAgfVxuICByZXR1cm4gZS5wcm90b2NvbCA9PT0gXCJodHRwOlwiIHx8IGUucHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG59XG5mdW5jdGlvbiBldChyLCBlKSB7XG4gIGlmIChyLm1pbWVUeXBlICE9PSBcInRleHQvaHRtbFwiICYmIHIubWltZVR5cGUgIT09IFwidGV4dC91cmktbGlzdFwiKVxuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogXCJSZXNvdXJjZSBtdXN0IGJlIG9mIHR5cGUgdGV4dC9odG1sIChmb3IgSFRNTCBjb250ZW50KSBvciB0ZXh0L3VyaS1saXN0IChmb3IgVVJMIGNvbnRlbnQpLlwiXG4gICAgfTtcbiAgaWYgKHIubWltZVR5cGUgPT09IFwidGV4dC91cmktbGlzdFwiKSB7XG4gICAgbGV0IHQgPSBcIlwiO1xuICAgIGlmICh0eXBlb2Ygci50ZXh0ID09IFwic3RyaW5nXCIgJiYgci50ZXh0LnRyaW0oKSAhPT0gXCJcIilcbiAgICAgIHQgPSByLnRleHQ7XG4gICAgZWxzZSBpZiAodHlwZW9mIHIuYmxvYiA9PSBcInN0cmluZ1wiKVxuICAgICAgdHJ5IHtcbiAgICAgICAgdCA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShcbiAgICAgICAgICBVaW50OEFycmF5LmZyb20oYXRvYihyLmJsb2IpLCAobykgPT4gby5jaGFyQ29kZUF0KDApKVxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkVycm9yIGRlY29kaW5nIGJhc2U2NCBibG9iIGZvciBVUkwgY29udGVudDpcIiwgbyksIHtcbiAgICAgICAgICBlcnJvcjogXCJFcnJvciBkZWNvZGluZyBVUkwgZnJvbSBibG9iLlwiXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IFwiVVJMIHJlc291cmNlIGV4cGVjdHMgYSBub24tZW1wdHkgdGV4dCBvciBibG9iIGZpZWxkIGNvbnRhaW5pbmcgdGhlIFVSTC5cIlxuICAgICAgfTtcbiAgICBpZiAodC50cmltKCkgPT09IFwiXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogXCJVUkwgY29udGVudCBpcyBlbXB0eS5cIlxuICAgICAgfTtcbiAgICBjb25zdCBuID0gdC5zcGxpdChgXG5gKS5tYXAoKG8pID0+IG8udHJpbSgpKS5maWx0ZXIoKG8pID0+IG8gJiYgIW8uc3RhcnRzV2l0aChcIiNcIikgJiYgUWUobykpO1xuICAgIGlmIChuLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBcIk5vIHZhbGlkIFVSTHMgZm91bmQgaW4gdXJpLWxpc3QgY29udGVudC5cIlxuICAgICAgfTtcbiAgICBuLmxlbmd0aCA+IDEgJiYgY29uc29sZS53YXJuKFxuICAgICAgYE11bHRpcGxlIFVSTHMgZm91bmQgaW4gdXJpLWxpc3QgY29udGVudC4gVXNpbmcgdGhlIGZpcnN0IFVSTDogXCIke25bMF19XCIuIE90aGVyIFVSTHMgaWdub3JlZDpgLFxuICAgICAgbi5zbGljZSgxKVxuICAgICk7XG4gICAgY29uc3QgcyA9IG5bMF07XG4gICAgaWYgKGUgJiYgZS50cmltKCkgIT09IFwiXCIpXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvID0gbmV3IFVSTChlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiBvLmhvc3QgPT09IHdpbmRvdy5sb2NhdGlvbi5ob3N0KVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkZvciBzZWN1cml0eSwgdGhlIHByb3h5IG9yaWdpbiBtdXN0IG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgaG9zdCBvcmlnaW4uIFVzaW5nIG9yaWdpbmFsIFVSTCBpbnN0ZWFkLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiBvLnNlYXJjaFBhcmFtcy5zZXQoXCJ1cmxcIiwgcyksIHtcbiAgICAgICAgICAgIGlmcmFtZVNyYzogby50b1N0cmluZygpLFxuICAgICAgICAgICAgaWZyYW1lUmVuZGVyTW9kZTogXCJzcmNcIlxuICAgICAgICAgIH07XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgcHJveHkgVVJMIHByb3ZpZGVkOiBcIiR7ZX1cIi4gRmFsbGluZyBiYWNrIHRvIGRpcmVjdCBVUkwuYCxcbiAgICAgICAgICBvIGluc3RhbmNlb2YgRXJyb3IgPyBvLm1lc3NhZ2UgOiBTdHJpbmcobylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaWZyYW1lU3JjOiBzLFxuICAgICAgaWZyYW1lUmVuZGVyTW9kZTogXCJzcmNcIlxuICAgIH07XG4gIH0gZWxzZSBpZiAoci5taW1lVHlwZSA9PT0gXCJ0ZXh0L2h0bWxcIikge1xuICAgIGxldCB0ID0gXCJcIjtcbiAgICBpZiAodHlwZW9mIHIudGV4dCA9PSBcInN0cmluZ1wiKVxuICAgICAgdCA9IHIudGV4dDtcbiAgICBlbHNlIGlmICh0eXBlb2Ygci5ibG9iID09IFwic3RyaW5nXCIpXG4gICAgICB0cnkge1xuICAgICAgICB0ID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKFxuICAgICAgICAgIFVpbnQ4QXJyYXkuZnJvbShhdG9iKHIuYmxvYiksIChuKSA9PiBuLmNoYXJDb2RlQXQoMCkpXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiRXJyb3IgZGVjb2RpbmcgYmFzZTY0IGJsb2IgZm9yIEhUTUwgY29udGVudDpcIiwgbiksIHtcbiAgICAgICAgICBlcnJvcjogXCJFcnJvciBkZWNvZGluZyBIVE1MIGNvbnRlbnQgZnJvbSBibG9iLlwiXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IFwiSFRNTCByZXNvdXJjZSByZXF1aXJlcyB0ZXh0IG9yIGJsb2IgY29udGVudC5cIlxuICAgICAgfTtcbiAgICBpZiAoZSAmJiBlLnRyaW0oKSAhPT0gXCJcIilcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG4gPSBuZXcgVVJMKGUpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIG4uaG9zdCA9PT0gd2luZG93LmxvY2F0aW9uLmhvc3QpXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRm9yIHNlY3VyaXR5LCB0aGUgcHJveHkgb3JpZ2luIG11c3Qgbm90IGJlIHRoZSBzYW1lIGFzIHRoZSBob3N0IG9yaWdpbi4gVXNpbmcgc3JjRG9jIHJlbmRlcmluZyBpbnN0ZWFkLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiBuLnNlYXJjaFBhcmFtcy5zZXQoXCJjb250ZW50VHlwZVwiLCBcInJhd2h0bWxcIiksIHtcbiAgICAgICAgICAgIGlmcmFtZVNyYzogbi50b1N0cmluZygpLFxuICAgICAgICAgICAgaWZyYW1lUmVuZGVyTW9kZTogXCJzcmNcIixcbiAgICAgICAgICAgIGh0bWxTdHJpbmc6IHRcbiAgICAgICAgICAgIC8vIFBhc3MgSFRNTCBzbyBpdCBjYW4gYmUgc2VudCB0byB0aGUgcHJveHkgdmlhIHBvc3RNZXNzYWdlXG4gICAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgSW52YWxpZCBwcm94eSBVUkwgcHJvdmlkZWQ6IFwiJHtlfVwiLiBGYWxsaW5nIGJhY2sgdG8gc3JjRG9jIHJlbmRlcmluZy5gLFxuICAgICAgICAgIG4gaW5zdGFuY2VvZiBFcnJvciA/IG4ubWVzc2FnZSA6IFN0cmluZyhuKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIHJldHVybiB7XG4gICAgICBodG1sU3RyaW5nOiB0LFxuICAgICAgaWZyYW1lUmVuZGVyTW9kZTogXCJzcmNEb2NcIlxuICAgIH07XG4gIH0gZWxzZVxuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogXCJVbnN1cHBvcnRlZCBtaW1lVHlwZS4gRXhwZWN0ZWQgdGV4dC9odG1sIG9yIHRleHQvdXJpLWxpc3QuXCJcbiAgICB9O1xufVxuZnVuY3Rpb24gdHQocikge1xuICBpZiAodHlwZW9mIHIudGV4dCA9PSBcInN0cmluZ1wiICYmIHIudGV4dC50cmltKCkgIT09IFwiXCIpXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IHIudGV4dFxuICAgIH07XG4gIGlmICh0eXBlb2Ygci5ibG9iID09IFwic3RyaW5nXCIpXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShcbiAgICAgICAgICBVaW50OEFycmF5LmZyb20oYXRvYihyLmJsb2IpLCAodCkgPT4gdC5jaGFyQ29kZUF0KDApKVxuICAgICAgICApXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiRXJyb3IgZGVjb2RpbmcgYmFzZTY0IGJsb2IgZm9yIHJlbW90ZSBET00gY29udGVudDpcIiwgZSksIHtcbiAgICAgICAgZXJyb3I6IFwiRXJyb3IgZGVjb2RpbmcgcmVtb3RlIERPTSBjb250ZW50IGZyb20gYmxvYi5cIlxuICAgICAgfTtcbiAgICB9XG4gIHJldHVybiB7XG4gICAgZXJyb3I6IFwiUmVtb3RlIERPTSByZXNvdXJjZSByZXF1aXJlcyBub24tZW1wdHkgdGV4dCBvciBibG9iIGNvbnRlbnQuXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIHJ0KHIpIHtcbiAgcmV0dXJuIHIuX21ldGEgPz8ge307XG59XG5mdW5jdGlvbiBudChyKSB7XG4gIGNvbnN0IGUgPSBydChyKSwgdCA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoW24sIHNdKSA9PiB7XG4gICAgbi5zdGFydHNXaXRoKGhlKSAmJiAodFtuLnNsaWNlKGhlLmxlbmd0aCldID0gcyk7XG4gIH0pLCB0O1xufVxuY29uc3QgTiA9IHtcbiAgVUlfTUVTU0FHRV9SRUNFSVZFRDogXCJ1aS1tZXNzYWdlLXJlY2VpdmVkXCIsXG4gIFVJX01FU1NBR0VfUkVTUE9OU0U6IFwidWktbWVzc2FnZS1yZXNwb25zZVwiLFxuICBVSV9TSVpFX0NIQU5HRTogXCJ1aS1zaXplLWNoYW5nZVwiLFxuICBVSV9MSUZFQ1lDTEVfSUZSQU1FX1JFQURZOiBcInVpLWxpZmVjeWNsZS1pZnJhbWUtcmVhZHlcIixcbiAgVUlfTElGRUNZQ0xFX0lGUkFNRV9SRU5ERVJfREFUQTogXCJ1aS1saWZlY3ljbGUtaWZyYW1lLXJlbmRlci1kYXRhXCIsXG4gIFVJX1JFUVVFU1RfUkVOREVSX0RBVEE6IFwidWktcmVxdWVzdC1yZW5kZXItZGF0YVwiLFxuICAvLyBQcm94eS1vbmx5IGxpZmVjeWNsZSBmb3Igb3V0ZXIgaWZyYW1lIChkaXN0aW5jdCBmcm9tIHdpZGdldCByZWFkaW5lc3MpXG4gIFVJX1BST1hZX0lGUkFNRV9SRUFEWTogXCJ1aS1wcm94eS1pZnJhbWUtcmVhZHlcIixcbiAgLy8gQ29udGVudCB0cmFuc3BvcnQgZm9yIHJhdyBIVE1MIHdoZW4gdXNpbmcgcHJveHlcbiAgVUlfSFRNTF9DT05URU5UOiBcInVpLWh0bWwtY29udGVudFwiXG59LCBvdCA9IHtcbiAgV0FJVF9GT1JfUkVOREVSX0RBVEE6IFwid2FpdEZvclJlbmRlckRhdGFcIlxufSwgTmUgPSAoe1xuICByZXNvdXJjZTogcixcbiAgb25VSUFjdGlvbjogZSxcbiAgc3R5bGU6IHQsXG4gIHByb3h5OiBuLFxuICBpZnJhbWVSZW5kZXJEYXRhOiBzLFxuICBhdXRvUmVzaXplSWZyYW1lOiBvLFxuICBzYW5kYm94UGVybWlzc2lvbnM6IGEsXG4gIGlmcmFtZVByb3BzOiB1XG59KSA9PiB7XG4gIGNvbnN0IGwgPSBCKG51bGwpO1xuICBLZSh1ID09IG51bGwgPyB2b2lkIDAgOiB1LnJlZiwgKCkgPT4gbC5jdXJyZW50KTtcbiAgY29uc3QgeyBlcnJvcjogZiwgaWZyYW1lU3JjOiBpLCBpZnJhbWVSZW5kZXJNb2RlOiBtLCBodG1sU3RyaW5nOiBkIH0gPSB6KFxuICAgICgpID0+IGV0KHIsIG4pLFxuICAgIFtyLCBuXVxuICApLCBjID0geigoKSA9PiBudChyKSwgW3JdKSwgcCA9IGNbZmUuUFJFRkVSUkVEX0ZSQU1FX1NJWkVdID8/IFtcIjEwMCVcIiwgXCIxMDAlXCJdLCBoID0gY1tmZS5JTklUSUFMX1JFTkRFUl9EQVRBXSA/PyB2b2lkIDAsIEUgPSB6KCgpID0+IHtcbiAgICBpZiAoISghcyAmJiAhaCkpXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5oLFxuICAgICAgICAuLi5zXG4gICAgICB9O1xuICB9LCBbcywgaF0pLCBfID0geigoKSA9PiB7XG4gICAgaWYgKGkgJiYgRSkge1xuICAgICAgY29uc3QgVCA9IG5ldyBVUkwoaSk7XG4gICAgICByZXR1cm4gVC5zZWFyY2hQYXJhbXMuc2V0KG90LldBSVRfRk9SX1JFTkRFUl9EQVRBLCBcInRydWVcIiksIFQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH0sIFtpLCBFXSksIFIgPSBaZShcbiAgICAoVCkgPT4ge1xuICAgICAgdmFyIGo7XG4gICAgICBpZiAoRSkge1xuICAgICAgICBjb25zdCBJID0gVC5jdXJyZW50VGFyZ2V0LmNvbnRlbnRXaW5kb3csIFAgPSBfID8gbmV3IFVSTChfKS5vcmlnaW4gOiBcIipcIjtcbiAgICAgICAgVShcbiAgICAgICAgICBOLlVJX0xJRkVDWUNMRV9JRlJBTUVfUkVOREVSX0RBVEEsXG4gICAgICAgICAgSSxcbiAgICAgICAgICBQLFxuICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZW5kZXJEYXRhOiBFXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgKGogPSB1ID09IG51bGwgPyB2b2lkIDAgOiB1Lm9uTG9hZCkgPT0gbnVsbCB8fCBqLmNhbGwodSwgVCk7XG4gICAgfSxcbiAgICBbRSwgXywgdSA9PSBudWxsID8gdm9pZCAwIDogdS5vbkxvYWRdXG4gICksIEEgPSB6KCgpID0+IG0gPT09IFwic3JjRG9jXCIgPyBfZShhID8/IFwiXCIsIFwiYWxsb3ctc2NyaXB0c1wiKSA6IF9lKGEgPz8gXCJcIiwgXCJhbGxvdy1zY3JpcHRzIGFsbG93LXNhbWUtb3JpZ2luXCIpLCBbYSwgbV0pO1xuICByZXR1cm4gSCgoKSA9PiB7XG4gICAgYXN5bmMgZnVuY3Rpb24gVChqKSB7XG4gICAgICBjb25zdCB7IHNvdXJjZTogSSwgb3JpZ2luOiBQLCBkYXRhOiBnIH0gPSBqO1xuICAgICAgaWYgKGwuY3VycmVudCAmJiBJID09PSBsLmN1cnJlbnQuY29udGVudFdpbmRvdykge1xuICAgICAgICBpZiAoKGcgPT0gbnVsbCA/IHZvaWQgMCA6IGcudHlwZSkgPT09IE4uVUlfUFJPWFlfSUZSQU1FX1JFQURZKSB7XG4gICAgICAgICAgbSA9PT0gXCJzcmNcIiAmJiBkICYmIChfICE9IG51bGwgJiYgXy5pbmNsdWRlcyhcImNvbnRlbnRUeXBlPXJhd2h0bWxcIikpICYmIFUoXG4gICAgICAgICAgICBOLlVJX0hUTUxfQ09OVEVOVCxcbiAgICAgICAgICAgIEksXG4gICAgICAgICAgICBQLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBodG1sOiBkLFxuICAgICAgICAgICAgICBzYW5kYm94OiBBXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChnID09IG51bGwgPyB2b2lkIDAgOiBnLnR5cGUpID09PSBOLlVJX0xJRkVDWUNMRV9JRlJBTUVfUkVBRFkpIHtcbiAgICAgICAgICBFICYmIFUoXG4gICAgICAgICAgICBOLlVJX0xJRkVDWUNMRV9JRlJBTUVfUkVOREVSX0RBVEEsXG4gICAgICAgICAgICBJLFxuICAgICAgICAgICAgUCxcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmVuZGVyRGF0YTogRVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZyA9PSBudWxsID8gdm9pZCAwIDogZy50eXBlKSA9PT0gTi5VSV9SRVFVRVNUX1JFTkRFUl9EQVRBKSB7XG4gICAgICAgICAgVShcbiAgICAgICAgICAgIE4uVUlfTElGRUNZQ0xFX0lGUkFNRV9SRU5ERVJfREFUQSxcbiAgICAgICAgICAgIEksXG4gICAgICAgICAgICBQLFxuICAgICAgICAgICAgZy5tZXNzYWdlSWQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJlbmRlckRhdGE6IEVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGcgPT0gbnVsbCA/IHZvaWQgMCA6IGcudHlwZSkgPT09IE4uVUlfU0laRV9DSEFOR0UpIHtcbiAgICAgICAgICBjb25zdCB7IHdpZHRoOiBGLCBoZWlnaHQ6IEMgfSA9IGcucGF5bG9hZDtcbiAgICAgICAgICBpZiAobyAmJiBsLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IEhlID0gKHR5cGVvZiBvID09IFwiYm9vbGVhblwiIHx8IG8uaGVpZ2h0KSAmJiBDLCBxZSA9ICh0eXBlb2YgbyA9PSBcImJvb2xlYW5cIiB8fCBvLndpZHRoKSAmJiBGO1xuICAgICAgICAgICAgSGUgJiYgKGwuY3VycmVudC5zdHlsZS5oZWlnaHQgPSBgJHtDfXB4YCksIHFlICYmIChsLmN1cnJlbnQuc3R5bGUud2lkdGggPSBgJHtGfXB4YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZSA9IGc7XG4gICAgICAgIGlmICghbmUpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgIGNvbnN0IEYgPSBuZS5tZXNzYWdlSWQ7XG4gICAgICAgICAgVShOLlVJX01FU1NBR0VfUkVDRUlWRUQsIEksIFAsIEYpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBDID0gYXdhaXQgZShuZSk7XG4gICAgICAgICAgICBVKE4uVUlfTUVTU0FHRV9SRVNQT05TRSwgSSwgUCwgRiwge1xuICAgICAgICAgICAgICByZXNwb25zZTogQ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoQykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGhhbmRsaW5nIFVJIGFjdGlvbiByZXN1bHQgaW4gSFRNTFJlc291cmNlUmVuZGVyZXI6XCIsIEMpLCBVKE4uVUlfTUVTU0FHRV9SRVNQT05TRSwgSSwgUCwgRiwge1xuICAgICAgICAgICAgICBlcnJvcjogQ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgVCksICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBUKTtcbiAgfSwgW2UsIEUsIG0sIGQsIF8sIEFdKSwgZiA/IC8qIEBfX1BVUkVfXyAqLyB2KFwicFwiLCB7IGNsYXNzTmFtZTogXCJ0ZXh0LXJlZC01MDBcIiwgY2hpbGRyZW46IGYgfSkgOiBtID09PSBcInNyY0RvY1wiID8gZCA9PSBudWxsID8gZiA/IG51bGwgOiAvKiBAX19QVVJFX18gKi8gdihcInBcIiwgeyBjbGFzc05hbWU6IFwidGV4dC1vcmFuZ2UtNTAwXCIsIGNoaWxkcmVuOiBcIk5vIEhUTUwgY29udGVudCB0byBkaXNwbGF5LlwiIH0pIDogLyogQF9fUFVSRV9fICovIHYoXG4gICAgXCJpZnJhbWVcIixcbiAgICB7XG4gICAgICBzcmNEb2M6IGQsXG4gICAgICBzYW5kYm94OiBBLFxuICAgICAgc3R5bGU6IHsgd2lkdGg6IHBbMF0sIGhlaWdodDogcFsxXSwgLi4udCB9LFxuICAgICAgdGl0bGU6IFwiTUNQIEhUTUwgUmVzb3VyY2UgKEVtYmVkZGVkIENvbnRlbnQpXCIsXG4gICAgICAuLi51LFxuICAgICAgcmVmOiBsLFxuICAgICAgb25Mb2FkOiBSXG4gICAgfVxuICApIDogbSA9PT0gXCJzcmNcIiA/IF8gPT0gbnVsbCA/IGYgPyBudWxsIDogLyogQF9fUFVSRV9fICovIHYoXCJwXCIsIHsgY2xhc3NOYW1lOiBcInRleHQtb3JhbmdlLTUwMFwiLCBjaGlsZHJlbjogXCJObyBVUkwgcHJvdmlkZWQgZm9yIEhUTUwgcmVzb3VyY2UuXCIgfSkgOiAvKiBAX19QVVJFX18gKi8gdihcbiAgICBcImlmcmFtZVwiLFxuICAgIHtcbiAgICAgIHNyYzogXyxcbiAgICAgIHNhbmRib3g6IEEsXG4gICAgICBzdHlsZTogeyB3aWR0aDogcFswXSwgaGVpZ2h0OiBwWzFdLCAuLi50IH0sXG4gICAgICB0aXRsZTogXCJNQ1AgSFRNTCBSZXNvdXJjZSAoVVJMKVwiLFxuICAgICAgLi4udSxcbiAgICAgIHJlZjogbCxcbiAgICAgIG9uTG9hZDogUlxuICAgIH1cbiAgKSA6IC8qIEBfX1BVUkVfXyAqLyB2KFwicFwiLCB7IGNsYXNzTmFtZTogXCJ0ZXh0LWdyYXktNTAwXCIsIGNoaWxkcmVuOiBcIkluaXRpYWxpemluZyBIVE1MIHJlc291cmNlIGRpc3BsYXkuLi5cIiB9KTtcbn07XG5OZS5kaXNwbGF5TmFtZSA9IFwiSFRNTFJlc291cmNlUmVuZGVyZXJcIjtcbmZ1bmN0aW9uIFUociwgZSwgdCwgbiwgcykge1xuICBjb25zdCBvID0gdCAmJiB0ICE9PSBcIm51bGxcIiA/IHQgOiBcIipcIjtcbiAgZSA9PSBudWxsIHx8IGUucG9zdE1lc3NhZ2UoXG4gICAge1xuICAgICAgdHlwZTogcixcbiAgICAgIG1lc3NhZ2VJZDogbiA/PyB2b2lkIDAsXG4gICAgICBwYXlsb2FkOiBzXG4gICAgfSxcbiAgICBvXG4gICk7XG59XG5mdW5jdGlvbiBfZShyLCBlKSB7XG4gIHJldHVybiBbLi4uLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLnIuc3BsaXQoXCIgXCIpLCAuLi5lLnNwbGl0KFwiIFwiKV0pXS5maWx0ZXIoQm9vbGVhbikubWFwKCh0KSA9PiB0LnRyaW0oKSkuam9pbihcIiBcIik7XG59XG5jb25zdCBJZSA9IDEsIFBlID0gMywgT2UgPSA4LCBpdCA9IDksIHN0ID0gMCwgYXQgPSAxLCBsdCA9IDIsIGN0ID0gMywgJCA9IDEsIGRlID0gMiwgdWUgPSAzLCBxID0gXCJ+XCI7XG5mdW5jdGlvbiBEZSh7XG4gIGNhbGw6IHIsXG4gIGluc2VydENoaWxkOiBlLFxuICByZW1vdmVDaGlsZDogdCxcbiAgdXBkYXRlVGV4dDogbixcbiAgdXBkYXRlUHJvcGVydHk6IHNcbn0pIHtcbiAgY29uc3QgbyA9IHtcbiAgICBbc3RdOiBlLFxuICAgIFthdF06IHQsXG4gICAgW2x0XTogbixcbiAgICBbY3RdOiBzXG4gIH07XG4gIHJldHVybiB7XG4gICAgY2FsbDogcixcbiAgICBtdXRhdGUoYSkge1xuICAgICAgZm9yIChjb25zdCBbdSwgLi4ubF0gb2YgYSlcbiAgICAgICAgb1t1XSguLi5sKTtcbiAgICB9XG4gIH07XG59XG5jbGFzcyBkdCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICByZXRhaW46IGUsXG4gICAgcmVsZWFzZTogdCxcbiAgICBtZXRob2RzOiBuXG4gIH0gPSB7fSkge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgcmVtb3RlIHRyZWUuIFRoaXMgbm9kZSBpcyBhbHdheXMgZGVmaW5lZCxcbiAgICAgKiBhbmQgeW91IHdpbGwgbGlrZWx5IGJlIG1vc3QgaW50ZXJlc3RlZCBpbiBpdHMgYGNoaWxkcmVuYCBwcm9wZXJ0eSwgd2hpY2hcbiAgICAgKiBjb250YWlucyB0aGUgdG9wLWxldmVsIGVsZW1lbnRzIG9mIHRoZSByZW1vdGUgdHJlZS5cbiAgICAgKi9cbiAgICBMKHRoaXMsIFwicm9vdFwiLCB7XG4gICAgICBpZDogcSxcbiAgICAgIHR5cGU6IGl0LFxuICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgdmVyc2lvbjogMCxcbiAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBldmVudExpc3RlbmVyczoge31cbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgdGhhdCBjYW4gc3luY2hyb25pemUgYSB0cmVlIG9mIGVsZW1lbnRzIGJldHdlZW4gdHdvIEphdmFTY3JpcHRcbiAgICAgKiBlbnZpcm9ubWVudHMuIFRoaXMgb2JqZWN0IGFjdHMgYXMgYSDigJx0aGluIHdhaXN04oCdLCBhbGxvd2luZyBmb3IgZWZmaWNpZW50XG4gICAgICogY29tbXVuaWNhdGlvbiBvZiBjaGFuZ2VzIGJldHdlZW4gYSDigJxyZW1vdGXigJ0gZW52aXJvbm1lbnQgKHVzdWFsbHksIGEgSmF2YVNjcmlwdFxuICAgICAqIHNhbmRib3gsIHN1Y2ggYXMgYW4gYGlmcmFtZWAgb3IgV2ViIFdvcmtlcikgYW5kIGEg4oCcaG9zdOKAnSBlbnZpcm9ubWVudFxuICAgICAqICh1c3VhbGx5LCBhIHRvcC1sZXZlbCBicm93c2VyIHBhZ2UpLlxuICAgICAqL1xuICAgIEwodGhpcywgXCJhdHRhY2hlZFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbW3EsIHRoaXMucm9vdF1dKSk7XG4gICAgTCh0aGlzLCBcInN1YnNjcmliZXJzXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIEwodGhpcywgXCJwYXJlbnRzXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIEwodGhpcywgXCJpbXBsZW1lbnRhdGlvbnNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgY29uc3Qge1xuICAgICAgYXR0YWNoZWQ6IHMsXG4gICAgICBwYXJlbnRzOiBvLFxuICAgICAgc3Vic2NyaWJlcnM6IGFcbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBEZSh7XG4gICAgICBjYWxsOiAoaSwgbSwgLi4uZCkgPT4ge1xuICAgICAgICBjb25zdCBjID0gdGhpcy5pbXBsZW1lbnRhdGlvbnMuZ2V0KGkpLCBwID0gYyA9PSBudWxsID8gdm9pZCAwIDogY1ttXTtcbiAgICAgICAgaWYgKHR5cGVvZiBwICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgJHtpfSBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlICR7bX0oKSBtZXRob2RgKTtcbiAgICAgICAgcmV0dXJuIHAoLi4uZCk7XG4gICAgICB9LFxuICAgICAgaW5zZXJ0Q2hpbGQ6IChpLCBtLCBkKSA9PiB7XG4gICAgICAgIGNvbnN0IGMgPSBzLmdldChpKSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBwXG4gICAgICAgIH0gPSBjLCBoID0gbChtLCBjKTtcbiAgICAgICAgZCA9PT0gcC5sZW5ndGggPyBwLnB1c2goaCkgOiBwLnNwbGljZShkLCAwLCBoKSwgYy52ZXJzaW9uICs9IDEsIHRoaXMucGFyZW50cy5zZXQobS5pZCwgYy5pZCksIHUoYyk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2hpbGQ6IChpLCBtKSA9PiB7XG4gICAgICAgIGNvbnN0IGQgPSBzLmdldChpKSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBjXG4gICAgICAgIH0gPSBkLCBbcF0gPSBjLnNwbGljZShtLCAxKTtcbiAgICAgICAgcCAmJiAoZC52ZXJzaW9uICs9IDEsIHUoZCksIGYocCkpO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZVByb3BlcnR5OiAoaSwgbSwgZCwgYyA9ICQpID0+IHtcbiAgICAgICAgY29uc3QgcCA9IHMuZ2V0KGkpO1xuICAgICAgICBlID09IG51bGwgfHwgZShkKTtcbiAgICAgICAgbGV0IGg7XG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgIGNhc2UgJDpcbiAgICAgICAgICAgIGggPSBwLnByb3BlcnRpZXM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGRlOlxuICAgICAgICAgICAgaCA9IHAuYXR0cmlidXRlcztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgdWU6XG4gICAgICAgICAgICBoID0gcC5ldmVudExpc3RlbmVycztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IEUgPSBoW21dO1xuICAgICAgICBoW21dID0gZCwgcC52ZXJzaW9uICs9IDE7XG4gICAgICAgIGxldCBfO1xuICAgICAgICBpZiAobSA9PT0gXCJzbG90XCIpIHtcbiAgICAgICAgICBjb25zdCBSID0gdGhpcy5wYXJlbnRzLmdldChpKTtcbiAgICAgICAgICBfID0gUiA9PSBudWxsID8gUiA6IHMuZ2V0KFIpLCBfICYmIChfLnZlcnNpb24gKz0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdShwKSwgXyAmJiB1KF8pLCB0ID09IG51bGwgfHwgdChFKTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVUZXh0OiAoaSwgbSkgPT4ge1xuICAgICAgICBjb25zdCBkID0gcy5nZXQoaSk7XG4gICAgICAgIGQuZGF0YSA9IG0sIGQudmVyc2lvbiArPSAxLCB1KGQpO1xuICAgICAgfVxuICAgIH0pLCBuICYmIHRoaXMuaW1wbGVtZW50KHRoaXMucm9vdCwgbik7XG4gICAgZnVuY3Rpb24gdShpKSB7XG4gICAgICBjb25zdCBtID0gYS5nZXQoaS5pZCk7XG4gICAgICBpZiAobSlcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIG0pXG4gICAgICAgICAgZChpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbChpLCBtKSB7XG4gICAgICBsZXQgZDtcbiAgICAgIHN3aXRjaCAoaS50eXBlKSB7XG4gICAgICAgIGNhc2UgUGU6XG4gICAgICAgIGNhc2UgT2U6IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpZDogYyxcbiAgICAgICAgICAgIHR5cGU6IHAsXG4gICAgICAgICAgICBkYXRhOiBoXG4gICAgICAgICAgfSA9IGk7XG4gICAgICAgICAgZCA9IHtcbiAgICAgICAgICAgIGlkOiBjLFxuICAgICAgICAgICAgdHlwZTogcCxcbiAgICAgICAgICAgIGRhdGE6IGgsXG4gICAgICAgICAgICB2ZXJzaW9uOiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEllOiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaWQ6IGMsXG4gICAgICAgICAgICB0eXBlOiBwLFxuICAgICAgICAgICAgZWxlbWVudDogaCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBFLFxuICAgICAgICAgICAgcHJvcGVydGllczogXyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFIsXG4gICAgICAgICAgICBldmVudExpc3RlbmVyczogQVxuICAgICAgICAgIH0gPSBpO1xuICAgICAgICAgIGUgPT0gbnVsbCB8fCBlKF8pLCBlID09IG51bGwgfHwgZShBKTtcbiAgICAgICAgICBjb25zdCBUID0gW107XG4gICAgICAgICAgZCA9IHtcbiAgICAgICAgICAgIGlkOiBjLFxuICAgICAgICAgICAgdHlwZTogcCxcbiAgICAgICAgICAgIGVsZW1lbnQ6IGgsXG4gICAgICAgICAgICB2ZXJzaW9uOiAwLFxuICAgICAgICAgICAgY2hpbGRyZW46IFQsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIC4uLl9cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIC4uLlJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBldmVudExpc3RlbmVyczoge1xuICAgICAgICAgICAgICAuLi5BXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGogb2YgRSlcbiAgICAgICAgICAgIFQucHVzaChsKGosIGQpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBub2RlIHR5cGU6ICR7SlNPTi5zdHJpbmdpZnkoaSl9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcy5zZXQoZC5pZCwgZCksIG8uc2V0KGQuaWQsIG0uaWQpLCBkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmKGkpIHtcbiAgICAgIGlmIChzLmRlbGV0ZShpLmlkKSwgby5kZWxldGUoaS5pZCksIHQgJiYgKFwicHJvcGVydGllc1wiIGluIGkgJiYgdChpLnByb3BlcnRpZXMpLCBcImV2ZW50TGlzdGVuZXJzXCIgaW4gaSAmJiB0KGkuZXZlbnRMaXN0ZW5lcnMpKSwgXCJjaGlsZHJlblwiIGluIGkpXG4gICAgICAgIGZvciAoY29uc3QgbSBvZiBpLmNoaWxkcmVuKVxuICAgICAgICAgIGYobSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBGZXRjaGVzIHRoZSBsYXRlc3Qgc3RhdGUgb2YgYSByZW1vdGUgZWxlbWVudCB0aGF0IGhhcyBiZWVuXG4gICAqIHJlY2VpdmVkIGZyb20gdGhlIHJlbW90ZSBlbnZpcm9ubWVudC5cbiAgICpcbiAgICogQHBhcmFtIG5vZGUgVGhlIHJlbW90ZSBub2RlIHRvIGZldGNoLlxuICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgcmVtb3RlIG5vZGUsIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBub2RlIGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhlIHJlbW90ZSB0cmVlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQge1JlbW90ZVJlY2VpdmVyfSBmcm9tICdAcmVtb3RlLWRvbS9jb3JlL3JlY2VpdmVycyc7XG4gICAqXG4gICAqIGNvbnN0IHJlY2VpdmVyID0gbmV3IFJlbW90ZVJlY2VpdmVyKCk7XG4gICAqXG4gICAqIHJlY2VpdmVyLmdldChyZWNlaXZlci5yb290KSA9PT0gcmVjZWl2ZXIucm9vdDsgLy8gdHJ1ZVxuICAgKi9cbiAgZ2V0KHtcbiAgICBpZDogZVxuICB9KSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0YWNoZWQuZ2V0KGUpO1xuICB9XG4gIC8qKlxuICAgKiBMZXRzIHlvdSBkZWZpbmUgaG93IFtyZW1vdGUgbWV0aG9kc10oaHR0cHM6Ly9naXRodWIuY29tL1Nob3BpZnkvcmVtb3RlLWRvbS9ibG9iL21haW4vcGFja2FnZXMvY29yZSNyZW1vdGVtZXRob2RzKVxuICAgKiBhcmUgaW1wbGVtZW50ZWQgZm9yIGEgcGFydGljdWxhciBlbGVtZW50IGluIHRoZSB0cmVlLlxuICAgKlxuICAgKiBAcGFyYW0gbm9kZSBUaGUgcmVtb3RlIG5vZGUgdG8gc3Vic2NyaWJlIGZvciBjaGFuZ2VzLlxuICAgKiBAcGFyYW0gaW1wbGVtZW50YXRpb24gQSByZWNvcmQgY29udGFpbmluZyB0aGUgbWV0aG9kcyB0byBleHBvc2UgZm9yIHRoZSBwYXNzZWQgbm9kZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gSW4gdGhlIGhvc3QgZW52aXJvbm1lbnQ6XG4gICAqIGltcG9ydCB7UmVtb3RlUmVjZWl2ZXJ9IGZyb20gJ0ByZW1vdGUtZG9tL2NvcmUvcmVjZWl2ZXJzJztcbiAgICpcbiAgICogY29uc3QgcmVjZWl2ZXIgPSBuZXcgUmVtb3RlUmVjZWl2ZXIoKTtcbiAgICpcbiAgICogcmVjZWl2ZXIuaW1wbGVtZW50KHJlY2VpdmVyLnJvb3QsIHtcbiAgICogICBhbGVydChtZXNzYWdlKSB7XG4gICAqICAgICB3aW5kb3cuYWxlcnQobWVzc2FnZSk7XG4gICAqICAgfSxcbiAgICogfSk7XG4gICAqXG4gICAqIC8vIEluIHRoZSByZW1vdGUgZW52aXJvbm1lbnQ6XG4gICAqIGltcG9ydCB7UmVtb3RlUm9vdEVsZW1lbnR9IGZyb20gJ0ByZW1vdGUtZG9tL2NvcmUvZWxlbWVudHMnO1xuICAgKlxuICAgKiBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ3JlbW90ZS1yb290JywgUmVtb3RlUm9vdEVsZW1lbnQpO1xuICAgKlxuICAgKiBjb25zdCByb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVtb3RlLXJvb3QnKTtcbiAgICogcm9vdC5jb25uZWN0KHJlY2VpdmVyLmNvbm5lY3Rpb24pO1xuICAgKlxuICAgKiByb290LmNhbGxSZW1vdGVNZXRob2QoJ2FsZXJ0JywgJ0hlbGxvLCB3b3JsZCEnKTtcbiAgICovXG4gIGltcGxlbWVudCh7XG4gICAgaWQ6IGVcbiAgfSwgdCkge1xuICAgIHQgPT0gbnVsbCA/IHRoaXMuaW1wbGVtZW50YXRpb25zLmRlbGV0ZShlKSA6IHRoaXMuaW1wbGVtZW50YXRpb25zLnNldChlLCB0KTtcbiAgfVxuICAvKipcbiAgICogQWxsb3dzIHlvdSB0byBzdWJzY3JpYmUgdG8gY2hhbmdlcyBpbiBhIHJlbW90ZSBlbGVtZW50LiBUaGlzIGluY2x1ZGVzXG4gICAqIGNoYW5nZXMgdG8gdGhlIHJlbW90ZSBlbGVtZW504oCZcyBwcm9wZXJ0aWVzIGFuZCBsaXN0IG9mIGNoaWxkcmVuLCBidXRcbiAgICogbm90ZSB0aGF0IHlvdSB3aWxsIG5vdCByZWNlaXZlIHVwZGF0ZXMgZm9yIHByb3BlcnRpZXMgb3IgY2hpbGRyZW4gb2ZcbiAgICogX25lc3RlZF8gZWxlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlIFRoZSByZW1vdGUgbm9kZSB0byBzdWJzY3JpYmUgZm9yIGNoYW5nZXMuXG4gICAqIEBwYXJhbSBzdWJzY3JpYmVyIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cGRhdGVkIG5vZGUgb24gZWFjaCBjaGFuZ2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7UmVtb3RlUmVjZWl2ZXJ9IGZyb20gJ0ByZW1vdGUtZG9tL2NvcmUvcmVjZWl2ZXJzJztcbiAgICpcbiAgICogY29uc3QgYWJvcnQgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAqIGNvbnN0IHJlY2VpdmVyID0gbmV3IFJlbW90ZVJlY2VpdmVyKCk7XG4gICAqXG4gICAqIC8vIFN1YnNjcmliZSB0byBhbGwgY2hhbmdlcyBpbiB0aGUgdG9wLWxldmVsIGNoaWxkcmVuLCBhdHRhY2hlZFxuICAgKiAvLyBkaXJlY3RseSB0byB0aGUgcmVtb3RlIOKAnHJvb3TigJ0uXG4gICAqIHJlY2VpdmVyLnN1YnNjcmliZShcbiAgICogICByZWNlaXZlci5yb290LFxuICAgKiAgIChyb290KSA9PiB7XG4gICAqICAgICBjb25zb2xlLmxvZygnUm9vdCBjaGFuZ2VkIScsIHJvb3QpO1xuICAgKiAgIH0sXG4gICAqICAge3NpZ25hbDogYWJvcnQuc2lnbmFsfSxcbiAgICogKTtcbiAgICovXG4gIHN1YnNjcmliZSh7XG4gICAgaWQ6IGVcbiAgfSwgdCwge1xuICAgIHNpZ25hbDogblxuICB9ID0ge30pIHtcbiAgICBsZXQgcyA9IHRoaXMuc3Vic2NyaWJlcnMuZ2V0KGUpO1xuICAgIHMgPT0gbnVsbCAmJiAocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIHRoaXMuc3Vic2NyaWJlcnMuc2V0KGUsIHMpKSwgcy5hZGQodCksIG4gPT0gbnVsbCB8fCBuLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICBzLmRlbGV0ZSh0KSwgcy5zaXplID09PSAwICYmIHRoaXMuc3Vic2NyaWJlcnMuZGVsZXRlKGUpO1xuICAgIH0pO1xuICB9XG59XG5jb25zdCBFZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBYID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIENlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jbGFzcyB1dCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICByb290OiBlLFxuICAgIHJldGFpbjogdCxcbiAgICByZWxlYXNlOiBuLFxuICAgIGNhbGw6IHMsXG4gICAgY2FjaGU6IG9cbiAgfSA9IHt9KSB7XG4gICAgLyoqXG4gICAgICogVGhlIHJvb3QgZWxlbWVudCB0aGF0IHdpbGwgY29udGFpbiB0aGUgaG9zdCBpbXBsZW1lbnRhdGlvbnMgb2ZcbiAgICAgKiBhbGwgbm9kZXMgYXR0YWNoZWQgdG8gdGhlIHJlbW90ZSB0cmVlLiBUbyBjb25uZWN0IHRoZSByZWNlaXZlciB0b1xuICAgICAqIGEgbmV3IGVsZW1lbnQsIGNhbGwgdGhlIGBjb25uZWN0KClgIG1ldGhvZC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgdGhhdCBjYW4gc3luY2hyb25pemUgYSB0cmVlIG9mIGVsZW1lbnRzIGJldHdlZW4gdHdvIEphdmFTY3JpcHRcbiAgICAgKiBlbnZpcm9ubWVudHMuIFRoaXMgb2JqZWN0IGFjdHMgYXMgYSDigJx0aGluIHdhaXN04oCdLCBhbGxvd2luZyBmb3IgZWZmaWNpZW50XG4gICAgICogY29tbXVuaWNhdGlvbiBvZiBjaGFuZ2VzIGJldHdlZW4gYSDigJxyZW1vdGXigJ0gZW52aXJvbm1lbnQgKHVzdWFsbHksIGEgSmF2YVNjcmlwdFxuICAgICAqIHNhbmRib3gsIHN1Y2ggYXMgYW4gYGlmcmFtZWAgb3IgV2ViIFdvcmtlcikgYW5kIGEg4oCcaG9zdOKAnSBlbnZpcm9ubWVudFxuICAgICAqICh1c3VhbGx5LCBhIHRvcC1sZXZlbCBicm93c2VyIHBhZ2UpLlxuICAgICAqL1xuICAgIEwodGhpcywgXCJhdHRhY2hlZFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICB0aGlzLnJvb3QgPSBlID8/IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBjb25zdCB7XG4gICAgICBhdHRhY2hlZDogYVxuICAgIH0gPSB0aGlzLCB1ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBEZSh7XG4gICAgICBjYWxsOiAoaSwgbSwgLi4uZCkgPT4ge1xuICAgICAgICBjb25zdCBjID0gaSA9PT0gcSAmJiB0aGlzLnJvb3Qubm9kZVR5cGUgIT09IDExID8gdGhpcy5yb290IDogYS5nZXQoaSk7XG4gICAgICAgIHJldHVybiBzID8gcyhjLCBtLCAuLi5kKSA6IGNbbV0oLi4uZCk7XG4gICAgICB9LFxuICAgICAgaW5zZXJ0Q2hpbGQ6IChpLCBtLCBkKSA9PiB7XG4gICAgICAgIGNvbnN0IGMgPSBpID09PSBxID8gdGhpcy5yb290IDogYS5nZXQoaSksIHAgPSB1LmdldChpKTtcbiAgICAgICAgcCAmJiBjbGVhclRpbWVvdXQocCksIGMuaW5zZXJ0QmVmb3JlKGwobSksIGMuY2hpbGROb2Rlc1tkXSB8fCBudWxsKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVDaGlsZDogKGksIG0pID0+IHtcbiAgICAgICAgY29uc3QgYyA9IChpID09PSBxID8gdGhpcy5yb290IDogYS5nZXQoaSkpLmNoaWxkTm9kZXNbbV07XG4gICAgICAgIGlmIChjLnJlbW92ZSgpLCBvICE9IG51bGwgJiYgby5tYXhBZ2UpIHtcbiAgICAgICAgICBjb25zdCBwID0gdS5nZXQoaSk7XG4gICAgICAgICAgcCAmJiBjbGVhclRpbWVvdXQocCk7XG4gICAgICAgICAgY29uc3QgaCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZihjKTtcbiAgICAgICAgICB9LCBvLm1heEFnZSk7XG4gICAgICAgICAgdS5zZXQoaSwgaCk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGYoYyk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlUHJvcGVydHk6IChpLCBtLCBkLCBjID0gJCkgPT4ge1xuICAgICAgICBjb25zdCBwID0gYS5nZXQoaSk7XG4gICAgICAgIHQgPT0gbnVsbCB8fCB0KGQpO1xuICAgICAgICBjb25zdCBoID0gWC5nZXQocCksIEUgPSBoW21dO1xuICAgICAgICBoW21dID0gZCwgSihwLCBtLCBkLCBjKSwgbiA9PSBudWxsIHx8IG4oRSk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlVGV4dDogKGksIG0pID0+IHtcbiAgICAgICAgY29uc3QgZCA9IGEuZ2V0KGkpO1xuICAgICAgICBkLmRhdGEgPSBtO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGwoaSkge1xuICAgICAgY29uc3QgbSA9IGEuZ2V0KGkuaWQpO1xuICAgICAgaWYgKG0pIHJldHVybiBtO1xuICAgICAgbGV0IGQ7XG4gICAgICBzd2l0Y2ggKGkudHlwZSkge1xuICAgICAgICBjYXNlIEllOiB7XG4gICAgICAgICAgaWYgKGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGkuZWxlbWVudCksIGkucHJvcGVydGllcykge1xuICAgICAgICAgICAgWC5zZXQoZCwgaS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBPYmplY3Qua2V5cyhpLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHAgPSBpLnByb3BlcnRpZXNbY107XG4gICAgICAgICAgICAgIHQgPT0gbnVsbCB8fCB0KHApLCBKKGQsIGMsIHAsICQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgWC5zZXQoZCwge30pO1xuICAgICAgICAgIGlmIChpLmF0dHJpYnV0ZXMpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgT2JqZWN0LmtleXMoaS5hdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgICBjb25zdCBwID0gaS5hdHRyaWJ1dGVzW2NdO1xuICAgICAgICAgICAgICB0ID09IG51bGwgfHwgdChwKSwgSihkLCBjLCBwLCBkZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgaWYgKENlLnNldChkLCB7fSksIGkuZXZlbnRMaXN0ZW5lcnMpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgT2JqZWN0LmtleXMoaS5ldmVudExpc3RlbmVycykpIHtcbiAgICAgICAgICAgICAgY29uc3QgcCA9IGkuZXZlbnRMaXN0ZW5lcnNbY107XG4gICAgICAgICAgICAgIHQgPT0gbnVsbCB8fCB0KHApLCBKKGQsIGMsIHAsIHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgaS5jaGlsZHJlbilcbiAgICAgICAgICAgIGQuYXBwZW5kQ2hpbGQobChjKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBQZToge1xuICAgICAgICAgIGQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShpLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgT2U6IHtcbiAgICAgICAgICBkID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChpLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG5vZGUgdHlwZTogJHtKU09OLnN0cmluZ2lmeShpKX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBFZS5zZXQoZCwgaS5pZCksIGEuc2V0KGkuaWQsIGQpLCBkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmKGkpIHtcbiAgICAgIGNvbnN0IG0gPSBFZS5nZXQoaSk7XG4gICAgICBtICYmIGEuZGVsZXRlKG0pO1xuICAgICAgY29uc3QgZCA9IFguZ2V0KGkpO1xuICAgICAgaWYgKGQgJiYgbiAmJiBuKGQpLCBpIGluc3RhbmNlb2YgRWxlbWVudClcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGkuY2hpbGROb2RlcylcbiAgICAgICAgICBmKGMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29ubmVjdHMgdGhlIHJlY2VpdmVyIHRvIGEgbmV3IHJvb3QgZWxlbWVudC4gVGhlIHJlcHJlc2VudGF0aW9uIG9mXG4gICAqIGFueSBjaGlsZCBlbGVtZW50cyBvZiB0aGUgcmVtb3RlIHJvb3Qgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGlzIG5vZGVcbiAgICogYXMgY2hpbGRyZW4sIGFuZCB0aGUgYHJvb3RgIHByb3BlcnR5IHdpbGwgYmUgdXBkYXRlZCB0byBwb2ludCB0byB0aGVcbiAgICogbmV3IGVsZW1lbnQuXG4gICAqL1xuICBjb25uZWN0KGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5yb290O1xuICAgIHRoaXMucm9vdCA9IGUsIHQuY2hpbGROb2Rlcy5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBlLmFwcGVuZENoaWxkKG4pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyB0aGUgcmVjZWl2ZXIgZnJvbSBpdHMgY3VycmVudCByb290IGVsZW1lbnQuIEFueSBjdXJyZW50XG4gICAqIGNoaWxkcmVuIG9mIHRoZSByb290IGVsZW1lbnQgd2lsbCBiZSBtb3ZlZCB0byBhIGBEb2N1bWVudEZyYWdtZW50YFxuICAgKiBpbnN0ZWFkLCBzbyB0aGV5IGNhbiBiZSByZS1hdHRhY2hlZCB0byBhIG5ldyBlbGVtZW50IGxhdGVyLlxuICAgKi9cbiAgZGlzY29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5yb290Lm5vZGVUeXBlID09PSAxMSkgcmV0dXJuIHRoaXMucm9vdDtcbiAgICBjb25zdCBlID0gdGhpcy5yb290LCB0ID0gbmV3IERvY3VtZW50RnJhZ21lbnQoKTtcbiAgICByZXR1cm4gdGhpcy5yb290ID0gdCwgZS5jaGlsZE5vZGVzLmZvckVhY2goKG4pID0+IHtcbiAgICAgIHQuYXBwZW5kQ2hpbGQobik7XG4gICAgfSksIHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIEoociwgZSwgdCwgbikge1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlICQ6IHtcbiAgICAgIHJbZV0gPSB0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgZGU6IHtcbiAgICAgIHQgPT0gbnVsbCA/IHIucmVtb3ZlQXR0cmlidXRlKGUpIDogci5zZXRBdHRyaWJ1dGUoZSwgdCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSB1ZToge1xuICAgICAgY29uc3QgcyA9IENlLmdldChyKSwgbyA9IHMgPT0gbnVsbCA/IHZvaWQgMCA6IHNbZV07XG4gICAgICBpZiAobyAmJiByLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgbyksIHQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBhID0gKHUpID0+IHtcbiAgICAgICAgICB2YXIgZjtcbiAgICAgICAgICBpZiAodS50YXJnZXQgIT09IHIpIHJldHVybjtcbiAgICAgICAgICBjb25zdCBsID0gdCh1LmRldGFpbCk7XG4gICAgICAgICAgKGYgPSB1LnJlc29sdmUpID09IG51bGwgfHwgZi5jYWxsKHUsIGwpO1xuICAgICAgICB9O1xuICAgICAgICBzICYmIChzW2VdID0gYSksIHIuYWRkRXZlbnRMaXN0ZW5lcihlLCBhKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWUociwgZSkge1xuICBjb25zdCBbdCwgbl0gPSBBZSgoKSA9PiB7XG4gICAgY29uc3QgbyA9IGUuZ2V0KHIpO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogci5pZCxcbiAgICAgIHZlcnNpb246IG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8udmVyc2lvbixcbiAgICAgIHZhbHVlOiBvLFxuICAgICAgcmVjZWl2ZXI6IGVcbiAgICB9O1xuICB9KTtcbiAgbGV0IHMgPSB0LnZhbHVlO1xuICBpZiAodC5yZWNlaXZlciAhPT0gZSB8fCB0LmlkICE9PSByLmlkKSB7XG4gICAgY29uc3QgbyA9IGUuZ2V0KHIpO1xuICAgIHMgPSBvLCBuKHtcbiAgICAgIHJlY2VpdmVyOiBlLFxuICAgICAgaWQ6IHIuaWQsXG4gICAgICB2ZXJzaW9uOiBvID09IG51bGwgPyB2b2lkIDAgOiBvLnZlcnNpb24sXG4gICAgICB2YWx1ZTogc1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBYZShzKSwgSCgoKSA9PiB7XG4gICAgY29uc3QgbyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKSwgYSA9ICgpID0+IHtcbiAgICAgIG8uc2lnbmFsLmFib3J0ZWQgfHwgbigodSkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWQ6IGwsXG4gICAgICAgICAgdmVyc2lvbjogZixcbiAgICAgICAgICByZWNlaXZlcjogaVxuICAgICAgICB9ID0gdSwge1xuICAgICAgICAgIGlkOiBtXG4gICAgICAgIH0gPSByO1xuICAgICAgICBpZiAoaSAhPT0gZSB8fCBsICE9PSBtKVxuICAgICAgICAgIHJldHVybiB1O1xuICAgICAgICBjb25zdCBkID0gZS5nZXQociksIGMgPSBkID09IG51bGwgPyB2b2lkIDAgOiBkLnZlcnNpb247XG4gICAgICAgIHJldHVybiBmID09PSBjID8gdSA6IHtcbiAgICAgICAgICByZWNlaXZlcjogZSxcbiAgICAgICAgICB2YWx1ZTogZCxcbiAgICAgICAgICBpZDogbSxcbiAgICAgICAgICB2ZXJzaW9uOiBjXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBlLnN1YnNjcmliZShyLCBhLCB7XG4gICAgICBzaWduYWw6IG8uc2lnbmFsXG4gICAgfSksIGEoKSwgKCkgPT4ge1xuICAgICAgby5hYm9ydCgpO1xuICAgIH07XG4gIH0sIFtlLCByLmlkXSksIHM7XG59XG5mdW5jdGlvbiBtdCh7XG4gIHJlbW90ZTogcixcbiAgcmVjZWl2ZXI6IGVcbn0pIHtcbiAgY29uc3QgdCA9IG1lKHIsIGUpO1xuICByZXR1cm4gdCA/IC8qIEBfX1BVUkVfXyAqLyB2KHRlLCB7XG4gICAgY2hpbGRyZW46IHQuZGF0YVxuICB9KSA6IG51bGw7XG59XG5mdW5jdGlvbiBzZShyLCB7XG4gIHJlY2VpdmVyOiBlLFxuICBjb21wb25lbnRzOiB0XG59KSB7XG4gIHN3aXRjaCAoci50eXBlKSB7XG4gICAgY2FzZSAxOiB7XG4gICAgICBjb25zdCBuID0gdC5nZXQoci5lbGVtZW50KTtcbiAgICAgIGlmIChuID09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gY29tcG9uZW50IGZvdW5kIGZvciByZW1vdGUgZWxlbWVudDogJHtyLmVsZW1lbnR9YCk7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIHYobiwge1xuICAgICAgICBlbGVtZW50OiByLFxuICAgICAgICByZWNlaXZlcjogZSxcbiAgICAgICAgY29tcG9uZW50czogdFxuICAgICAgfSwgci5pZCk7XG4gICAgfVxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gdihtdCwge1xuICAgICAgICByZW1vdGU6IHIsXG4gICAgICAgIHJlY2VpdmVyOiBlXG4gICAgICB9LCByLmlkKTtcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHJlbW90ZSBub2RlIHR5cGU6ICR7U3RyaW5nKHIpfWApO1xuICB9XG59XG5mdW5jdGlvbiBwdChyLCBlKSB7XG4gIGlmICghcikgcmV0dXJuO1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW46IHQsXG4gICAgcHJvcGVydGllczogbixcbiAgICBhdHRyaWJ1dGVzOiBzLFxuICAgIGV2ZW50TGlzdGVuZXJzOiBvXG4gIH0gPSByLCBhID0gW10sIHUgPSB7XG4gICAgLi4ubixcbiAgICAuLi5zLFxuICAgIGNoaWxkcmVuOiBhXG4gIH07XG4gIGlmIChlLmV2ZW50UHJvcHMpXG4gICAgZm9yIChjb25zdCBbbCwgZl0gb2YgT2JqZWN0LmVudHJpZXMoZS5ldmVudFByb3BzKSkge1xuICAgICAgY29uc3QgaSA9IGYgPT0gbnVsbCA/IHZvaWQgMCA6IGYuZXZlbnQ7XG4gICAgICBpZiAoaSA9PSBudWxsKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IG0gPSBvW2ldO1xuICAgICAgbSAmJiAodVtsXSA9IGJlKG0pKTtcbiAgICB9XG4gIGVsc2VcbiAgICBmb3IgKGNvbnN0IFtsLCBmXSBvZiBPYmplY3QuZW50cmllcyhvKSlcbiAgICAgIHVbYG9uJHtsWzBdLnRvVXBwZXJDYXNlKCl9JHtsLnNsaWNlKDEpfWBdID0gYmUoZik7XG4gIGZvciAoY29uc3QgbCBvZiB0KVxuICAgIGlmIChsLnR5cGUgPT09IDEgJiYgdHlwZW9mIGwuYXR0cmlidXRlcy5zbG90ID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGYgPSBsLmF0dHJpYnV0ZXMuc2xvdCwgaSA9IHNlKGwsIGUpO1xuICAgICAgdVtmXSA9IHVbZl0gPyAvKiBAX19QVVJFX18gKi8gY2UodGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFt1W2ZdLCBpXVxuICAgICAgfSkgOiBpO1xuICAgIH0gZWxzZVxuICAgICAgYS5wdXNoKHNlKGwsIGUpKTtcbiAgcmV0dXJuIHU7XG59XG5mdW5jdGlvbiBiZShyKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi50KSB7XG4gICAgaWYgKHQubGVuZ3RoID09PSAxICYmIHRbMF0gaW5zdGFuY2VvZiBFdmVudCkge1xuICAgICAgY29uc3QgbiA9IHRbMF07XG4gICAgICByZXR1cm4gbi50YXJnZXQgIT09IG4uY3VycmVudFRhcmdldCA/IHZvaWQgMCA6IFwiZGV0YWlsXCIgaW4gbiA/IHIobi5kZXRhaWwpIDogcigpO1xuICAgIH1cbiAgICByZXR1cm4gciguLi50KTtcbiAgfTtcbn1cbmNvbnN0IGZ0ID0gU3ltYm9sLmZvcihcInJlbW90ZS1kb20uZWxlbWVudFwiKSwgaHQgPSBTeW1ib2wuZm9yKFwicmVtb3RlLWRvbS5lbGVtZW50LmF0dGFjaGVkXCIpO1xuZnVuY3Rpb24gX3Qociwge1xuICBuYW1lOiBlLFxuICBldmVudFByb3BzOiB0XG59ID0ge30pIHtcbiAgY29uc3QgbiA9IC8qIEBfX1BVUkVfXyAqLyBKZShmdW5jdGlvbih7XG4gICAgZWxlbWVudDogbyxcbiAgICByZWNlaXZlcjogYSxcbiAgICBjb21wb25lbnRzOiB1XG4gIH0pIHtcbiAgICBjb25zdCBsID0gQigpLCBmID0gbWUobywgYSksIGkgPSBmID8/IG8sIG0gPSBpLmlkLCBkID0gcHQoaSwge1xuICAgICAgcmVjZWl2ZXI6IGEsXG4gICAgICBjb21wb25lbnRzOiB1LFxuICAgICAgZXZlbnRQcm9wczogdFxuICAgIH0pO1xuICAgIGlmIChkW2Z0XSA9IGksIGRbaHRdID0gZiAhPSBudWxsLCBsLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgY29uc3QgYyA9IHtcbiAgICAgICAgaWQ6IG0sXG4gICAgICAgIHJlY2VpdmVyOiBhXG4gICAgICB9O1xuICAgICAgYy5pbnN0YW5jZVJlZiA9IEV0KGMpLCBsLmN1cnJlbnQgPSBjO1xuICAgIH1cbiAgICByZXR1cm4gbC5jdXJyZW50LmlkID0gbSwgbC5jdXJyZW50LnJlY2VpdmVyID0gYSwgSCgoKSA9PiB7XG4gICAgICB2YXIgcDtcbiAgICAgIGNvbnN0IGMgPSB7XG4gICAgICAgIGlkOiBtXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGEuaW1wbGVtZW50KGMsIChwID0gbC5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogcC5pbnN0YW5jZVJlZi5jdXJyZW50KSwgKCkgPT4ge1xuICAgICAgICBhLmltcGxlbWVudChjLCBudWxsKTtcbiAgICAgIH07XG4gICAgfSwgW20sIGFdKSwgLyogQF9fUFVSRV9fICovIHYociwge1xuICAgICAgcmVmOiBsLmN1cnJlbnQuaW5zdGFuY2VSZWYsXG4gICAgICAuLi5kXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gbi5kaXNwbGF5TmFtZSA9IGUgPz8gYFJlbW90ZUNvbXBvbmVudFJlbmRlcmVyKCR7ci5kaXNwbGF5TmFtZSA/PyByLm5hbWUgPz8gXCJDb21wb25lbnRcIn0pYCwgbjtcbn1cbmZ1bmN0aW9uIEV0KHIpIHtcbiAgbGV0IGUgPSBudWxsO1xuICByZXR1cm4ge1xuICAgIGdldCBjdXJyZW50KCkge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfSxcbiAgICBzZXQgY3VycmVudCh0KSB7XG4gICAgICBlID0gdCwgci5yZWNlaXZlci5pbXBsZW1lbnQociwgdCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYnQocikge1xuICBjb25zdCB7XG4gICAgcmVjZWl2ZXI6IGVcbiAgfSA9IHIsIHtcbiAgICBjaGlsZHJlbjogdFxuICB9ID0gbWUoZS5yb290LCBlKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB2KHRlLCB7XG4gICAgY2hpbGRyZW46IHQubWFwKChuKSA9PiBzZShuLCByKSlcbiAgfSk7XG59XG5jb25zdCB2dCA9IGA8IURPQ1RZUEUgaHRtbD5cbjxodG1sPlxuPGhlYWQ+XG4gIDxtZXRhIGNoYXJzZXQ9XCJ1dGYtOFwiPlxuPC9oZWFkPlxuPGJvZHk+XG4gIDxkaXYgaWQ9XCJyb290XCI+PC9kaXY+XG4gIDxzY3JpcHQ+XG5cInVzZSBzdHJpY3RcIjtcbigoKSA9PiB7XG4gIHZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gIHZhciBfX3R5cGVFcnJvciA9IChtc2cpID0+IHtcbiAgICB0aHJvdyBUeXBlRXJyb3IobXNnKTtcbiAgfTtcbiAgdmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xuICB2YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHZhciBfX2FjY2Vzc0NoZWNrID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IG1lbWJlci5oYXMob2JqKSB8fCBfX3R5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG4gIHZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4gKF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIiksIGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiBtZW1iZXIuZ2V0KG9iaikpO1xuICB2YXIgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4gbWVtYmVyLmhhcyhvYmopID8gX190eXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpIDogbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG4gIHZhciBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIiksIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKSwgdmFsdWUpO1xuICB2YXIgX19wcml2YXRlTWV0aG9kID0gKG9iaiwgbWVtYmVyLCBtZXRob2QpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcImFjY2VzcyBwcml2YXRlIG1ldGhvZFwiKSwgbWV0aG9kKTtcblxuICAvLyAuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlbW90ZS1kb20rY29yZUAxLjguMV9AcHJlYWN0K3NpZ25hbHMtY29yZUAxLjEwLjAvbm9kZV9tb2R1bGVzL0ByZW1vdGUtZG9tL2NvcmUvYnVpbGQvZXNtL2VsZW1lbnRzL1JlbW90ZUV2ZW50Lm1qc1xuICB2YXIgUmVtb3RlRXZlbnQgPSBjbGFzcyBleHRlbmRzIEN1c3RvbUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCB2YWx1ZSByZWNlaXZlZCBmcm9tIGEgXFxgcmVzcG9uZFdpdGgoKVxcYCBjYWxsLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIHRoZSBcXGByZXNwb25zZVxcYCB2YWx1ZSB0byBiZSBzZW50IGFzIHRoZSByZXR1cm4gdmFsdWUgZm9yXG4gICAgICogdGhlIHJlbW90ZSBwcm9wZXJ0eSBmdW5jdGlvbiB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50LlxuICAgICAqL1xuICAgIHJlc3BvbmRXaXRoKHJlc3BvbnNlKSB7XG4gICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgfVxuICB9O1xuXG4gIC8vIC4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AcmVtb3RlLWRvbStjb3JlQDEuOC4xX0BwcmVhY3Qrc2lnbmFscy1jb3JlQDEuMTAuMC9ub2RlX21vZHVsZXMvQHJlbW90ZS1kb20vY29yZS9idWlsZC9lc20vY29uc3RhbnRzLm1qc1xuICB2YXIgTVVUQVRJT05fVFlQRV9JTlNFUlRfQ0hJTEQgPSAwO1xuICB2YXIgTVVUQVRJT05fVFlQRV9SRU1PVkVfQ0hJTEQgPSAxO1xuICB2YXIgTVVUQVRJT05fVFlQRV9VUERBVEVfVEVYVCA9IDI7XG4gIHZhciBNVVRBVElPTl9UWVBFX1VQREFURV9QUk9QRVJUWSA9IDM7XG4gIHZhciBVUERBVEVfUFJPUEVSVFlfVFlQRV9QUk9QRVJUWSA9IDE7XG4gIHZhciBVUERBVEVfUFJPUEVSVFlfVFlQRV9BVFRSSUJVVEUgPSAyO1xuICB2YXIgVVBEQVRFX1BST1BFUlRZX1RZUEVfRVZFTlRfTElTVEVORVIgPSAzO1xuICB2YXIgUk9PVF9JRCA9IFwiflwiO1xuXG4gIC8vIC4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AcmVtb3RlLWRvbStjb3JlQDEuOC4xX0BwcmVhY3Qrc2lnbmFscy1jb3JlQDEuMTAuMC9ub2RlX21vZHVsZXMvQHJlbW90ZS1kb20vY29yZS9idWlsZC9lc20vZWxlbWVudHMvaW50ZXJuYWxzLm1qc1xuICB2YXIgUkVNT1RFX0NPTk5FQ1RJT05TID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIHZhciBSRU1PVEVfSURTID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIHZhciBpZCA9IDA7XG4gIGZ1bmN0aW9uIHJlbW90ZUlkKG5vZGUpIHtcbiAgICBsZXQgcmVtb3RlSUQgPSBSRU1PVEVfSURTLmdldChub2RlKTtcbiAgICBpZiAocmVtb3RlSUQgPT0gbnVsbCkge1xuICAgICAgcmVtb3RlSUQgPSBTdHJpbmcoaWQrKyk7XG4gICAgICBSRU1PVEVfSURTLnNldChub2RlLCByZW1vdGVJRCk7XG4gICAgfVxuICAgIHJldHVybiByZW1vdGVJRDtcbiAgfVxuICB2YXIgUkVNT1RFX1BST1BFUlRJRVMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgZnVuY3Rpb24gcmVtb3RlUHJvcGVydGllcyhub2RlKSB7XG4gICAgcmV0dXJuIFJFTU9URV9QUk9QRVJUSUVTLmdldChub2RlKTtcbiAgfVxuICB2YXIgUkVNT1RFX0FUVFJJQlVURVMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgZnVuY3Rpb24gcmVtb3RlQXR0cmlidXRlcyhub2RlKSB7XG4gICAgbGV0IGF0dHJpYnV0ZXMgPSBSRU1PVEVfQVRUUklCVVRFUy5nZXQobm9kZSk7XG4gICAgaWYgKGF0dHJpYnV0ZXMgIT0gbnVsbCkgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHx8IG5vZGUudGFnTmFtZS5pbmNsdWRlcyhcIi1cIikpIHJldHVybiB2b2lkIDA7XG4gICAgYXR0cmlidXRlcyA9IHt9O1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHZhbHVlXG4gICAgfSBvZiBub2RlLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gIH1cbiAgdmFyIFJFTU9URV9FVkVOVF9MSVNURU5FUlMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgZnVuY3Rpb24gcmVtb3RlRXZlbnRMaXN0ZW5lcnMobm9kZSkge1xuICAgIHJldHVybiBSRU1PVEVfRVZFTlRfTElTVEVORVJTLmdldChub2RlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVSZW1vdGVFbGVtZW50UHJvcGVydHkobm9kZSwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgbGV0IHByb3BlcnRpZXMgPSBSRU1PVEVfUFJPUEVSVElFUy5nZXQobm9kZSk7XG4gICAgaWYgKHByb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgUkVNT1RFX1BST1BFUlRJRVMuc2V0KG5vZGUsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBpZiAocHJvcGVydGllc1twcm9wZXJ0eV0gPT09IHZhbHVlKSByZXR1cm47XG4gICAgcHJvcGVydGllc1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICBjb25zdCBjb25uZWN0aW9uID0gUkVNT1RFX0NPTk5FQ1RJT05TLmdldChub2RlKTtcbiAgICBpZiAoY29ubmVjdGlvbiA9PSBudWxsKSByZXR1cm47XG4gICAgY29ubmVjdGlvbi5tdXRhdGUoW1tNVVRBVElPTl9UWVBFX1VQREFURV9QUk9QRVJUWSwgcmVtb3RlSWQobm9kZSksIHByb3BlcnR5LCB2YWx1ZSwgVVBEQVRFX1BST1BFUlRZX1RZUEVfUFJPUEVSVFldXSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUmVtb3RlRWxlbWVudEF0dHJpYnV0ZShub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgbGV0IGF0dHJpYnV0ZXMgPSBSRU1PVEVfQVRUUklCVVRFUy5nZXQobm9kZSk7XG4gICAgaWYgKGF0dHJpYnV0ZXMgPT0gbnVsbCkge1xuICAgICAgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgUkVNT1RFX0FUVFJJQlVURVMuc2V0KG5vZGUsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlc1thdHRyaWJ1dGVdID09PSB2YWx1ZSkgcmV0dXJuO1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWxldGUgYXR0cmlidXRlc1thdHRyaWJ1dGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICBjb25zdCBjb25uZWN0aW9uID0gUkVNT1RFX0NPTk5FQ1RJT05TLmdldChub2RlKTtcbiAgICBpZiAoY29ubmVjdGlvbiA9PSBudWxsKSByZXR1cm47XG4gICAgY29ubmVjdGlvbi5tdXRhdGUoW1tNVVRBVElPTl9UWVBFX1VQREFURV9QUk9QRVJUWSwgcmVtb3RlSWQobm9kZSksIGF0dHJpYnV0ZSwgdmFsdWUsIFVQREFURV9QUk9QRVJUWV9UWVBFX0FUVFJJQlVURV1dKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVSZW1vdGVFbGVtZW50RXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgICBsZXQgZXZlbnRMaXN0ZW5lcnMgPSBSRU1PVEVfRVZFTlRfTElTVEVORVJTLmdldChub2RlKTtcbiAgICBpZiAoZXZlbnRMaXN0ZW5lcnMgPT0gbnVsbCkge1xuICAgICAgZXZlbnRMaXN0ZW5lcnMgPSB7fTtcbiAgICAgIFJFTU9URV9FVkVOVF9MSVNURU5FUlMuc2V0KG5vZGUsIGV2ZW50TGlzdGVuZXJzKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50TGlzdGVuZXJzW2V2ZW50XSA9PT0gbGlzdGVuZXIpIHJldHVybjtcbiAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkge1xuICAgICAgZGVsZXRlIGV2ZW50TGlzdGVuZXJzW2V2ZW50XTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnRMaXN0ZW5lcnNbZXZlbnRdID0gbGlzdGVuZXI7XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBSRU1PVEVfQ09OTkVDVElPTlMuZ2V0KG5vZGUpO1xuICAgIGlmIChjb25uZWN0aW9uID09IG51bGwpIHJldHVybjtcbiAgICBjb25uZWN0aW9uLm11dGF0ZShbW01VVEFUSU9OX1RZUEVfVVBEQVRFX1BST1BFUlRZLCByZW1vdGVJZChub2RlKSwgZXZlbnQsIGxpc3RlbmVyLCBVUERBVEVfUFJPUEVSVFlfVFlQRV9FVkVOVF9MSVNURU5FUl1dKTtcbiAgfVxuICBmdW5jdGlvbiBjb25uZWN0UmVtb3RlTm9kZShub2RlLCBjb25uZWN0aW9uKSB7XG4gICAgY29uc3QgZXhpc3RpbmdDb25uZWN0aW9uID0gUkVNT1RFX0NPTk5FQ1RJT05TLmdldChub2RlKTtcbiAgICBpZiAoZXhpc3RpbmdDb25uZWN0aW9uID09PSBjb25uZWN0aW9uKSByZXR1cm47XG4gICAgUkVNT1RFX0NPTk5FQ1RJT05TLnNldChub2RlLCBjb25uZWN0aW9uKTtcbiAgICBpZiAobm9kZS5jaGlsZE5vZGVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25uZWN0UmVtb3RlTm9kZShub2RlLmNoaWxkTm9kZXNbaV0sIGNvbm5lY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkaXNjb25uZWN0UmVtb3RlTm9kZShub2RlKSB7XG4gICAgY29uc3QgZXhpc3RpbmdDb25uZWN0aW9uID0gUkVNT1RFX0NPTk5FQ1RJT05TLmdldChub2RlKTtcbiAgICBpZiAoZXhpc3RpbmdDb25uZWN0aW9uID09IG51bGwpIHJldHVybjtcbiAgICBSRU1PVEVfQ09OTkVDVElPTlMuZGVsZXRlKG5vZGUpO1xuICAgIGlmIChub2RlLmNoaWxkTm9kZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRpc2Nvbm5lY3RSZW1vdGVOb2RlKG5vZGUuY2hpbGROb2Rlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZVJlbW90ZU5vZGUobm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5vZGVUeXBlXG4gICAgfSA9IG5vZGU7XG4gICAgc3dpdGNoIChub2RlVHlwZSkge1xuICAgICAgLy8gRWxlbWVudFxuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IHJlbW90ZUlkKG5vZGUpLFxuICAgICAgICAgIHR5cGU6IG5vZGVUeXBlLFxuICAgICAgICAgIGVsZW1lbnQ6IG5vZGUubG9jYWxOYW1lLFxuICAgICAgICAgIHByb3BlcnRpZXM6IGNsb25lTWF5YmVPYmplY3QocmVtb3RlUHJvcGVydGllcyhub2RlKSksXG4gICAgICAgICAgYXR0cmlidXRlczogY2xvbmVNYXliZU9iamVjdChyZW1vdGVBdHRyaWJ1dGVzKG5vZGUpKSxcbiAgICAgICAgICBldmVudExpc3RlbmVyczogY2xvbmVNYXliZU9iamVjdChyZW1vdGVFdmVudExpc3RlbmVycyhub2RlKSksXG4gICAgICAgICAgY2hpbGRyZW46IEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKS5tYXAoc2VyaWFsaXplUmVtb3RlTm9kZSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8vIFRleHROb2RlXG4gICAgICBjYXNlIDM6XG4gICAgICAvLyBDb21tZW50XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgIGNhc2UgODoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiByZW1vdGVJZChub2RlKSxcbiAgICAgICAgICB0eXBlOiBub2RlVHlwZSxcbiAgICAgICAgICBkYXRhOiBub2RlLmRhdGFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcYENhbm5vdCBzZXJpYWxpemUgbm9kZSBvZiB0eXBlIFxcJHtub2RlLm5vZGVUeXBlfSAoXFwke3R5cGVvZiBub2RlLm5vZGVUeXBlfSlcXGApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjbG9uZU1heWJlT2JqZWN0KG1heWJlT2JqZWN0KSB7XG4gICAgcmV0dXJuIG1heWJlT2JqZWN0ID8ge1xuICAgICAgLi4ubWF5YmVPYmplY3RcbiAgICB9IDogdm9pZCAwO1xuICB9XG4gIGZ1bmN0aW9uIGNhbGxSZW1vdGVFbGVtZW50TWV0aG9kKG5vZGUsIG1ldGhvZCwgLi4uYXJncykge1xuICAgIGNvbnN0IGlkMiA9IFJFTU9URV9JRFMuZ2V0KG5vZGUpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBSRU1PVEVfQ09OTkVDVElPTlMuZ2V0KG5vZGUpO1xuICAgIGlmIChpZDIgPT0gbnVsbCB8fCBjb25uZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcXGBDYW5ub3QgY2FsbCBtZXRob2QgXFwke21ldGhvZH0gb24gYW4gdW5jb25uZWN0ZWQgbm9kZVxcYCk7XG4gICAgfVxuICAgIHJldHVybiBjb25uZWN0aW9uLmNhbGwoaWQyLCBtZXRob2QsIC4uLmFyZ3MpO1xuICB9XG5cbiAgLy8gLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0ByZW1vdGUtZG9tK2NvcmVAMS44LjFfQHByZWFjdCtzaWduYWxzLWNvcmVAMS4xMC4wL25vZGVfbW9kdWxlcy9AcmVtb3RlLWRvbS9jb3JlL2J1aWxkL2VzbS9lbGVtZW50cy9SZW1vdGVFbGVtZW50Lm1qc1xuICB2YXIgRU1QVFlfREVGSU5JVElPTiA9IE9iamVjdC5mcmVlemUoe30pO1xuICB2YXIgUmVtb3RlRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUoKS5fX29ic2VydmVkQXR0cmlidXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJlc29sdmVkIHByb3BlcnR5IGRlZmluaXRpb25zIGZvciB0aGlzIHJlbW90ZSBlbGVtZW50LlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgcmVtb3RlUHJvcGVydHlEZWZpbml0aW9ucygpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKCkuX19yZW1vdGVQcm9wZXJ0eURlZmluaXRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzb2x2ZWQgYXR0cmlidXRlIGRlZmluaXRpb25zIGZvciB0aGlzIHJlbW90ZSBlbGVtZW50LlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgcmVtb3RlQXR0cmlidXRlRGVmaW5pdGlvbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZSgpLl9fcmVtb3RlQXR0cmlidXRlRGVmaW5pdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByZXNvbHZlZCBldmVudCBsaXN0ZW5lciBkZWZpbml0aW9ucyBmb3IgdGhpcyByZW1vdGUgZWxlbWVudC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IHJlbW90ZUV2ZW50RGVmaW5pdGlvbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZSgpLl9fcmVtb3RlRXZlbnREZWZpbml0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJlc29sdmVkIHNsb3QgZGVmaW5pdGlvbnMgZm9yIHRoaXMgcmVtb3RlIGVsZW1lbnQuXG4gICAgICovXG4gICAgc3RhdGljIGdldCByZW1vdGVTbG90RGVmaW5pdGlvbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZSgpLl9fcmVtb3RlU2xvdERlZmluaXRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGRlZmluaXRpb24gZm9yIGEgcHJvcGVydHkgdGhhdCB3aWxsIGJlIHN5bmNocm9uaXplZCBiZXR3ZWVuXG4gICAgICogdGhpcyByZW1vdGUgZWxlbWVudCBhbmQgaXRzIGhvc3QgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVByb3BlcnR5KG5hbWUsIGRlZmluaXRpb24pIHtcbiAgICAgIHNhdmVSZW1vdGVQcm9wZXJ0eShuYW1lLCBkZWZpbml0aW9uLCB0aGlzLm9ic2VydmVkQXR0cmlidXRlcywgdGhpcy5yZW1vdGVQcm9wZXJ0eURlZmluaXRpb25zLCB0aGlzLl9fYXR0cmlidXRlVG9Qcm9wZXJ0eU1hcCwgdGhpcy5fX2V2ZW50VG9Qcm9wZXJ0eU1hcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN1bWVzIGFsbCB0aGUgc3RhdGljIG1lbWJlcnMgZGVmaW5lZCBvbiB0aGUgY2xhc3MgYW5kIGNvbnZlcnRzIHRoZW1cbiAgICAgKiBpbnRvIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiB1c2VkIHRvIGhhbmRsZSBwcm9wZXJ0aWVzLCBhdHRyaWJ1dGVzLFxuICAgICAqIGFuZCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgc3RhdGljIGZpbmFsaXplKCkge1xuICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoXCJfX2ZpbmFsaXplZFwiKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMuX19maW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzbG90dGFibGUsXG4gICAgICAgIHJlbW90ZVNsb3RzLFxuICAgICAgICByZW1vdGVQcm9wZXJ0aWVzOiByZW1vdGVQcm9wZXJ0aWVzMixcbiAgICAgICAgcmVtb3RlQXR0cmlidXRlczogcmVtb3RlQXR0cmlidXRlczIsXG4gICAgICAgIHJlbW90ZUV2ZW50cyxcbiAgICAgICAgcmVtb3RlTWV0aG9kc1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCBTdXBlckNvbnN0cnVjdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpO1xuICAgICAgY29uc3Qgb2JzZXJ2ZWRBdHRyaWJ1dGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGlmIChzbG90dGFibGUpIG9ic2VydmVkQXR0cmlidXRlcy5hZGQoXCJzbG90XCIpO1xuICAgICAgY29uc3QgYXR0cmlidXRlVG9Qcm9wZXJ0eU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBldmVudFRvUHJvcGVydHlNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgcmVtb3RlU2xvdERlZmluaXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IHJlbW90ZVByb3BlcnR5RGVmaW5pdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgcmVtb3RlQXR0cmlidXRlRGVmaW5pdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgcmVtb3RlRXZlbnREZWZpbml0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBpZiAodHlwZW9mIFN1cGVyQ29uc3RydWN0b3IuZmluYWxpemUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBTdXBlckNvbnN0cnVjdG9yLmZpbmFsaXplKCk7XG4gICAgICAgIFN1cGVyQ29uc3RydWN0b3Iub2JzZXJ2ZWRBdHRyaWJ1dGVzLmZvckVhY2goKGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgICAgIG9ic2VydmVkQXR0cmlidXRlcy5hZGQoYXR0cmlidXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFN1cGVyQ29uc3RydWN0b3IucmVtb3RlUHJvcGVydHlEZWZpbml0aW9ucy5mb3JFYWNoKChkZWZpbml0aW9uLCBwcm9wZXJ0eSkgPT4ge1xuICAgICAgICAgIHJlbW90ZVByb3BlcnR5RGVmaW5pdGlvbnMuc2V0KHByb3BlcnR5LCBkZWZpbml0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFN1cGVyQ29uc3RydWN0b3IucmVtb3RlQXR0cmlidXRlRGVmaW5pdGlvbnMuZm9yRWFjaCgoZGVmaW5pdGlvbiwgZXZlbnQpID0+IHtcbiAgICAgICAgICByZW1vdGVBdHRyaWJ1dGVEZWZpbml0aW9ucy5zZXQoZXZlbnQsIGRlZmluaXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgU3VwZXJDb25zdHJ1Y3Rvci5yZW1vdGVFdmVudERlZmluaXRpb25zLmZvckVhY2goKGRlZmluaXRpb24sIGV2ZW50KSA9PiB7XG4gICAgICAgICAgcmVtb3RlRXZlbnREZWZpbml0aW9ucy5zZXQoZXZlbnQsIGRlZmluaXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgU3VwZXJDb25zdHJ1Y3Rvci5yZW1vdGVTbG90RGVmaW5pdGlvbnMuZm9yRWFjaCgoZGVmaW5pdGlvbiwgc2xvdCkgPT4ge1xuICAgICAgICAgIHJlbW90ZVNsb3REZWZpbml0aW9ucy5zZXQoc2xvdCwgZGVmaW5pdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHJlbW90ZVNsb3RzICE9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc2xvdE5hbWVzID0gQXJyYXkuaXNBcnJheShyZW1vdGVTbG90cykgPyByZW1vdGVTbG90cyA6IE9iamVjdC5rZXlzKHJlbW90ZVNsb3RzKTtcbiAgICAgICAgc2xvdE5hbWVzLmZvckVhY2goKHNsb3ROYW1lKSA9PiB7XG4gICAgICAgICAgcmVtb3RlU2xvdERlZmluaXRpb25zLnNldChzbG90TmFtZSwgRU1QVFlfREVGSU5JVElPTik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHJlbW90ZVByb3BlcnRpZXMyICE9IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVtb3RlUHJvcGVydGllczIpKSB7XG4gICAgICAgICAgcmVtb3RlUHJvcGVydGllczIuZm9yRWFjaCgocHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICAgICAgICBzYXZlUmVtb3RlUHJvcGVydHkocHJvcGVydHlOYW1lLCB2b2lkIDAsIG9ic2VydmVkQXR0cmlidXRlcywgcmVtb3RlUHJvcGVydHlEZWZpbml0aW9ucywgYXR0cmlidXRlVG9Qcm9wZXJ0eU1hcCwgZXZlbnRUb1Byb3BlcnR5TWFwKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhyZW1vdGVQcm9wZXJ0aWVzMikuZm9yRWFjaCgocHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICAgICAgICBzYXZlUmVtb3RlUHJvcGVydHkocHJvcGVydHlOYW1lLCByZW1vdGVQcm9wZXJ0aWVzMltwcm9wZXJ0eU5hbWVdLCBvYnNlcnZlZEF0dHJpYnV0ZXMsIHJlbW90ZVByb3BlcnR5RGVmaW5pdGlvbnMsIGF0dHJpYnV0ZVRvUHJvcGVydHlNYXAsIGV2ZW50VG9Qcm9wZXJ0eU1hcCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZW1vdGVBdHRyaWJ1dGVzMiAhPSBudWxsKSB7XG4gICAgICAgIHJlbW90ZUF0dHJpYnV0ZXMyLmZvckVhY2goKGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgICAgIHJlbW90ZUF0dHJpYnV0ZURlZmluaXRpb25zLnNldChhdHRyaWJ1dGUsIEVNUFRZX0RFRklOSVRJT04pO1xuICAgICAgICAgIG9ic2VydmVkQXR0cmlidXRlcy5hZGQoYXR0cmlidXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAocmVtb3RlRXZlbnRzICE9IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVtb3RlRXZlbnRzKSkge1xuICAgICAgICAgIHJlbW90ZUV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgICAgICAgcmVtb3RlRXZlbnREZWZpbml0aW9ucy5zZXQoZXZlbnQsIEVNUFRZX0RFRklOSVRJT04pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHJlbW90ZUV2ZW50cykuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHJlbW90ZUV2ZW50RGVmaW5pdGlvbnMuc2V0KGV2ZW50LCByZW1vdGVFdmVudHNbZXZlbnRdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlbW90ZU1ldGhvZHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZW1vdGVNZXRob2RzKSkge1xuICAgICAgICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIHJlbW90ZU1ldGhvZHMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGxSZW1vdGVNZXRob2QobWV0aG9kLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcmVtb3RlTWV0aG9kcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgX19vYnNlcnZlZEF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICB2YWx1ZTogWy4uLm9ic2VydmVkQXR0cmlidXRlc10sXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgX19yZW1vdGVTbG90RGVmaW5pdGlvbnM6IHtcbiAgICAgICAgICB2YWx1ZTogcmVtb3RlU2xvdERlZmluaXRpb25zLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIF9fcmVtb3RlUHJvcGVydHlEZWZpbml0aW9uczoge1xuICAgICAgICAgIHZhbHVlOiByZW1vdGVQcm9wZXJ0eURlZmluaXRpb25zLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIF9fcmVtb3RlQXR0cmlidXRlRGVmaW5pdGlvbnM6IHtcbiAgICAgICAgICB2YWx1ZTogcmVtb3RlQXR0cmlidXRlRGVmaW5pdGlvbnMsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgX19yZW1vdGVFdmVudERlZmluaXRpb25zOiB7XG4gICAgICAgICAgdmFsdWU6IHJlbW90ZUV2ZW50RGVmaW5pdGlvbnMsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgX19hdHRyaWJ1dGVUb1Byb3BlcnR5TWFwOiB7XG4gICAgICAgICAgdmFsdWU6IGF0dHJpYnV0ZVRvUHJvcGVydHlNYXAsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgX19ldmVudFRvUHJvcGVydHlNYXA6IHtcbiAgICAgICAgICB2YWx1ZTogZXZlbnRUb1Byb3BlcnR5TWFwLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEp1c3QgbmVlZCB0byB1c2UgdGhlc2UgdHlwZXMgc28gVFMgZG9lc27igJl0IGxvc2UgdHJhY2sgb2YgdGhlbS5cbiAgICAvKiogQGludGVybmFsICovXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAvKiogQGludGVybmFsICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5maW5hbGl6ZSgpO1xuICAgICAgY29uc3QgcHJvcGVydHlEZXNjcmlwdG9ycyA9IHt9O1xuICAgICAgY29uc3QgaW5pdGlhbFByb3BlcnRpZXNUb1NldCA9IHt9O1xuICAgICAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpO1xuICAgICAgY29uc3QgVGhpc0NsYXNzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgIGZvciAoY29uc3QgW3Byb3BlcnR5LCBkZXNjcmlwdGlvbl0gb2YgVGhpc0NsYXNzLnJlbW90ZVByb3BlcnR5RGVmaW5pdGlvbnMuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IGFsaWFzZWROYW1lID0gZGVzY3JpcHRpb24ubmFtZTtcbiAgICAgICAgaWYgKHByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydHkgPT09IGFsaWFzZWROYW1lKSB7XG4gICAgICAgICAgaW5pdGlhbFByb3BlcnRpZXNUb1NldFtwcm9wZXJ0eV0gPSBkZXNjcmlwdGlvbi5kZWZhdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3BlcnR5RGVzY3JpcHRvciA9IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogcHJvcGVydHkgPT09IGFsaWFzZWROYW1lLFxuICAgICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlbW90ZVByb3BlcnRpZXModGhpcyk/LlthbGlhc2VkTmFtZV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdXBkYXRlUmVtb3RlRWxlbWVudFByb3BlcnR5KHRoaXMsIGFsaWFzZWROYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBwcm9wZXJ0eURlc2NyaXB0b3JzW3Byb3BlcnR5XSA9IHByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW2V2ZW50LCBkZWZpbml0aW9uXSBvZiBUaGlzQ2xhc3MucmVtb3RlRXZlbnREZWZpbml0aW9ucy5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlGcm9tRGVmaW5pdGlvbiA9IGRlZmluaXRpb24ucHJvcGVydHkgPz8gdHJ1ZTtcbiAgICAgICAgaWYgKCFwcm9wZXJ0eUZyb21EZWZpbml0aW9uKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBwcm9wZXJ0eUZyb21EZWZpbml0aW9uID09PSB0cnVlID8gXFxgb25cXCR7ZXZlbnR9XFxgIDogcHJvcGVydHlGcm9tRGVmaW5pdGlvbjtcbiAgICAgICAgcHJvcGVydHlEZXNjcmlwdG9yc1twcm9wZXJ0eV0gPSB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UmVtb3RlRXZlbnRzKHRoaXMpLnByb3BlcnRpZXMuZ2V0KHByb3BlcnR5KSA/PyBudWxsO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZUV2ZW50cyA9IGdldFJlbW90ZUV2ZW50cyh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMaXN0ZW5lciA9IHJlbW90ZUV2ZW50cy5wcm9wZXJ0aWVzLmdldChwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgbGV0IGhhbmRsZXIgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmNhbGwodGhpcywgLi4uYXJncyk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJlbW90ZUV2ZW50cy5wcm9wZXJ0aWVzLnNldChwcm9wZXJ0eSwgaGFuZGxlcik7XG4gICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZW1vdGVFdmVudHMucHJvcGVydGllcy5kZWxldGUocHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGN1cnJlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywgcHJvcGVydHlEZXNjcmlwdG9ycyk7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGluaXRpYWxQcm9wZXJ0aWVzVG9TZXQpO1xuICAgIH1cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0cmlidXRlLCBfb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICBpZiAoYXR0cmlidXRlID09PSBcInNsb3RcIiAmJiB0aGlzLmNvbnN0cnVjdG9yLnNsb3R0YWJsZSkge1xuICAgICAgICB1cGRhdGVSZW1vdGVFbGVtZW50QXR0cmlidXRlKHRoaXMsIGF0dHJpYnV0ZSwgbmV3VmFsdWUgPyBTdHJpbmcobmV3VmFsdWUpIDogdm9pZCAwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICByZW1vdGVQcm9wZXJ0eURlZmluaXRpb25zLFxuICAgICAgICByZW1vdGVBdHRyaWJ1dGVEZWZpbml0aW9ucyxcbiAgICAgICAgX19hdHRyaWJ1dGVUb1Byb3BlcnR5TWFwOiBhdHRyaWJ1dGVUb1Byb3BlcnR5TWFwXG4gICAgICB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChyZW1vdGVBdHRyaWJ1dGVEZWZpbml0aW9ucy5oYXMoYXR0cmlidXRlKSkge1xuICAgICAgICB1cGRhdGVSZW1vdGVFbGVtZW50QXR0cmlidXRlKHRoaXMsIGF0dHJpYnV0ZSwgbmV3VmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IGF0dHJpYnV0ZVRvUHJvcGVydHlNYXAuZ2V0KGF0dHJpYnV0ZSk7XG4gICAgICBjb25zdCBwcm9wZXJ0eURlZmluaXRpb24gPSBwcm9wZXJ0eSA9PSBudWxsID8gcHJvcGVydHkgOiByZW1vdGVQcm9wZXJ0eURlZmluaXRpb25zLmdldChwcm9wZXJ0eSk7XG4gICAgICBpZiAocHJvcGVydHlEZWZpbml0aW9uID09IG51bGwpIHJldHVybjtcbiAgICAgIHRoaXNbcHJvcGVydHldID0gY29udmVydEF0dHJpYnV0ZVZhbHVlVG9Qcm9wZXJ0eShuZXdWYWx1ZSwgcHJvcGVydHlEZWZpbml0aW9uLnR5cGUpO1xuICAgIH1cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGZvciAoY29uc3QgW2V2ZW50LCBkZXNjcmlwdG9yXSBvZiB0aGlzLmNvbnN0cnVjdG9yLnJlbW90ZUV2ZW50RGVmaW5pdGlvbnMuZW50cmllcygpKSB7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yLmJ1YmJsZXMpIHtcbiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG5vb3BCdWJibGVzRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBmb3IgKGNvbnN0IFtldmVudCwgZGVzY3JpcHRvcl0gb2YgdGhpcy5jb25zdHJ1Y3Rvci5yZW1vdGVFdmVudERlZmluaXRpb25zLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAoZGVzY3JpcHRvci5idWJibGVzKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBub29wQnViYmxlc0V2ZW50TGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVtb3RlRXZlbnREZWZpbml0aW9ucyxcbiAgICAgICAgX19ldmVudFRvUHJvcGVydHlNYXA6IGV2ZW50VG9Qcm9wZXJ0eU1hcFxuICAgICAgfSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICBjb25zdCBsaXN0ZW5lckRlZmluaXRpb24gPSByZW1vdGVFdmVudERlZmluaXRpb25zLmdldCh0eXBlKTtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gZXZlbnRUb1Byb3BlcnR5TWFwLmdldCh0eXBlKTtcbiAgICAgIGlmIChsaXN0ZW5lckRlZmluaXRpb24gPT0gbnVsbCAmJiBwcm9wZXJ0eSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbW90ZUV2ZW50cyA9IGdldFJlbW90ZUV2ZW50cyh0aGlzKTtcbiAgICAgIGNvbnN0IHJlbW90ZUV2ZW50ID0gZ2V0UmVtb3RlRXZlbnRSZWNvcmQuY2FsbCh0aGlzLCB0eXBlLCB7XG4gICAgICAgIHByb3BlcnR5LFxuICAgICAgICBkZWZpbml0aW9uOiBsaXN0ZW5lckRlZmluaXRpb25cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZExpc3RlbmVyID0gdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucz8ub25jZSA/ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHR5cGVvZiBsaXN0ZW5lciA9PT0gXCJvYmplY3RcIiA/IGxpc3RlbmVyLmhhbmRsZUV2ZW50KC4uLmFyZ3MpIDogbGlzdGVuZXIuY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgICAgICAgcmVtb3ZlUmVtb3RlTGlzdGVuZXIuY2FsbCh0aGlzLCB0eXBlLCBsaXN0ZW5lciwgbGlzdGVuZXJSZWNvcmQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSA6IGxpc3RlbmVyO1xuICAgICAgY29uc3QgbGlzdGVuZXJSZWNvcmQgPSBbbm9ybWFsaXplZExpc3RlbmVyLCByZW1vdGVFdmVudF07XG4gICAgICByZW1vdGVFdmVudC5saXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICAgIHJlbW90ZUV2ZW50cy5saXN0ZW5lcnMuc2V0KGxpc3RlbmVyLCBsaXN0ZW5lclJlY29yZCk7XG4gICAgICBzdXBlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIG5vcm1hbGl6ZWRMaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5zaWduYWwpIHtcbiAgICAgICAgb3B0aW9ucy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgICByZW1vdmVSZW1vdGVMaXN0ZW5lci5jYWxsKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBsaXN0ZW5lclJlY29yZCk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3RlbmVyRGVmaW5pdGlvbikge1xuICAgICAgICB1cGRhdGVSZW1vdGVFbGVtZW50RXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCByZW1vdGVFdmVudC5kaXNwYXRjaCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVSZW1vdGVFbGVtZW50UHJvcGVydHkodGhpcywgcHJvcGVydHksIHJlbW90ZUV2ZW50LmRpc3BhdGNoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgY29uc3QgbGlzdGVuZXJSZWNvcmQgPSBSRU1PVEVfRVZFTlRTLmdldCh0aGlzKT8ubGlzdGVuZXJzLmdldChsaXN0ZW5lcik7XG4gICAgICBjb25zdCBub3JtYWxpemVkTGlzdGVuZXIgPSBsaXN0ZW5lclJlY29yZCA/IGxpc3RlbmVyUmVjb3JkWzBdIDogbGlzdGVuZXI7XG4gICAgICBzdXBlci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIG5vcm1hbGl6ZWRMaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgICBpZiAobGlzdGVuZXJSZWNvcmQgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgcmVtb3ZlUmVtb3RlTGlzdGVuZXIuY2FsbCh0aGlzLCB0eXBlLCBsaXN0ZW5lciwgbGlzdGVuZXJSZWNvcmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgc2luZ2xlIHJlbW90ZSBwcm9wZXJ0eSBvbiBhbiBlbGVtZW50IG5vZGUuIElmIHRoZSBlbGVtZW50IGlzXG4gICAgICogY29ubmVjdGVkIHRvIGEgcmVtb3RlIHJvb3QsIHRoaXMgZnVuY3Rpb24gd2lsbCBhbHNvIG1ha2UgYSBcXGBtdXRhdGUoKVxcYCBjYWxsXG4gICAgICogdG8gY29tbXVuaWNhdGUgdGhlIGNoYW5nZSB0byB0aGUgaG9zdC5cbiAgICAgKi9cbiAgICB1cGRhdGVSZW1vdGVQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgICAgdXBkYXRlUmVtb3RlRWxlbWVudFByb3BlcnR5KHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhIHNpbmdsZSByZW1vdGUgYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQgbm9kZS4gSWYgdGhlIGVsZW1lbnQgaXNcbiAgICAgKiBjb25uZWN0ZWQgdG8gYSByZW1vdGUgcm9vdCwgdGhpcyBmdW5jdGlvbiB3aWxsIGFsc28gbWFrZSBhIFxcYG11dGF0ZSgpXFxgIGNhbGxcbiAgICAgKiB0byBjb21tdW5pY2F0ZSB0aGUgY2hhbmdlIHRvIHRoZSBob3N0LlxuICAgICAqL1xuICAgIHVwZGF0ZVJlbW90ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICAgICAgdXBkYXRlUmVtb3RlRWxlbWVudEF0dHJpYnV0ZSh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgbWV0aG9kIHRocm91Z2ggXFxgUmVtb3RlQ29ubmVjdGlvbi5jYWxsKClcXGAsIHVzaW5nIHRoZSByZW1vdGUgSUQgYW5kXG4gICAgICogY29ubmVjdGlvbiBmb3IgdGhlIHByb3ZpZGVkIG5vZGUuXG4gICAgICovXG4gICAgY2FsbFJlbW90ZU1ldGhvZChtZXRob2QsIC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiBjYWxsUmVtb3RlRWxlbWVudE1ldGhvZCh0aGlzLCBtZXRob2QsIC4uLmFyZ3MpO1xuICAgIH1cbiAgfTtcbiAgX19wdWJsaWNGaWVsZChSZW1vdGVFbGVtZW50LCBcInNsb3R0YWJsZVwiLCB0cnVlKTtcbiAgX19wdWJsaWNGaWVsZChSZW1vdGVFbGVtZW50LCBcIl9fZmluYWxpemVkXCIsIHRydWUpO1xuICBfX3B1YmxpY0ZpZWxkKFJlbW90ZUVsZW1lbnQsIFwiX19vYnNlcnZlZEF0dHJpYnV0ZXNcIiwgW10pO1xuICBfX3B1YmxpY0ZpZWxkKFJlbW90ZUVsZW1lbnQsIFwiX19hdHRyaWJ1dGVUb1Byb3BlcnR5TWFwXCIsIC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSkoKSk7XG4gIF9fcHVibGljRmllbGQoUmVtb3RlRWxlbWVudCwgXCJfX2V2ZW50VG9Qcm9wZXJ0eU1hcFwiLCAvKiBAX19QVVJFX18gKi8gKCgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpKCkpO1xuICBfX3B1YmxpY0ZpZWxkKFJlbW90ZUVsZW1lbnQsIFwiX19yZW1vdGVQcm9wZXJ0eURlZmluaXRpb25zXCIsIC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSkoKSk7XG4gIF9fcHVibGljRmllbGQoUmVtb3RlRWxlbWVudCwgXCJfX3JlbW90ZUF0dHJpYnV0ZURlZmluaXRpb25zXCIsIC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSkoKSk7XG4gIF9fcHVibGljRmllbGQoUmVtb3RlRWxlbWVudCwgXCJfX3JlbW90ZUV2ZW50RGVmaW5pdGlvbnNcIiwgLyogQF9fUFVSRV9fICovICgoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKSgpKTtcbiAgX19wdWJsaWNGaWVsZChSZW1vdGVFbGVtZW50LCBcIl9fcmVtb3RlU2xvdERlZmluaXRpb25zXCIsIC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSkoKSk7XG4gIHZhciBSRU1PVEVfRVZFTlRTID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGZ1bmN0aW9uIGdldFJlbW90ZUV2ZW50cyhlbGVtZW50KSB7XG4gICAgbGV0IGV2ZW50cyA9IFJFTU9URV9FVkVOVFMuZ2V0KGVsZW1lbnQpO1xuICAgIGlmIChldmVudHMpIHJldHVybiBldmVudHM7XG4gICAgZXZlbnRzID0ge1xuICAgICAgZXZlbnRzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgcHJvcGVydGllczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIGxpc3RlbmVyczogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKClcbiAgICB9O1xuICAgIFJFTU9URV9FVkVOVFMuc2V0KGVsZW1lbnQsIGV2ZW50cyk7XG4gICAgcmV0dXJuIGV2ZW50cztcbiAgfVxuICBmdW5jdGlvbiBnZXRSZW1vdGVFdmVudFJlY29yZCh0eXBlLCB7XG4gICAgcHJvcGVydHksXG4gICAgZGVmaW5pdGlvblxuICB9KSB7XG4gICAgY29uc3QgcmVtb3RlRXZlbnRzID0gZ2V0UmVtb3RlRXZlbnRzKHRoaXMpO1xuICAgIGxldCByZW1vdGVFdmVudCA9IHJlbW90ZUV2ZW50cy5ldmVudHMuZ2V0KHR5cGUpO1xuICAgIGlmIChyZW1vdGVFdmVudCA9PSBudWxsKSB7XG4gICAgICByZW1vdGVFdmVudCA9IHtcbiAgICAgICAgbmFtZTogdHlwZSxcbiAgICAgICAgcHJvcGVydHksXG4gICAgICAgIGRlZmluaXRpb24sXG4gICAgICAgIGxpc3RlbmVyczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgICAgZGlzcGF0Y2g6IChhcmcpID0+IHtcbiAgICAgICAgICBjb25zdCBldmVudCA9IGRlZmluaXRpb24/LmRpc3BhdGNoRXZlbnQ/LmNhbGwodGhpcywgYXJnKSA/PyBuZXcgUmVtb3RlRXZlbnQodHlwZSwge1xuICAgICAgICAgICAgZGV0YWlsOiBhcmcsXG4gICAgICAgICAgICBidWJibGVzOiBkZWZpbml0aW9uPy5idWJibGVzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICByZXR1cm4gZXZlbnQucmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZW1vdGVFdmVudHMuZXZlbnRzLnNldCh0eXBlLCByZW1vdGVFdmVudCk7XG4gICAgfVxuICAgIHJldHVybiByZW1vdGVFdmVudDtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVSZW1vdGVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgbGlzdGVuZXJSZWNvcmQpIHtcbiAgICBjb25zdCByZW1vdGVFdmVudHMgPSBnZXRSZW1vdGVFdmVudHModGhpcyk7XG4gICAgY29uc3QgcmVtb3RlRXZlbnQgPSBsaXN0ZW5lclJlY29yZFsxXTtcbiAgICByZW1vdGVFdmVudC5saXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICByZW1vdGVFdmVudHMubGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgaWYgKHJlbW90ZUV2ZW50Lmxpc3RlbmVycy5zaXplID4gMCkgcmV0dXJuO1xuICAgIHJlbW90ZUV2ZW50cy5ldmVudHMuZGVsZXRlKHR5cGUpO1xuICAgIGlmIChyZW1vdGVFdmVudC5wcm9wZXJ0eSkge1xuICAgICAgaWYgKHJlbW90ZVByb3BlcnRpZXModGhpcyk/LltyZW1vdGVFdmVudC5wcm9wZXJ0eV0gPT09IHJlbW90ZUV2ZW50LmRpc3BhdGNoKSB7XG4gICAgICAgIHVwZGF0ZVJlbW90ZUVsZW1lbnRQcm9wZXJ0eSh0aGlzLCByZW1vdGVFdmVudC5wcm9wZXJ0eSwgdm9pZCAwKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlbW90ZUV2ZW50TGlzdGVuZXJzKHRoaXMpPy5bdHlwZV0gPT09IHJlbW90ZUV2ZW50LmRpc3BhdGNoKSB7XG4gICAgICAgIHVwZGF0ZVJlbW90ZUVsZW1lbnRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIHZvaWQgMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNhdmVSZW1vdGVQcm9wZXJ0eShuYW1lLCBkZXNjcmlwdGlvbiwgb2JzZXJ2ZWRBdHRyaWJ1dGVzLCByZW1vdGVQcm9wZXJ0eURlZmluaXRpb25zLCBhdHRyaWJ1dGVUb1Byb3BlcnR5TWFwLCBldmVudFRvUHJvcGVydHlNYXApIHtcbiAgICBpZiAocmVtb3RlUHJvcGVydHlEZWZpbml0aW9ucy5oYXMobmFtZSkpIHtcbiAgICAgIHJldHVybiByZW1vdGVQcm9wZXJ0eURlZmluaXRpb25zLmdldChuYW1lKTtcbiAgICB9XG4gICAgY29uc3QgbG9va3NMaWtlRXZlbnRDYWxsYmFjayA9IG5hbWVbMF0gPT09IFwib1wiICYmIG5hbWVbMV0gPT09IFwiblwiO1xuICAgIGNvbnN0IHJlc29sdmVkRGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbiA/PyB7fTtcbiAgICBsZXQge1xuICAgICAgYWxpYXNcbiAgICB9ID0gcmVzb2x2ZWREZXNjcmlwdGlvbjtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlID0gbG9va3NMaWtlRXZlbnRDYWxsYmFjayA/IEZ1bmN0aW9uIDogU3RyaW5nLFxuICAgICAgYXR0cmlidXRlID0gdHlwZSAhPT0gRnVuY3Rpb24sXG4gICAgICBldmVudCA9IGxvb2tzTGlrZUV2ZW50Q2FsbGJhY2ssXG4gICAgICBkZWZhdWx0OiBkZWZhdWx0VmFsdWUgPSB0eXBlID09PSBCb29sZWFuID8gZmFsc2UgOiB2b2lkIDBcbiAgICB9ID0gcmVzb2x2ZWREZXNjcmlwdGlvbjtcbiAgICBpZiAoYWxpYXMgPT0gbnVsbCkge1xuICAgICAgY29uc3QgbG93ZXJjYXNlUHJvcGVydHkgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJjYXNlUHJvcGVydHkgIT09IG5hbWUpIHtcbiAgICAgICAgYWxpYXMgPSBbbG93ZXJjYXNlUHJvcGVydHldO1xuICAgICAgfVxuICAgICAgaWYgKGxvb2tzTGlrZUV2ZW50Q2FsbGJhY2spIHtcbiAgICAgICAgYWxpYXMgPz8gKGFsaWFzID0gW10pO1xuICAgICAgICBhbGlhcy51bnNoaWZ0KFxcYF9cXCR7bmFtZX1cXGApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgYXR0cmlidXRlTmFtZTtcbiAgICBpZiAoYXR0cmlidXRlID09PSB0cnVlKSB7XG4gICAgICBhdHRyaWJ1dGVOYW1lID0gY2FtZWxUb0tlYmFiQ2FzZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhdHRyaWJ1dGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGU7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYnNlcnZlZEF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIG9ic2VydmVkQXR0cmlidXRlcy5wdXNoKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JzZXJ2ZWRBdHRyaWJ1dGVzLmFkZChhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH1cbiAgICAgIGF0dHJpYnV0ZVRvUHJvcGVydHlNYXAuc2V0KGF0dHJpYnV0ZU5hbWUsIG5hbWUpO1xuICAgIH1cbiAgICBsZXQgZXZlbnROYW1lO1xuICAgIGlmIChldmVudCA9PT0gdHJ1ZSkge1xuICAgICAgZXZlbnROYW1lID0gY2FtZWxUb0tlYmFiQ2FzZShsb29rc0xpa2VFdmVudENhbGxiYWNrID8gbmFtZS5zbGljZSgyKSA6IG5hbWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBldmVudE5hbWUgPSBldmVudDtcbiAgICB9XG4gICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgZXZlbnRUb1Byb3BlcnR5TWFwLnNldChldmVudE5hbWUsIG5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBkZWZpbml0aW9uID0ge1xuICAgICAgbmFtZSxcbiAgICAgIHR5cGUsXG4gICAgICBhbGlhcyxcbiAgICAgIGV2ZW50OiBldmVudE5hbWUsXG4gICAgICBhdHRyaWJ1dGU6IGF0dHJpYnV0ZU5hbWUsXG4gICAgICBkZWZhdWx0OiBkZWZhdWx0VmFsdWVcbiAgICB9O1xuICAgIHJlbW90ZVByb3BlcnR5RGVmaW5pdGlvbnMuc2V0KG5hbWUsIGRlZmluaXRpb24pO1xuICAgIGlmIChhbGlhcykge1xuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eUFsaWFzIG9mIGFsaWFzKSB7XG4gICAgICAgIHJlbW90ZVByb3BlcnR5RGVmaW5pdGlvbnMuc2V0KHByb3BlcnR5QWxpYXMsIGRlZmluaXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBjb252ZXJ0QXR0cmlidXRlVmFsdWVUb1Byb3BlcnR5KHZhbHVlLCB0eXBlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBcImZhbHNlXCI7XG4gICAgICBjYXNlIE9iamVjdDpcbiAgICAgIGNhc2UgQXJyYXk6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICBjYXNlIFN0cmluZzpcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIGNhc2UgRnVuY3Rpb246XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHJldHVybiB0eXBlLnBhcnNlPy4odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjYW1lbFRvS2ViYWJDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgXCIkMS0kMlwiKS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIGZ1bmN0aW9uIG5vb3BCdWJibGVzRXZlbnRMaXN0ZW5lcigpIHtcbiAgfVxuXG4gIC8vIC4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AcmVtb3RlLWRvbStjb3JlQDEuOC4xX0BwcmVhY3Qrc2lnbmFscy1jb3JlQDEuMTAuMC9ub2RlX21vZHVsZXMvQHJlbW90ZS1kb20vY29yZS9idWlsZC9lc20vZWxlbWVudHMvUmVtb3RlTXV0YXRpb25PYnNlcnZlci5tanNcbiAgdmFyIFJlbW90ZU11dGF0aW9uT2JzZXJ2ZXIgPSBjbGFzcyBleHRlbmRzIE11dGF0aW9uT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24pIHtcbiAgICAgIHN1cGVyKChyZWNvcmRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGFkZGVkTm9kZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVtb3RlUmVjb3JkcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiByZWNvcmRzKSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSByZW1vdGVJZChyZWNvcmQudGFyZ2V0KTtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcmVjb3JkLnByZXZpb3VzU2libGluZyA/IGluZGV4T2YocmVjb3JkLnByZXZpb3VzU2libGluZywgcmVjb3JkLnRhcmdldC5jaGlsZE5vZGVzKSArIDEgOiAwO1xuICAgICAgICAgICAgcmVjb3JkLnJlbW92ZWROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICAgIGRpc2Nvbm5lY3RSZW1vdGVOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICByZW1vdGVSZWNvcmRzLnB1c2goW01VVEFUSU9OX1RZUEVfUkVNT1ZFX0NISUxELCB0YXJnZXRJZCwgcG9zaXRpb25dKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVjb3JkLmFkZGVkTm9kZXMuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGFkZGVkTm9kZXMuc29tZSgoYWRkZWROb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZGVkTm9kZSA9PT0gbm9kZSB8fCBhZGRlZE5vZGUuY29udGFpbnMobm9kZSk7XG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFkZGVkTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgY29ubmVjdFJlbW90ZU5vZGUobm9kZSwgY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgIHJlbW90ZVJlY29yZHMucHVzaChbTVVUQVRJT05fVFlQRV9JTlNFUlRfQ0hJTEQsIHRhcmdldElkLCBzZXJpYWxpemVSZW1vdGVOb2RlKG5vZGUpLCBwb3NpdGlvbiArIGluZGV4XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcImNoYXJhY3RlckRhdGFcIikge1xuICAgICAgICAgICAgcmVtb3RlUmVjb3Jkcy5wdXNoKFtNVVRBVElPTl9UWVBFX1VQREFURV9URVhULCB0YXJnZXRJZCwgcmVjb3JkLnRhcmdldC50ZXh0Q29udGVudCA/PyBcIlwiXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIgJiYgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgIT0gbnVsbCAmJiByZWNvcmQudGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCAmJiAhcmVjb3JkLnRhcmdldC50YWdOYW1lLmluY2x1ZGVzKFwiLVwiKSkge1xuICAgICAgICAgICAgcmVtb3RlUmVjb3Jkcy5wdXNoKFtNVVRBVElPTl9UWVBFX1VQREFURV9QUk9QRVJUWSwgdGFyZ2V0SWQsIHJlY29yZC5hdHRyaWJ1dGVOYW1lLCByZWNvcmQudGFyZ2V0LmdldEF0dHJpYnV0ZShyZWNvcmQuYXR0cmlidXRlTmFtZSldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGlvbi5tdXRhdGUocmVtb3RlUmVjb3Jkcyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB3YXRjaGluZyBjaGFuZ2VzIHRvIHRoZSBlbGVtZW50LCBhbmQgY29tbXVuaWNhdGVzIGNoYW5nZXMgdG8gdGhlXG4gICAgICogaG9zdCBlbnZpcm9ubWVudC4gQnkgZGVmYXVsdCwgdGhpcyBtZXRob2Qgd2lsbCBhbHNvIGNvbW11bmljYXRlIGFueSBpbml0aWFsXG4gICAgICogY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnQgdG8gdGhlIGhvc3QgZW52aXJvbm1lbnQuXG4gICAgICovXG4gICAgb2JzZXJ2ZSh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIFJFTU9URV9JRFMuc2V0KHRhcmdldCwgUk9PVF9JRCk7XG4gICAgICBpZiAob3B0aW9ucz8uaW5pdGlhbCAhPT0gZmFsc2UgJiYgdGFyZ2V0LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCByZWNvcmRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gdGFyZ2V0LmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgY29ubmVjdFJlbW90ZU5vZGUobm9kZSwgdGhpcy5jb25uZWN0aW9uKTtcbiAgICAgICAgICByZWNvcmRzLnB1c2goW01VVEFUSU9OX1RZUEVfSU5TRVJUX0NISUxELCBST09UX0lELCBzZXJpYWxpemVSZW1vdGVOb2RlKG5vZGUpLCBpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm11dGF0ZShyZWNvcmRzKTtcbiAgICAgIH1cbiAgICAgIHN1cGVyLm9ic2VydmUodGFyZ2V0LCB7XG4gICAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBpbmRleE9mKG5vZGUsIGxpc3QpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBub2RlKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BxdWlsdGVkK3RocmVhZHNAMy4xLjNfQHByZWFjdCtzaWduYWxzLWNvcmVAMS4xMC4wL25vZGVfbW9kdWxlcy9AcXVpbHRlZC90aHJlYWRzL2J1aWxkL2VzbS9jb25zdGFudHMubWpzXG4gIHZhciBNRVNTQUdFX0NBTEwgPSAxO1xuICB2YXIgTUVTU0FHRV9DQUxMX1JFU1VMVCA9IDI7XG4gIHZhciBNRVNTQUdFX0ZVTkNUSU9OX0NBTEwgPSAzO1xuICB2YXIgTUVTU0FHRV9GVU5DVElPTl9SRVNVTFQgPSA0O1xuICB2YXIgTUVTU0FHRV9GVU5DVElPTl9SRUxFQVNFID0gNTtcbiAgdmFyIFNFUklBTElaRV9NRVRIT0QgPSBTeW1ib2wuZm9yKFwicXVpbHQudGhyZWFkcy5zZXJpYWxpemVcIik7XG4gIHZhciBUUkFOU0ZFUkFCTEUgPSBTeW1ib2wuZm9yKFwicXVpbHQudGhyZWFkcy50cmFuc2ZlcmFibGVcIik7XG5cbiAgLy8gLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BxdWlsdGVkK2V2ZW50c0AyLjEuMy9ub2RlX21vZHVsZXMvQHF1aWx0ZWQvZXZlbnRzL2J1aWxkL2VzbS9hYm9ydC9OZXN0ZWRBYm9ydENvbnRyb2xsZXIubWpzXG4gIHZhciBOZXN0ZWRBYm9ydENvbnRyb2xsZXIgPSBjbGFzcyBleHRlbmRzIEFib3J0Q29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IoLi4ucGFyZW50cykge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIGNvbnN0IGFib3J0ZWRTaWduYWwgPSBwYXJlbnRzLmZpbmQoKHNpZ25hbCkgPT4gc2lnbmFsLmFib3J0ZWQpO1xuICAgICAgaWYgKGFib3J0ZWRTaWduYWwpIHtcbiAgICAgICAgdGhpcy5hYm9ydChhYm9ydGVkU2lnbmFsLnJlYXNvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhYm9ydCA9IChldmVudCkgPT4gdGhpcy5hYm9ydChldmVudC50YXJnZXQucmVhc29uKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzaWduYWw6IHRoaXMuc2lnbmFsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3Qgc2lnbmFsIG9mIHBhcmVudHMpIHtcbiAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyAuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHF1aWx0ZWQrdGhyZWFkc0AzLjEuM19AcHJlYWN0K3NpZ25hbHMtY29yZUAxLjEwLjAvbm9kZV9tb2R1bGVzL0BxdWlsdGVkL3RocmVhZHMvYnVpbGQvZXNtL2Vycm9ycy5tanNcbiAgdmFyIFRocmVhZENsb3NlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcihcIllvdSBhdHRlbXB0ZWQgdG8gY2FsbCBhIGZ1bmN0aW9uIG9uIGEgY2xvc2VkIHRocmVhZC5cIik7XG4gICAgfVxuICB9O1xuXG4gIC8vIC4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AcXVpbHRlZCt0aHJlYWRzQDMuMS4zX0BwcmVhY3Qrc2lnbmFscy1jb3JlQDEuMTAuMC9ub2RlX21vZHVsZXMvQHF1aWx0ZWQvdGhyZWFkcy9idWlsZC9lc20vbmFub2lkLm1qc1xuICB2YXIgYSA9IFwidXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdFwiO1xuICBmdW5jdGlvbiBuYW5vaWQoZSA9IDIxKSB7XG4gICAgbGV0IHQgPSBcIlwiLCByID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShlKSk7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBlOyBuKyspIHQgKz0gYVs2MyAmIHJbbl1dO1xuICAgIHJldHVybiB0O1xuICB9XG5cbiAgLy8gLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BxdWlsdGVkK3RocmVhZHNAMy4xLjNfQHByZWFjdCtzaWduYWxzLWNvcmVAMS4xMC4wL25vZGVfbW9kdWxlcy9AcXVpbHRlZC90aHJlYWRzL2J1aWxkL2VzbS9mdW5jdGlvbnMvVGhyZWFkRnVuY3Rpb25zQXV0b21hdGljLm1qc1xuICB2YXIgX2Z1bmN0aW9uc1RvSWQsIF9pZHNUb0Z1bmN0aW9uLCBfaWRzVG9Qcm94eSwgX2ZpbmFsaXphdGlvbiwgX1RocmVhZEZ1bmN0aW9uc0F1dG9tYXRpY19pbnN0YW5jZXMsIGZpbmFsaXphdGlvblJlZ2lzdHJ5X2ZuO1xuICB2YXIgVGhyZWFkRnVuY3Rpb25zQXV0b21hdGljID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgX19wcml2YXRlQWRkKHRoaXMsIF9UaHJlYWRGdW5jdGlvbnNBdXRvbWF0aWNfaW5zdGFuY2VzKTtcbiAgICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZnVuY3Rpb25zVG9JZCwgLyogQF9fUFVSRV9fICovICgoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKSgpKTtcbiAgICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaWRzVG9GdW5jdGlvbiwgLyogQF9fUFVSRV9fICovICgoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKSgpKTtcbiAgICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaWRzVG9Qcm94eSwgLyogQF9fUFVSRV9fICovICgoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKSgpKTtcbiAgICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZmluYWxpemF0aW9uLCAvKiBAX19QVVJFX18gKi8gKCgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKSgpKTtcbiAgICB9XG4gICAgZ2V0KGlkMikge1xuICAgICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfaWRzVG9GdW5jdGlvbikuZ2V0KGlkMik7XG4gICAgfVxuICAgIHJlbGVhc2UoaWQyKSB7XG4gICAgICBjb25zdCBmdW5jID0gX19wcml2YXRlR2V0KHRoaXMsIF9pZHNUb0Z1bmN0aW9uKS5nZXQoaWQyKTtcbiAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfaWRzVG9GdW5jdGlvbikuZGVsZXRlKGlkMik7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfZnVuY3Rpb25zVG9JZCkuZGVsZXRlKGZ1bmMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJvb2xlYW4oZnVuYyk7XG4gICAgfVxuICAgIHNlcmlhbGl6ZShmdW5jKSB7XG4gICAgICBsZXQgaWQyID0gX19wcml2YXRlR2V0KHRoaXMsIF9mdW5jdGlvbnNUb0lkKS5nZXQoZnVuYyk7XG4gICAgICBpZiAoaWQyID09IG51bGwpIHtcbiAgICAgICAgaWQyID0gbmFub2lkKCk7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfZnVuY3Rpb25zVG9JZCkuc2V0KGZ1bmMsIGlkMik7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfaWRzVG9GdW5jdGlvbikuc2V0KGlkMiwgZnVuYyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaWQyO1xuICAgIH1cbiAgICBkZXNlcmlhbGl6ZShpZDIsIHRocmVhZCkge1xuICAgICAgbGV0IHByb3h5ID0gX19wcml2YXRlR2V0KHRoaXMsIF9pZHNUb1Byb3h5KS5nZXQoaWQyKT8uZGVyZWYoKTtcbiAgICAgIGlmIChwcm94eSkgcmV0dXJuIHByb3h5O1xuICAgICAgcHJveHkgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfaWRzVG9Qcm94eSkuaGFzKGlkMikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgYXR0ZW1wdGVkIHRvIGNhbGwgYSBmdW5jdGlvbiB0aGF0IHdhcyBhbHJlYWR5IHJldm9rZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aHJlYWQuY2FsbCgoY2FsbElELCBhcmdzMiwgdHJhbnNmZXJhYmxlKSA9PiB7XG4gICAgICAgICAgdGhyZWFkLm1lc3NhZ2VzLnNlbmQoW01FU1NBR0VfRlVOQ1RJT05fQ0FMTCwgY2FsbElELCBpZDIsIGFyZ3MyXSwgdHJhbnNmZXJhYmxlKTtcbiAgICAgICAgfSwgYXJncyk7XG4gICAgICB9O1xuICAgICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UaHJlYWRGdW5jdGlvbnNBdXRvbWF0aWNfaW5zdGFuY2VzLCBmaW5hbGl6YXRpb25SZWdpc3RyeV9mbikuY2FsbCh0aGlzLCB0aHJlYWQpPy5yZWdpc3Rlcihwcm94eSwgaWQyKTtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfaWRzVG9Qcm94eSkuc2V0KGlkMiwgbmV3IFdlYWtSZWYocHJveHkpKTtcbiAgICAgIHJldHVybiBwcm94eTtcbiAgICB9XG4gIH07XG4gIF9mdW5jdGlvbnNUb0lkID0gbmV3IFdlYWtNYXAoKTtcbiAgX2lkc1RvRnVuY3Rpb24gPSBuZXcgV2Vha01hcCgpO1xuICBfaWRzVG9Qcm94eSA9IG5ldyBXZWFrTWFwKCk7XG4gIF9maW5hbGl6YXRpb24gPSBuZXcgV2Vha01hcCgpO1xuICBfVGhyZWFkRnVuY3Rpb25zQXV0b21hdGljX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCk7XG4gIGZpbmFsaXphdGlvblJlZ2lzdHJ5X2ZuID0gZnVuY3Rpb24odGhyZWFkKSB7XG4gICAgbGV0IGZpbmFsaXphdGlvbiA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfZmluYWxpemF0aW9uKS5nZXQodGhyZWFkKTtcbiAgICBpZiAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoIWZpbmFsaXphdGlvbikge1xuICAgICAgZmluYWxpemF0aW9uID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KChpZDIpID0+IHtcbiAgICAgICAgdGhyZWFkLm1lc3NhZ2VzLnNlbmQoW01FU1NBR0VfRlVOQ1RJT05fUkVMRUFTRSwgaWQyXSk7XG4gICAgICB9KTtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfZmluYWxpemF0aW9uKS5zZXQodGhyZWFkLCBmaW5hbGl6YXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gZmluYWxpemF0aW9uO1xuICB9O1xuXG4gIC8vIC4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AcXVpbHRlZCt0aHJlYWRzQDMuMS4zX0BwcmVhY3Qrc2lnbmFscy1jb3JlQDEuMTAuMC9ub2RlX21vZHVsZXMvQHF1aWx0ZWQvdGhyZWFkcy9idWlsZC9lc20vc2VyaWFsaXphdGlvbi9zaGFyZWQubWpzXG4gIGZ1bmN0aW9uIGlzSXRlcmF0b3IodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gdmFsdWUgfHwgU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUubmV4dCA9PT0gXCJmdW5jdGlvblwiO1xuICB9XG4gIGZ1bmN0aW9uIGlzQmFzaWNPYmplY3QodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICAgIHJldHVybiBwcm90b3R5cGUgPT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG4gIH1cblxuICAvLyAuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHF1aWx0ZWQrdGhyZWFkc0AzLjEuM19AcHJlYWN0K3NpZ25hbHMtY29yZUAxLjEwLjAvbm9kZV9tb2R1bGVzL0BxdWlsdGVkL3RocmVhZHMvYnVpbGQvZXNtL3NlcmlhbGl6YXRpb24vVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZS5tanNcbiAgdmFyIEZVTkNUSU9OID0gXCJfQGZcIjtcbiAgdmFyIEFTWU5DX0lURVJBVE9SID0gXCJfQGlcIjtcbiAgdmFyIF9jdXN0b21TZXJpYWxpemVyLCBfY3VzdG9tRGVzZXJpYWxpemVyLCBfVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZV9pbnN0YW5jZXMsIHNlcmlhbGl6ZUludGVybmFsX2ZuLCBkZXNlcmlhbGl6ZUludGVybmFsX2ZuO1xuICB2YXIgVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZSA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICBfX3ByaXZhdGVBZGQodGhpcywgX1RocmVhZFNlcmlhbGl6YXRpb25TdHJ1Y3R1cmVkQ2xvbmVfaW5zdGFuY2VzKTtcbiAgICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfY3VzdG9tU2VyaWFsaXplcik7XG4gICAgICBfX3ByaXZhdGVBZGQodGhpcywgX2N1c3RvbURlc2VyaWFsaXplcik7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2N1c3RvbVNlcmlhbGl6ZXIsIG9wdGlvbnM/LnNlcmlhbGl6ZSk7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2N1c3RvbURlc2VyaWFsaXplciwgb3B0aW9ucz8uZGVzZXJpYWxpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIGEgdmFsdWUgaW50byBhIHN0cnVjdHVyZWQgY2xvbmluZy1jb21wYXRpYmxlIGZvcm1hdCB0aGF0IGNhbiBiZSB0cmFuc2ZlcnJlZCBiZXR3ZWVuIHRocmVhZHMuXG4gICAgICovXG4gICAgc2VyaWFsaXplKHZhbHVlLCB0aHJlYWQsIHRyYW5zZmVyYWJsZSkge1xuICAgICAgcmV0dXJuIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZV9pbnN0YW5jZXMsIHNlcmlhbGl6ZUludGVybmFsX2ZuKS5jYWxsKHRoaXMsIHZhbHVlLCB0aHJlYWQsIHRyYW5zZmVyYWJsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc2VyaWFsaXplcyBhIHN0cnVjdHVyZWQgY2xvbmluZy1jb21wYXRpYmxlIHZhbHVlIGZyb20gYW5vdGhlciB0aHJlYWQuXG4gICAgICovXG4gICAgZGVzZXJpYWxpemUodmFsdWUsIHRocmVhZCkge1xuICAgICAgcmV0dXJuIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZV9pbnN0YW5jZXMsIGRlc2VyaWFsaXplSW50ZXJuYWxfZm4pLmNhbGwodGhpcywgdmFsdWUsIHRocmVhZCk7XG4gICAgfVxuICB9O1xuICBfY3VzdG9tU2VyaWFsaXplciA9IG5ldyBXZWFrTWFwKCk7XG4gIF9jdXN0b21EZXNlcmlhbGl6ZXIgPSBuZXcgV2Vha01hcCgpO1xuICBfVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZV9pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpO1xuICBzZXJpYWxpemVJbnRlcm5hbF9mbiA9IGZ1bmN0aW9uKHZhbHVlLCB0aHJlYWQsIHRyYW5zZmVyYWJsZSwgc2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIGlzQXBwbHlpbmdEZWZhdWx0ID0gZmFsc2UpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHZhbHVlO1xuICAgIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHJldHVybiBzZWVuLmdldCh2YWx1ZSk7XG4gICAgc2Vlbi5zZXQodmFsdWUsIHZvaWQgMCk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfY3VzdG9tU2VyaWFsaXplcikgJiYgIWlzQXBwbHlpbmdEZWZhdWx0KSB7XG4gICAgICAgIGNvbnN0IGN1c3RvbVZhbHVlID0gX19wcml2YXRlR2V0KHRoaXMsIF9jdXN0b21TZXJpYWxpemVyKS5jYWxsKHRoaXMsIHZhbHVlLCAodmFsdWUyKSA9PiBfX3ByaXZhdGVNZXRob2QodGhpcywgX1RocmVhZFNlcmlhbGl6YXRpb25TdHJ1Y3R1cmVkQ2xvbmVfaW5zdGFuY2VzLCBzZXJpYWxpemVJbnRlcm5hbF9mbikuY2FsbCh0aGlzLCB2YWx1ZTIsIHRocmVhZCwgdHJhbnNmZXJhYmxlLCBzZWVuLCB0cnVlKSwgdGhyZWFkLCB0cmFuc2ZlcmFibGUpO1xuICAgICAgICBpZiAoY3VzdG9tVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHNlZW4uc2V0KHZhbHVlLCBjdXN0b21WYWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIGN1c3RvbVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVbVFJBTlNGRVJBQkxFXSkge1xuICAgICAgICB0cmFuc2ZlcmFibGU/LnB1c2godmFsdWUpO1xuICAgICAgICBzZWVuLnNldCh2YWx1ZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzZXJpYWxpemVWYWx1ZSA9ICh2YWx1ZTIpID0+IHtcbiAgICAgICAgcmV0dXJuIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZV9pbnN0YW5jZXMsIHNlcmlhbGl6ZUludGVybmFsX2ZuKS5jYWxsKHRoaXMsIHZhbHVlMiwgdGhyZWFkLCB0cmFuc2ZlcmFibGUsIHNlZW4pO1xuICAgICAgfTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVbU0VSSUFMSVpFX01FVEhPRF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZVtTRVJJQUxJWkVfTUVUSE9EXSh7XG4gICAgICAgICAgc2VyaWFsaXplOiBzZXJpYWxpemVWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgc2Vlbi5zZXQodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUubWFwKChpdGVtKSA9PiBzZXJpYWxpemVWYWx1ZShpdGVtKSk7XG4gICAgICAgIHNlZW4uc2V0KHZhbHVlLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBbLi4udmFsdWUuZW50cmllcygpXS5tYXAoKFtrZXksIHZhbHVlMl0pID0+IHtcbiAgICAgICAgICByZXR1cm4gW3NlcmlhbGl6ZVZhbHVlKGtleSksIHNlcmlhbGl6ZVZhbHVlKHZhbHVlMildO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcChlbnRyaWVzKTtcbiAgICAgICAgc2Vlbi5zZXQodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IFsuLi52YWx1ZV0ubWFwKChlbnRyeSkgPT4gc2VyaWFsaXplVmFsdWUoZW50cnkpKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldChlbnRyaWVzKTtcbiAgICAgICAgc2Vlbi5zZXQodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZUlzSXRlcmF0b3IgPSBpc0l0ZXJhdG9yKHZhbHVlKTtcbiAgICAgIGlmIChpc0Jhc2ljT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZUlzSXRlcmF0b3IpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gc2VyaWFsaXplVmFsdWUodmFsdWVba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlSXNJdGVyYXRvcikge1xuICAgICAgICAgIHJlc3VsdC5uZXh0ID8/IChyZXN1bHQubmV4dCA9IHNlcmlhbGl6ZVZhbHVlKHZhbHVlLm5leHQuYmluZCh2YWx1ZSkpKTtcbiAgICAgICAgICByZXN1bHQucmV0dXJuID8/IChyZXN1bHQucmV0dXJuID0gc2VyaWFsaXplVmFsdWUodmFsdWUucmV0dXJuLmJpbmQodmFsdWUpKSk7XG4gICAgICAgICAgcmVzdWx0LnRocm93ID8/IChyZXN1bHQudGhyb3cgPSBzZXJpYWxpemVWYWx1ZSh2YWx1ZS50aHJvdy5iaW5kKHZhbHVlKSkpO1xuICAgICAgICAgIHJlc3VsdFtBU1lOQ19JVEVSQVRPUl0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4uc2V0KHZhbHVlLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB0aHJlYWQuZnVuY3Rpb25zLnNlcmlhbGl6ZSh2YWx1ZSwgdGhyZWFkLCB0cmFuc2ZlcmFibGUpO1xuICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBbRlVOQ1RJT05dOiBzZXJpYWxpemVkXG4gICAgICB9O1xuICAgICAgc2Vlbi5zZXQodmFsdWUsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzZWVuLnNldCh2YWx1ZSwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgZGVzZXJpYWxpemVJbnRlcm5hbF9mbiA9IGZ1bmN0aW9uKHZhbHVlLCB0aHJlYWQsIGlzQXBwbHlpbmdEZWZhdWx0ID0gZmFsc2UpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX2N1c3RvbURlc2VyaWFsaXplcikgJiYgIWlzQXBwbHlpbmdEZWZhdWx0KSB7XG4gICAgICAgIGNvbnN0IGN1c3RvbVZhbHVlID0gX19wcml2YXRlR2V0KHRoaXMsIF9jdXN0b21EZXNlcmlhbGl6ZXIpLmNhbGwodGhpcywgdmFsdWUsICh2YWx1ZTIpID0+IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZV9pbnN0YW5jZXMsIGRlc2VyaWFsaXplSW50ZXJuYWxfZm4pLmNhbGwodGhpcywgdmFsdWUyLCB0aHJlYWQsIHRydWUpLCB0aHJlYWQpO1xuICAgICAgICBpZiAoY3VzdG9tVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBjdXN0b21WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHZhbHVlMikgPT4gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UaHJlYWRTZXJpYWxpemF0aW9uU3RydWN0dXJlZENsb25lX2luc3RhbmNlcywgZGVzZXJpYWxpemVJbnRlcm5hbF9mbikuY2FsbCh0aGlzLCB2YWx1ZTIsIHRocmVhZCkpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKFsuLi52YWx1ZV0ubWFwKChba2V5LCB2YWx1ZTJdKSA9PiBbX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UaHJlYWRTZXJpYWxpemF0aW9uU3RydWN0dXJlZENsb25lX2luc3RhbmNlcywgZGVzZXJpYWxpemVJbnRlcm5hbF9mbikuY2FsbCh0aGlzLCBrZXksIHRocmVhZCksIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZV9pbnN0YW5jZXMsIGRlc2VyaWFsaXplSW50ZXJuYWxfZm4pLmNhbGwodGhpcywgdmFsdWUyLCB0aHJlYWQpXSkpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2V0KFsuLi52YWx1ZV0ubWFwKChlbnRyeSkgPT4gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UaHJlYWRTZXJpYWxpemF0aW9uU3RydWN0dXJlZENsb25lX2luc3RhbmNlcywgZGVzZXJpYWxpemVJbnRlcm5hbF9mbikuY2FsbCh0aGlzLCBlbnRyeSwgdGhyZWFkKSkpO1xuICAgICAgfVxuICAgICAgaWYgKEZVTkNUSU9OIGluIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSB0aHJlYWQuZnVuY3Rpb25zLmRlc2VyaWFsaXplKHZhbHVlW0ZVTkNUSU9OXSwgdGhyZWFkKTtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQmFzaWNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModmFsdWUpKSB7XG4gICAgICAgIGlmIChrZXkgPT09IEFTWU5DX0lURVJBVE9SKSB7XG4gICAgICAgICAgcmVzdWx0W1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9ICgpID0+IHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZV9pbnN0YW5jZXMsIGRlc2VyaWFsaXplSW50ZXJuYWxfZm4pLmNhbGwodGhpcywgdmFsdWVba2V5XSwgdGhyZWFkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8vIC4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AcXVpbHRlZCt0aHJlYWRzQDMuMS4zX0BwcmVhY3Qrc2lnbmFscy1jb3JlQDEuMTAuMC9ub2RlX21vZHVsZXMvQHF1aWx0ZWQvdGhyZWFkcy9idWlsZC9lc20vVGhyZWFkLm1qc1xuICB2YXIgX2Fib3J0LCBfaWRzVG9SZXNvbHZlciwgX1RocmVhZF9pbnN0YW5jZXMsIGNhbGxMb2NhbF9mbiwgaGFuZGxlckZvckNhbGxfZm4sIHJlc29sdmVDYWxsX2ZuLCB3YWl0Rm9yUmVzdWx0X2ZuO1xuICB2YXIgVGhyZWFkID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2VzLCB7XG4gICAgICBpbXBvcnRzLFxuICAgICAgZXhwb3J0cyxcbiAgICAgIGZ1bmN0aW9ucyA9IG5ldyBUaHJlYWRGdW5jdGlvbnNBdXRvbWF0aWMoKSxcbiAgICAgIHNlcmlhbGl6YXRpb24gPSBuZXcgVGhyZWFkU2VyaWFsaXphdGlvblN0cnVjdHVyZWRDbG9uZSgpLFxuICAgICAgc2lnbmFsXG4gICAgfSA9IHt9KSB7XG4gICAgICBfX3ByaXZhdGVBZGQodGhpcywgX1RocmVhZF9pbnN0YW5jZXMpO1xuICAgICAgX19wcml2YXRlQWRkKHRoaXMsIF9hYm9ydCk7XG4gICAgICBfX3ByaXZhdGVBZGQodGhpcywgX2lkc1RvUmVzb2x2ZXIsIC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSkoKSk7XG4gICAgICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2Fib3J0LCBzaWduYWwgPyBuZXcgTmVzdGVkQWJvcnRDb250cm9sbGVyKHNpZ25hbCkgOiBuZXcgQWJvcnRDb250cm9sbGVyKCkpO1xuICAgICAgdGhpcy5leHBvcnRzID0gZXhwb3J0cyA/PyB7fTtcbiAgICAgIHRoaXMuaW1wb3J0cyA9IGNyZWF0ZVRocmVhZEltcG9ydHMoX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UaHJlYWRfaW5zdGFuY2VzLCBoYW5kbGVyRm9yQ2FsbF9mbikuYmluZCh0aGlzKSwgaW1wb3J0cyk7XG4gICAgICB0aGlzLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICAgIHRoaXMuc2VyaWFsaXphdGlvbiA9IHNlcmlhbGl6YXRpb247XG4gICAgICB0aGlzLmZ1bmN0aW9ucy5zdGFydD8uKHRoaXMpO1xuICAgICAgdGhpcy5zZXJpYWxpemF0aW9uLnN0YXJ0Py4odGhpcyk7XG4gICAgICB0aGlzLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGlkMiBvZiBfX3ByaXZhdGVHZXQodGhpcywgX2lkc1RvUmVzb2x2ZXIpLmtleXMoKSkge1xuICAgICAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVGhyZWFkX2luc3RhbmNlcywgcmVzb2x2ZUNhbGxfZm4pLmNhbGwodGhpcywgaWQyLCB2b2lkIDAsIG5ldyBUaHJlYWRDbG9zZWRFcnJvcigpKTtcbiAgICAgICAgfVxuICAgICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2lkc1RvUmVzb2x2ZXIpLmNsZWFyKCk7XG4gICAgICB9LCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgbWVzc2FnZXMubGlzdGVuKGFzeW5jIChyYXdEYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzVGhyZWFkTWVzc2FnZURhdGEgPSBBcnJheS5pc0FycmF5KHJhd0RhdGEpICYmIHR5cGVvZiByYXdEYXRhWzBdID09PSBcIm51bWJlclwiO1xuICAgICAgICBpZiAoIWlzVGhyZWFkTWVzc2FnZURhdGEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHJhd0RhdGE7XG4gICAgICAgIHN3aXRjaCAoZGF0YVswXSkge1xuICAgICAgICAgIGNhc2UgTUVTU0FHRV9DQUxMOiB7XG4gICAgICAgICAgICBjb25zdCBbLCBpZDIsIHByb3BlcnR5LCBhcmdzXSA9IGRhdGE7XG4gICAgICAgICAgICBjb25zdCBmdW5jID0gdGhpcy5leHBvcnRzW3Byb3BlcnR5XSA/PyAoKCkgPT4ge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxgTm8gJ1xcJHtwcm9wZXJ0eX0nIG1ldGhvZCBpcyBleHBvcnRlZCBmcm9tIHRoaXMgdGhyZWFkXFxgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UaHJlYWRfaW5zdGFuY2VzLCBjYWxsTG9jYWxfZm4pLmNhbGwodGhpcywgZnVuYywgYXJncywgKHZhbHVlLCBlcnJvciwgdHJhbnNmZXJhYmxlKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMubWVzc2FnZXMuc2VuZChbTUVTU0FHRV9DQUxMX1JFU1VMVCwgaWQyLCB2YWx1ZSwgZXJyb3JdLCB0cmFuc2ZlcmFibGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBNRVNTQUdFX0ZVTkNUSU9OX0NBTEw6IHtcbiAgICAgICAgICAgIGNvbnN0IFssIGNhbGxJRCwgZnVuY0lELCBhcmdzXSA9IGRhdGE7XG4gICAgICAgICAgICBjb25zdCBmdW5jID0gdGhpcy5mdW5jdGlvbnMuZ2V0KGZ1bmNJRCwgdGhpcykgPz8gbWlzc2luZ1RocmVhZEZ1bmN0aW9uO1xuICAgICAgICAgICAgYXdhaXQgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UaHJlYWRfaW5zdGFuY2VzLCBjYWxsTG9jYWxfZm4pLmNhbGwodGhpcywgZnVuYywgYXJncywgKHZhbHVlLCBlcnJvciwgdHJhbnNmZXJhYmxlKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMubWVzc2FnZXMuc2VuZChbTUVTU0FHRV9GVU5DVElPTl9SRVNVTFQsIGNhbGxJRCwgdmFsdWUsIGVycm9yXSwgdHJhbnNmZXJhYmxlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgTUVTU0FHRV9DQUxMX1JFU1VMVDpcbiAgICAgICAgICBjYXNlIE1FU1NBR0VfRlVOQ1RJT05fUkVTVUxUOiB7XG4gICAgICAgICAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX1RocmVhZF9pbnN0YW5jZXMsIHJlc29sdmVDYWxsX2ZuKS5jYWxsKHRoaXMsIC4uLmRhdGEuc2xpY2UoMSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgTUVTU0FHRV9GVU5DVElPTl9SRUxFQVNFOiB7XG4gICAgICAgICAgICBjb25zdCBpZDIgPSBkYXRhWzFdO1xuICAgICAgICAgICAgdGhpcy5mdW5jdGlvbnMucmVsZWFzZShpZDIsIHRoaXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbDogdGhpcy5zaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgdGhhdCBleHBvc2VzIHRoZSBtZXRob2RzIHRoYXQgY2FuIGJlIGNhbGxlZCBvbiB0aGUgcGFpcmVkIHRocmVhZC5cbiAgICAgKiBUaGlzIG9iamVjdCB3aWxsIGF1dG9tYXRpY2FsbHkgZW5jb2RlIGFuZCBkZWNvZGUgYXJndW1lbnRzIGFuZCByZXR1cm4gdmFsdWVzXG4gICAgICogYXMgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCB0aGF0IGV4cG9zZXMgdGhlIG1ldGhvZHMgdGhhdCBjYW4gYmUgY2FsbGVkIG9uIHRoaXMgdGhyZWFkIGJ5IHRoZVxuICAgICAqIHBhaXJlZCB0aHJlYWQuIFRvIHNldCB0aGVzZSBtZXRob2RzLCBwYXNzIHRoZSBcXGBleHBvcnRzXFxgIG9wdGlvbiB3aGVuIGNyZWF0aW5nXG4gICAgICogYSBuZXcgXFxgVGhyZWFkXFxgLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCB0aGF0IHByb3ZpZGVzIHRoZSBtZXNzYWdlLXBhc3NpbmcgaW50ZXJmYWNlIHRoYXQgYWxsb3dzIGNvbW11bmljYXRpb25cbiAgICAgKiB0byBmbG93IGJldHdlZW4gZW52aXJvbm1lbnRzLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCB0aGF0IG1hbmFnZXMgaG93IGZ1bmN0aW9ucyBhcmUgcHJveGllZCBiZXR3ZWVuIHRocmVhZHMuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHRoYXQgbWFuYWdlcyBob3cgdmFsdWVzIGFyZSBzZXJpYWxpemVkIGFuZCBkZXNlcmlhbGl6ZWQgYmV0d2VlbiB0aHJlYWRzLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEFuIFxcYEFib3J0U2lnbmFsXFxgIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNvbW11bmljYXRpb24gY2hhbm5lbCBpcyBzdGlsbCBvcGVuLlxuICAgICAqL1xuICAgIGdldCBzaWduYWwoKSB7XG4gICAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9hYm9ydCkuc2lnbmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjb21tdW5pY2F0aW9uIGNoYW5uZWwgaXMgc3RpbGwgb3Blbi5cbiAgICAgKi9cbiAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfYWJvcnQpLnNpZ25hbC5hYm9ydGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGNvbW11bmljYXRpb24gY2hhbm5lbCBiZXR3ZWVuIHRoZSB0d28gdGhyZWFkcy4gVGhpcyB3aWxsIHByZXZlbnRcbiAgICAgKiBhbnkgZnVydGhlciBjb21tdW5pY2F0aW9uIGJldHdlZW4gdGhlIHRocmVhZHMsIGFuZCB3aWxsIGNsZWFuIHVwIGFueSBtZW1vcnlcbiAgICAgKiBhc3NvY2lhdGVkIHdpdGggaW4tcHJvZ3Jlc3MgY29tbXVuaWNhdGlvbi4gSXQgd2lsbCBhbHNvIHJlamVjdCBhbnkgaW5mbGlnaHRcbiAgICAgKiBmdW5jdGlvbiBjYWxscyBiZXR3ZWVuIHRocmVhZHMgd2l0aCBhIFxcYFRocmVhZENsb3NlZEVycm9yXFxgLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9hYm9ydCkuYWJvcnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgdGhhdCB0aGUgdGhyZWFkIHByb3ZpZGUgdGhlIGNvbnRleHQgbmVlZGVkIHRvIG1ha2UgYSBmdW5jdGlvblxuICAgICAqIGNhbGwgYmV0d2VlbiB0aHJlYWRzLiBZb3UgcHJvdmlkZSB0aGlzIG1ldGhvZCBhIGZ1bmN0aW9uIHRvIGNhbGwgYW5kIHRoZVxuICAgICAqIHVuc2VyaWFsaXplZCBhcmd1bWVudHMgeW91IHdpc2ggdG8gY2FsbCBpdCB3aXRoLCBhbmQgdGhlIHRocmVhZCB3aWxsIGNhbGxcbiAgICAgKiB0aGUgZnVuY3Rpb24geW91IHByb3ZpZGVkIHdpdGggYSBzZXJpYWxpemVkIGNhbGwgSUQsIHRoZSBzZXJpYWxpemVkIGFyZ3VtZW50cyxcbiAgICAgKiBhbmQgYW55IHRyYW5zZmVyYWJsZSBvYmplY3RzIHRoYXQgbmVlZCB0byBiZSBwYXNzZWQgYmV0d2VlbiB0aHJlYWRzLlxuICAgICAqL1xuICAgIGNhbGwoZnVuYywgYXJncykge1xuICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVGhyZWFkQ2xvc2VkRXJyb3IoKSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2ZlcmFibGUgPSBbXTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB0aGlzLnNlcmlhbGl6YXRpb24uc2VyaWFsaXplKGFyZ3MsIHRoaXMsIHRyYW5zZmVyYWJsZSk7XG4gICAgICBjb25zdCBpZDIgPSBuYW5vaWQoKTtcbiAgICAgIGNvbnN0IGRvbmUgPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX1RocmVhZF9pbnN0YW5jZXMsIHdhaXRGb3JSZXN1bHRfZm4pLmNhbGwodGhpcywgaWQyKTtcbiAgICAgIGZ1bmMoaWQyLCBzZXJpYWxpemVkLCB0cmFuc2ZlcmFibGUpO1xuICAgICAgcmV0dXJuIGRvbmU7XG4gICAgfVxuICB9O1xuICBfYWJvcnQgPSBuZXcgV2Vha01hcCgpO1xuICBfaWRzVG9SZXNvbHZlciA9IG5ldyBXZWFrTWFwKCk7XG4gIF9UaHJlYWRfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKTtcbiAgY2FsbExvY2FsX2ZuID0gYXN5bmMgZnVuY3Rpb24oZnVuYywgYXJncywgd2l0aFJlc3VsdCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmZ1bmN0aW9ucy5jYWxsID8gYXdhaXQgdGhpcy5mdW5jdGlvbnMuY2FsbChmdW5jLCBhcmdzLCB0aGlzKSA6IGF3YWl0IGZ1bmMoLi4udGhpcy5zZXJpYWxpemF0aW9uLmRlc2VyaWFsaXplKGFyZ3MsIHRoaXMpKTtcbiAgICAgIGNvbnN0IHRyYW5zZmVyYWJsZSA9IFtdO1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHRoaXMuc2VyaWFsaXphdGlvbi5zZXJpYWxpemUocmVzdWx0LCB0aGlzLCB0cmFuc2ZlcmFibGUpO1xuICAgICAgd2l0aFJlc3VsdChzZXJpYWxpemVkLCB2b2lkIDAsIHRyYW5zZmVyYWJsZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHdpdGhSZXN1bHQodm9pZCAwLCB0aGlzLnNlcmlhbGl6YXRpb24uc2VyaWFsaXplKGVycm9yLCB0aGlzKSk7XG4gICAgfVxuICB9O1xuICBoYW5kbGVyRm9yQ2FsbF9mbiA9IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBwcm9wZXJ0eSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXGBDYW7igJl0IGNhbGwgYSBzeW1ib2wgbWV0aG9kIG9uIGEgdGhyZWFkOiBcXCR7cHJvcGVydHkudG9TdHJpbmcoKX1cXGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoKGlkMiwgc2VyaWFsaXplZEFyZ3MsIHRyYW5zZmVyYWJsZSkgPT4ge1xuICAgICAgICAgIHRoaXMubWVzc2FnZXMuc2VuZChbTUVTU0FHRV9DQUxMLCBpZDIsIHByb3BlcnR5LCBzZXJpYWxpemVkQXJnc10sIHRyYW5zZmVyYWJsZSk7XG4gICAgICAgIH0sIGFyZ3MpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICByZXNvbHZlQ2FsbF9mbiA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjYWxsSUQgPSBhcmdzWzBdO1xuICAgIGNvbnN0IHJlc29sdmVyID0gX19wcml2YXRlR2V0KHRoaXMsIF9pZHNUb1Jlc29sdmVyKS5nZXQoY2FsbElEKTtcbiAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgIHJlc29sdmVyKC4uLmFyZ3MpO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9pZHNUb1Jlc29sdmVyKS5kZWxldGUoY2FsbElEKTtcbiAgICB9XG4gIH07XG4gIHdhaXRGb3JSZXN1bHRfZm4gPSBmdW5jdGlvbihpZDIpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9pZHNUb1Jlc29sdmVyKS5zZXQoaWQyLCAoXywgdmFsdWUsIGVycm9yKSA9PiB7XG4gICAgICAgIGlmIChlcnJvciA9PSBudWxsKSB7XG4gICAgICAgICAgcmVzb2x2ZSh0aGlzLnNlcmlhbGl6YXRpb24uZGVzZXJpYWxpemUodmFsdWUsIHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QodGhpcy5zZXJpYWxpemF0aW9uLmRlc2VyaWFsaXplKGVycm9yLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBTeW1ib2wuYXN5bmNJdGVyYXRvciwge1xuICAgICAgYXN5bmMgKnZhbHVlKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBTeW1ib2wuYXN5bmNJdGVyYXRvciwge1xuICAgICAgICAgIHZhbHVlOiAoKSA9PiByZXN1bHRcbiAgICAgICAgfSk7XG4gICAgICAgIHlpZWxkKiByZXN1bHQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG4gIGZ1bmN0aW9uIGNyZWF0ZVRocmVhZEltcG9ydHMoaGFuZGxlckZvckltcG9ydCwgaW1wb3J0ZWQpIHtcbiAgICBsZXQgY2FsbDtcbiAgICBpZiAoaW1wb3J0ZWQgPT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBQcm94eSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXGBZb3UgbXVzdCBwYXNzIGFuIGFycmF5IG9mIGNhbGxhYmxlIG1ldGhvZHMgaW4gZW52aXJvbm1lbnRzIHdpdGhvdXQgUHJveGllcy5cXGApO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY2FsbCA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgICBnZXQoX3RhcmdldCwgcHJvcGVydHkpIHtcbiAgICAgICAgICBpZiAoY2FjaGUuaGFzKHByb3BlcnR5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmdldChwcm9wZXJ0eSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyRm9ySW1wb3J0KHByb3BlcnR5KTtcbiAgICAgICAgICBjYWNoZS5zZXQocHJvcGVydHksIGhhbmRsZXIpO1xuICAgICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBtZXRob2Qgb2YgaW1wb3J0ZWQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNhbGwsIG1ldGhvZCwge1xuICAgICAgICAgIHZhbHVlOiBoYW5kbGVyRm9ySW1wb3J0KG1ldGhvZCksXG4gICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuICBmdW5jdGlvbiBtaXNzaW5nVGhyZWFkRnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxcYFlvdSBhdHRlbXB0ZWQgdG8gY2FsbCBhIGZ1bmN0aW9uIHRoYXQgaXMgbm90IHN0b3JlZC4gSXQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbGVhc2VkLlxcYCk7XG4gIH1cblxuICAvLyAuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHF1aWx0ZWQrdGhyZWFkc0AzLjEuM19AcHJlYWN0K3NpZ25hbHMtY29yZUAxLjEwLjAvbm9kZV9tb2R1bGVzL0BxdWlsdGVkL3RocmVhZHMvYnVpbGQvZXNtL3RocmVhZHMvd2luZG93L3NoYXJlZC5tanNcbiAgdmFyIENIRUNLX01FU1NBR0UgPSBcInF1aWx0LnRocmVhZHMucGluZ1wiO1xuICB2YXIgUkVTUE9OU0VfTUVTU0FHRSA9IFwicXVpbHQudGhyZWFkcy5wb25nXCI7XG5cbiAgLy8gLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BxdWlsdGVkK3RocmVhZHNAMy4xLjNfQHByZWFjdCtzaWduYWxzLWNvcmVAMS4xMC4wL25vZGVfbW9kdWxlcy9AcXVpbHRlZC90aHJlYWRzL2J1aWxkL2VzbS90aHJlYWRzL3dpbmRvdy9UaHJlYWROZXN0ZWRXaW5kb3cubWpzXG4gIGZ1bmN0aW9uIG5lc3RlZFdpbmRvd1RvVGhyZWFkVGFyZ2V0KHBhcmVudCwge1xuICAgIHRhcmdldE9yaWdpbiA9IFwiKlwiXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlYWR5ID0gKCkgPT4ge1xuICAgICAgY29uc3QgcmVzcG9uZCA9ICgpID0+IHBhcmVudC5wb3N0TWVzc2FnZShSRVNQT05TRV9NRVNTQUdFLCB0YXJnZXRPcmlnaW4pO1xuICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoe1xuICAgICAgICBkYXRhLFxuICAgICAgICBzb3VyY2VcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gcGFyZW50KSByZXR1cm47XG4gICAgICAgIGlmIChkYXRhID09PSBDSEVDS19NRVNTQUdFKSByZXNwb25kKCk7XG4gICAgICB9KTtcbiAgICAgIHJlc3BvbmQoKTtcbiAgICB9O1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgIHJlYWR5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgIHJlYWR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2VuZChtZXNzYWdlLCB0cmFuc2Zlcikge1xuICAgICAgICByZXR1cm4gcGFyZW50LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRhcmdldE9yaWdpbiwgdHJhbnNmZXIpO1xuICAgICAgfSxcbiAgICAgIGxpc3RlbihsaXN0ZW4sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KSB7XG4gICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50LmRhdGEgPT09IENIRUNLX01FU1NBR0UpIHJldHVybjtcbiAgICAgICAgICBsaXN0ZW4oZXZlbnQuZGF0YSk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIC4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AcXVpbHRlZCt0aHJlYWRzQDMuMS4zX0BwcmVhY3Qrc2lnbmFscy1jb3JlQDEuMTAuMC9ub2RlX21vZHVsZXMvQHF1aWx0ZWQvdGhyZWFkcy9idWlsZC9lc20vdGhyZWFkcy9UaHJlYWROZXN0ZWRJZnJhbWUubWpzXG4gIHZhciBUaHJlYWROZXN0ZWRJZnJhbWUgPSBjbGFzcyBleHRlbmRzIFRocmVhZCB7XG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgcGFyZW50ID0gZ2xvYmFsVGhpcy5wYXJlbnQsXG4gICAgICB0YXJnZXRPcmlnaW4gPSBcIipcIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9ID0ge30pIHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiB8fCBwYXJlbnQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgYXJlIG5vdCBpbnNpZGUgYW4gaWZyYW1lLCBiZWNhdXNlIHRoZXJlIGlzIG5vIHBhcmVudCB3aW5kb3cuXCIpO1xuICAgICAgfVxuICAgICAgc3VwZXIobmVzdGVkV2luZG93VG9UaHJlYWRUYXJnZXQocGFyZW50LCB7XG4gICAgICAgIHRhcmdldE9yaWdpblxuICAgICAgfSksIG9wdGlvbnMpO1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICB9O1xuXG4gIC8vIHNjcmlwdHMvaWZyYW1lLWVudHJ5LmpzXG4gIG5ldyBUaHJlYWROZXN0ZWRJZnJhbWUoe1xuICAgIGV4cG9ydHM6IHtcbiAgICAgIGFzeW5jIHJlbmRlcihvcHRpb25zLCByZWNlaXZlciwgaG9zdEFwaSkge1xuICAgICAgICBpZiAob3B0aW9ucy5yZW1vdGVFbGVtZW50cykge1xuICAgICAgICAgIG9wdGlvbnMucmVtb3RlRWxlbWVudHMuZm9yRWFjaCgoZGVmKSA9PiB7XG4gICAgICAgICAgICBpZiAoY3VzdG9tRWxlbWVudHMuZ2V0KGRlZi50YWdOYW1lKSkgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgUmVtb3RlRWxlbWVudCB7XG4gICAgICAgICAgICAgIHN0YXRpYyBnZXQgcmVtb3RlQXR0cmlidXRlcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmLnJlbW90ZUF0dHJpYnV0ZXMgfHwgW107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdGljIGdldCByZW1vdGVFdmVudHMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZi5yZW1vdGVFdmVudHMgfHwgW107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVtb3RlRWxlbWVudCwgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IFxcYFJlbW90ZVxcJHtkZWYudGFnTmFtZS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIC8oXnd8LXcpL2csXG4gICAgICAgICAgICAgICAgKGMpID0+IGMucmVwbGFjZShcIi1cIiwgXCJcIikudG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgICApfVxcYFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoZGVmLnRhZ05hbWUsIHJlbW90ZUVsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvb3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3Jvb3RcIik7XG4gICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlbW90ZU11dGF0aW9uT2JzZXJ2ZXIocmVjZWl2ZXIpO1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHJvb3QpO1xuICAgICAgICBjb25zdCB7IGNvZGUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChjb2RlICYmIHJvb3QpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc2NyaXB0RnVuY3Rpb24gPSBuZXcgRnVuY3Rpb24oXCJyb290XCIsIFwiY29uc29sZVwiLCBjb2RlKTtcbiAgICAgICAgICAgIHNjcmlwdEZ1bmN0aW9uKHJvb3QsIGNvbnNvbGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBleGVjdXRpbmcgcmVtb3RlIHNjcmlwdDpcIiwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cbiAgPFxcL3NjcmlwdD5cbjwvYm9keT5cbjwvaHRtbD5gLCB2ZSA9IDEsIHllID0gMiwgTGUgPSAzLCBUZSA9IDQsIFVlID0gNSwgZ2UgPSBTeW1ib2wuZm9yKFwicXVpbHQudGhyZWFkcy5zZXJpYWxpemVcIiksIHl0ID0gU3ltYm9sLmZvcihcInF1aWx0LnRocmVhZHMudHJhbnNmZXJhYmxlXCIpO1xuY2xhc3MgVHQgZXh0ZW5kcyBBYm9ydENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvciguLi5lKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB0ID0gZS5maW5kKChuKSA9PiBuLmFib3J0ZWQpO1xuICAgIGlmICh0KVxuICAgICAgdGhpcy5hYm9ydCh0LnJlYXNvbik7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBuID0gKG8pID0+IHRoaXMuYWJvcnQoby50YXJnZXQucmVhc29uKSwgcyA9IHtcbiAgICAgICAgc2lnbmFsOiB0aGlzLnNpZ25hbFxuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3QgbyBvZiBlKVxuICAgICAgICBvLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBuLCBzKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFJlIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIllvdSBhdHRlbXB0ZWQgdG8gY2FsbCBhIGZ1bmN0aW9uIG9uIGEgY2xvc2VkIHRocmVhZC5cIik7XG4gIH1cbn1cbmxldCBndCA9IFwidXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdFwiO1xuZnVuY3Rpb24gemUociA9IDIxKSB7XG4gIGxldCBlID0gXCJcIiwgdCA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkocikpO1xuICBmb3IgKGxldCBuID0gMDsgbiA8IHI7IG4rKykgZSArPSBndFs2MyAmIHRbbl1dO1xuICByZXR1cm4gZTtcbn1cbnZhciBZLCB4LCBHLCBLLCBlZSwgeGU7XG5jbGFzcyBSdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIFModGhpcywgZWUpO1xuICAgIFModGhpcywgWSwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgUyh0aGlzLCB4LCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBTKHRoaXMsIEcsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIFModGhpcywgSywgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICB9XG4gIGdldChlKSB7XG4gICAgcmV0dXJuIGIodGhpcywgeCkuZ2V0KGUpO1xuICB9XG4gIHJlbGVhc2UoZSkge1xuICAgIGNvbnN0IHQgPSBiKHRoaXMsIHgpLmdldChlKTtcbiAgICByZXR1cm4gdCAmJiAoYih0aGlzLCB4KS5kZWxldGUoZSksIGIodGhpcywgWSkuZGVsZXRlKHQpKSwgISF0O1xuICB9XG4gIHNlcmlhbGl6ZShlKSB7XG4gICAgbGV0IHQgPSBiKHRoaXMsIFkpLmdldChlKTtcbiAgICByZXR1cm4gdCA9PSBudWxsICYmICh0ID0gemUoKSwgYih0aGlzLCBZKS5zZXQoZSwgdCksIGIodGhpcywgeCkuc2V0KHQsIGUpKSwgdDtcbiAgfVxuICBkZXNlcmlhbGl6ZShlLCB0KSB7XG4gICAgdmFyIHMsIG87XG4gICAgbGV0IG4gPSAocyA9IGIodGhpcywgRykuZ2V0KGUpKSA9PSBudWxsID8gdm9pZCAwIDogcy5kZXJlZigpO1xuICAgIHJldHVybiBuIHx8IChuID0gKC4uLmEpID0+IHtcbiAgICAgIGlmICghYih0aGlzLCBHKS5oYXMoZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBhdHRlbXB0ZWQgdG8gY2FsbCBhIGZ1bmN0aW9uIHRoYXQgd2FzIGFscmVhZHkgcmV2b2tlZC5cIik7XG4gICAgICByZXR1cm4gdC5jYWxsKCh1LCBsLCBmKSA9PiB7XG4gICAgICAgIHQubWVzc2FnZXMuc2VuZChbTGUsIHUsIGUsIGxdLCBmKTtcbiAgICAgIH0sIGEpO1xuICAgIH0sIChvID0geSh0aGlzLCBlZSwgeGUpLmNhbGwodGhpcywgdCkpID09IG51bGwgfHwgby5yZWdpc3RlcihuLCBlKSwgYih0aGlzLCBHKS5zZXQoZSwgbmV3IFdlYWtSZWYobikpLCBuKTtcbiAgfVxufVxuWSA9IG5ldyBXZWFrTWFwKCksIHggPSBuZXcgV2Vha01hcCgpLCBHID0gbmV3IFdlYWtNYXAoKSwgSyA9IG5ldyBXZWFrTWFwKCksIGVlID0gbmV3IFdlYWtTZXQoKSwgeGUgPSBmdW5jdGlvbihlKSB7XG4gIGxldCB0ID0gYih0aGlzLCBLKS5nZXQoZSk7XG4gIGlmICghKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA+IFwidVwiKSlcbiAgICByZXR1cm4gdCB8fCAodCA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgobikgPT4ge1xuICAgICAgZS5tZXNzYWdlcy5zZW5kKFtVZSwgbl0pO1xuICAgIH0pLCBiKHRoaXMsIEspLnNldChlLCB0KSksIHQ7XG59O1xuZnVuY3Rpb24gd3Qocikge1xuICByZXR1cm4gciAhPSBudWxsICYmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByIHx8IFN5bWJvbC5pdGVyYXRvciBpbiByKSAmJiB0eXBlb2Ygci5uZXh0ID09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIHdlKHIpIHtcbiAgaWYgKHIgPT0gbnVsbCB8fCB0eXBlb2YgciAhPSBcIm9iamVjdFwiKSByZXR1cm4gITE7XG4gIGNvbnN0IGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yocik7XG4gIHJldHVybiBlID09IG51bGwgfHwgZSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cbmNvbnN0IGllID0gXCJfQGZcIiwgU2UgPSBcIl9AaVwiO1xudmFyIFYsIFcsIHcsIFEsIE87XG5jbGFzcyBTdCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBTKHRoaXMsIHcpO1xuICAgIFModGhpcywgVik7XG4gICAgUyh0aGlzLCBXKTtcbiAgICBaKHRoaXMsIFYsIGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuc2VyaWFsaXplKSwgWih0aGlzLCBXLCBlID09IG51bGwgPyB2b2lkIDAgOiBlLmRlc2VyaWFsaXplKTtcbiAgfVxuICAvKipcbiAgICogU2VyaWFsaXplcyBhIHZhbHVlIGludG8gYSBzdHJ1Y3R1cmVkIGNsb25pbmctY29tcGF0aWJsZSBmb3JtYXQgdGhhdCBjYW4gYmUgdHJhbnNmZXJyZWQgYmV0d2VlbiB0aHJlYWRzLlxuICAgKi9cbiAgc2VyaWFsaXplKGUsIHQsIG4pIHtcbiAgICByZXR1cm4geSh0aGlzLCB3LCBRKS5jYWxsKHRoaXMsIGUsIHQsIG4pO1xuICB9XG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZXMgYSBzdHJ1Y3R1cmVkIGNsb25pbmctY29tcGF0aWJsZSB2YWx1ZSBmcm9tIGFub3RoZXIgdGhyZWFkLlxuICAgKi9cbiAgZGVzZXJpYWxpemUoZSwgdCkge1xuICAgIHJldHVybiB5KHRoaXMsIHcsIE8pLmNhbGwodGhpcywgZSwgdCk7XG4gIH1cbn1cblYgPSBuZXcgV2Vha01hcCgpLCBXID0gbmV3IFdlYWtNYXAoKSwgdyA9IG5ldyBXZWFrU2V0KCksIFEgPSBmdW5jdGlvbihlLCB0LCBuLCBzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgbyA9ICExKSB7XG4gIGlmIChlID09IG51bGwpIHJldHVybiBlO1xuICBpZiAocy5oYXMoZSkpIHJldHVybiBzLmdldChlKTtcbiAgaWYgKHMuc2V0KGUsIHZvaWQgMCksIHR5cGVvZiBlID09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoYih0aGlzLCBWKSAmJiAhbykge1xuICAgICAgY29uc3QgbCA9IGIodGhpcywgVikuY2FsbCh0aGlzLCBlLCAoZikgPT4geSh0aGlzLCB3LCBRKS5jYWxsKHRoaXMsIGYsIHQsIG4sIHMsICEwKSwgdCwgbik7XG4gICAgICBpZiAobCAhPT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gcy5zZXQoZSwgbCksIGw7XG4gICAgfVxuICAgIGlmIChlW3l0XSlcbiAgICAgIHJldHVybiBuID09IG51bGwgfHwgbi5wdXNoKGUpLCBzLnNldChlLCBlKSwgZTtcbiAgICBjb25zdCBhID0gKGwpID0+IHkodGhpcywgdywgUSkuY2FsbCh0aGlzLCBsLCB0LCBuLCBzKTtcbiAgICBpZiAodHlwZW9mIGVbZ2VdID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc3QgbCA9IGVbZ2VdKHtcbiAgICAgICAgc2VyaWFsaXplOiBhXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzLnNldChlLCBsKSwgbDtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGNvbnN0IGwgPSBlLm1hcCgoZikgPT4gYShmKSk7XG4gICAgICByZXR1cm4gcy5zZXQoZSwgbCksIGw7XG4gICAgfVxuICAgIGlmIChlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICBjb25zdCBsID0gWy4uLmUuZW50cmllcygpXS5tYXAoKFtpLCBtXSkgPT4gW2EoaSksIGEobSldKSwgZiA9IG5ldyBNYXAobCk7XG4gICAgICByZXR1cm4gcy5zZXQoZSwgZiksIGY7XG4gICAgfVxuICAgIGlmIChlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICBjb25zdCBsID0gWy4uLmVdLm1hcCgoaSkgPT4gYShpKSksIGYgPSBuZXcgU2V0KGwpO1xuICAgICAgcmV0dXJuIHMuc2V0KGUsIGYpLCBmO1xuICAgIH1cbiAgICBjb25zdCB1ID0gd3QoZSk7XG4gICAgaWYgKHdlKGUpIHx8IHUpIHtcbiAgICAgIGNvbnN0IGwgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgZiBvZiBPYmplY3Qua2V5cyhlKSlcbiAgICAgICAgbFtmXSA9IGEoZVtmXSk7XG4gICAgICByZXR1cm4gdSAmJiAobC5uZXh0ID8/IChsLm5leHQgPSBhKGUubmV4dC5iaW5kKGUpKSksIGwucmV0dXJuID8/IChsLnJldHVybiA9IGEoZS5yZXR1cm4uYmluZChlKSkpLCBsLnRocm93ID8/IChsLnRocm93ID0gYShlLnRocm93LmJpbmQoZSkpKSwgbFtTZV0gPSAhMCksIHMuc2V0KGUsIGwpLCBsO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3QgYSA9IHQuZnVuY3Rpb25zLnNlcmlhbGl6ZShlLCB0LCBuKSwgdSA9IHtcbiAgICAgIFtpZV06IGFcbiAgICB9O1xuICAgIHJldHVybiBzLnNldChlLCB1KSwgdTtcbiAgfVxuICByZXR1cm4gcy5zZXQoZSwgZSksIGU7XG59LCBPID0gZnVuY3Rpb24oZSwgdCwgbiA9ICExKSB7XG4gIGlmIChlID09IG51bGwpIHJldHVybiBlO1xuICBpZiAodHlwZW9mIGUgPT0gXCJvYmplY3RcIikge1xuICAgIGlmIChiKHRoaXMsIFcpICYmICFuKSB7XG4gICAgICBjb25zdCBvID0gYih0aGlzLCBXKS5jYWxsKHRoaXMsIGUsIChhKSA9PiB5KHRoaXMsIHcsIE8pLmNhbGwodGhpcywgYSwgdCwgITApLCB0KTtcbiAgICAgIGlmIChvICE9PSB2b2lkIDApXG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgICBpZiAoZSA9PSBudWxsKVxuICAgICAgcmV0dXJuIGU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpXG4gICAgICByZXR1cm4gZS5tYXAoKG8pID0+IHkodGhpcywgdywgTykuY2FsbCh0aGlzLCBvLCB0KSk7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBNYXApXG4gICAgICByZXR1cm4gbmV3IE1hcChbLi4uZV0ubWFwKChbbywgYV0pID0+IFt5KHRoaXMsIHcsIE8pLmNhbGwodGhpcywgbywgdCksIHkodGhpcywgdywgTykuY2FsbCh0aGlzLCBhLCB0KV0pKTtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFNldClcbiAgICAgIHJldHVybiBuZXcgU2V0KFsuLi5lXS5tYXAoKG8pID0+IHkodGhpcywgdywgTykuY2FsbCh0aGlzLCBvLCB0KSkpO1xuICAgIGlmIChpZSBpbiBlKVxuICAgICAgcmV0dXJuIHQuZnVuY3Rpb25zLmRlc2VyaWFsaXplKGVbaWVdLCB0KTtcbiAgICBpZiAoIXdlKGUpKVxuICAgICAgcmV0dXJuIGU7XG4gICAgY29uc3QgcyA9IHt9O1xuICAgIGZvciAoY29uc3QgbyBvZiBPYmplY3Qua2V5cyhlKSlcbiAgICAgIG8gPT09IFNlID8gc1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSAoKSA9PiBzIDogc1tvXSA9IHkodGhpcywgdywgTykuY2FsbCh0aGlzLCBlW29dLCB0KTtcbiAgICByZXR1cm4gcztcbiAgfVxuICByZXR1cm4gZTtcbn07XG52YXIgaywgRCwgTSwgYWUsIGtlLCBsZSwgamU7XG5jbGFzcyBNdCB7XG4gIGNvbnN0cnVjdG9yKGUsIHtcbiAgICBpbXBvcnRzOiB0LFxuICAgIGV4cG9ydHM6IG4sXG4gICAgZnVuY3Rpb25zOiBzID0gbmV3IFJ0KCksXG4gICAgc2VyaWFsaXphdGlvbjogbyA9IG5ldyBTdCgpLFxuICAgIHNpZ25hbDogYVxuICB9ID0ge30pIHtcbiAgICBTKHRoaXMsIE0pO1xuICAgIFModGhpcywgayk7XG4gICAgUyh0aGlzLCBELCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICB2YXIgdSwgbCwgZiwgaTtcbiAgICB0aGlzLm1lc3NhZ2VzID0gZSwgWih0aGlzLCBrLCBhID8gbmV3IFR0KGEpIDogbmV3IEFib3J0Q29udHJvbGxlcigpKSwgdGhpcy5leHBvcnRzID0gbiA/PyB7fSwgdGhpcy5pbXBvcnRzID0gQXQoeSh0aGlzLCBNLCBrZSkuYmluZCh0aGlzKSwgdCksIHRoaXMuZnVuY3Rpb25zID0gcywgdGhpcy5zZXJpYWxpemF0aW9uID0gbywgKGwgPSAodSA9IHRoaXMuZnVuY3Rpb25zKS5zdGFydCkgPT0gbnVsbCB8fCBsLmNhbGwodSwgdGhpcyksIChpID0gKGYgPSB0aGlzLnNlcmlhbGl6YXRpb24pLnN0YXJ0KSA9PSBudWxsIHx8IGkuY2FsbChmLCB0aGlzKSwgdGhpcy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBiKHRoaXMsIEQpLmtleXMoKSlcbiAgICAgICAgeSh0aGlzLCBNLCBsZSkuY2FsbCh0aGlzLCBtLCB2b2lkIDAsIG5ldyBSZSgpKTtcbiAgICAgIGIodGhpcywgRCkuY2xlYXIoKTtcbiAgICB9LCB7XG4gICAgICBvbmNlOiAhMFxuICAgIH0pLCBlLmxpc3Rlbihhc3luYyAobSkgPT4ge1xuICAgICAgaWYgKCEoQXJyYXkuaXNBcnJheShtKSAmJiB0eXBlb2YgbVswXSA9PSBcIm51bWJlclwiKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgYyA9IG07XG4gICAgICBzd2l0Y2ggKGNbMF0pIHtcbiAgICAgICAgY2FzZSB2ZToge1xuICAgICAgICAgIGNvbnN0IFssIHAsIGgsIEVdID0gYywgXyA9IHRoaXMuZXhwb3J0c1toXSA/PyAoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyAnJHtofScgbWV0aG9kIGlzIGV4cG9ydGVkIGZyb20gdGhpcyB0aHJlYWRgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhd2FpdCB5KHRoaXMsIE0sIGFlKS5jYWxsKHRoaXMsIF8sIEUsIChSLCBBLCBUKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VzLnNlbmQoW3llLCBwLCBSLCBBXSwgVCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBMZToge1xuICAgICAgICAgIGNvbnN0IFssIHAsIGgsIEVdID0gYywgXyA9IHRoaXMuZnVuY3Rpb25zLmdldChoLCB0aGlzKSA/PyBOdDtcbiAgICAgICAgICBhd2FpdCB5KHRoaXMsIE0sIGFlKS5jYWxsKHRoaXMsIF8sIEUsIChSLCBBLCBUKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VzLnNlbmQoW1RlLCBwLCBSLCBBXSwgVCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSB5ZTpcbiAgICAgICAgY2FzZSBUZToge1xuICAgICAgICAgIHkodGhpcywgTSwgbGUpLmNhbGwodGhpcywgLi4uYy5zbGljZSgxKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBVZToge1xuICAgICAgICAgIGNvbnN0IHAgPSBjWzFdO1xuICAgICAgICAgIHRoaXMuZnVuY3Rpb25zLnJlbGVhc2UocCwgdGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBzaWduYWw6IHRoaXMuc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFuIG9iamVjdCB0aGF0IGV4cG9zZXMgdGhlIG1ldGhvZHMgdGhhdCBjYW4gYmUgY2FsbGVkIG9uIHRoZSBwYWlyZWQgdGhyZWFkLlxuICAgKiBUaGlzIG9iamVjdCB3aWxsIGF1dG9tYXRpY2FsbHkgZW5jb2RlIGFuZCBkZWNvZGUgYXJndW1lbnRzIGFuZCByZXR1cm4gdmFsdWVzXG4gICAqIGFzIG5lY2Vzc2FyeS5cbiAgICovXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgdGhhdCBleHBvc2VzIHRoZSBtZXRob2RzIHRoYXQgY2FuIGJlIGNhbGxlZCBvbiB0aGlzIHRocmVhZCBieSB0aGVcbiAgICogcGFpcmVkIHRocmVhZC4gVG8gc2V0IHRoZXNlIG1ldGhvZHMsIHBhc3MgdGhlIGBleHBvcnRzYCBvcHRpb24gd2hlbiBjcmVhdGluZ1xuICAgKiBhIG5ldyBgVGhyZWFkYC5cbiAgICovXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgdGhhdCBwcm92aWRlcyB0aGUgbWVzc2FnZS1wYXNzaW5nIGludGVyZmFjZSB0aGF0IGFsbG93cyBjb21tdW5pY2F0aW9uXG4gICAqIHRvIGZsb3cgYmV0d2VlbiBlbnZpcm9ubWVudHMuXG4gICAqL1xuICAvKipcbiAgICogQW4gb2JqZWN0IHRoYXQgbWFuYWdlcyBob3cgZnVuY3Rpb25zIGFyZSBwcm94aWVkIGJldHdlZW4gdGhyZWFkcy5cbiAgICovXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgdGhhdCBtYW5hZ2VzIGhvdyB2YWx1ZXMgYXJlIHNlcmlhbGl6ZWQgYW5kIGRlc2VyaWFsaXplZCBiZXR3ZWVuIHRocmVhZHMuXG4gICAqL1xuICAvKipcbiAgICogQW4gYEFib3J0U2lnbmFsYCB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBjb21tdW5pY2F0aW9uIGNoYW5uZWwgaXMgc3RpbGwgb3Blbi5cbiAgICovXG4gIGdldCBzaWduYWwoKSB7XG4gICAgcmV0dXJuIGIodGhpcywgaykuc2lnbmFsO1xuICB9XG4gIC8qKlxuICAgKiBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjb21tdW5pY2F0aW9uIGNoYW5uZWwgaXMgc3RpbGwgb3Blbi5cbiAgICovXG4gIGdldCBjbG9zZWQoKSB7XG4gICAgcmV0dXJuIGIodGhpcywgaykuc2lnbmFsLmFib3J0ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgY29tbXVuaWNhdGlvbiBjaGFubmVsIGJldHdlZW4gdGhlIHR3byB0aHJlYWRzLiBUaGlzIHdpbGwgcHJldmVudFxuICAgKiBhbnkgZnVydGhlciBjb21tdW5pY2F0aW9uIGJldHdlZW4gdGhlIHRocmVhZHMsIGFuZCB3aWxsIGNsZWFuIHVwIGFueSBtZW1vcnlcbiAgICogYXNzb2NpYXRlZCB3aXRoIGluLXByb2dyZXNzIGNvbW11bmljYXRpb24uIEl0IHdpbGwgYWxzbyByZWplY3QgYW55IGluZmxpZ2h0XG4gICAqIGZ1bmN0aW9uIGNhbGxzIGJldHdlZW4gdGhyZWFkcyB3aXRoIGEgYFRocmVhZENsb3NlZEVycm9yYC5cbiAgICovXG4gIGNsb3NlKCkge1xuICAgIGIodGhpcywgaykuYWJvcnQoKTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgdGhhdCB0aGUgdGhyZWFkIHByb3ZpZGUgdGhlIGNvbnRleHQgbmVlZGVkIHRvIG1ha2UgYSBmdW5jdGlvblxuICAgKiBjYWxsIGJldHdlZW4gdGhyZWFkcy4gWW91IHByb3ZpZGUgdGhpcyBtZXRob2QgYSBmdW5jdGlvbiB0byBjYWxsIGFuZCB0aGVcbiAgICogdW5zZXJpYWxpemVkIGFyZ3VtZW50cyB5b3Ugd2lzaCB0byBjYWxsIGl0IHdpdGgsIGFuZCB0aGUgdGhyZWFkIHdpbGwgY2FsbFxuICAgKiB0aGUgZnVuY3Rpb24geW91IHByb3ZpZGVkIHdpdGggYSBzZXJpYWxpemVkIGNhbGwgSUQsIHRoZSBzZXJpYWxpemVkIGFyZ3VtZW50cyxcbiAgICogYW5kIGFueSB0cmFuc2ZlcmFibGUgb2JqZWN0cyB0aGF0IG5lZWQgdG8gYmUgcGFzc2VkIGJldHdlZW4gdGhyZWFkcy5cbiAgICovXG4gIGNhbGwoZSwgdCkge1xuICAgIGlmICh0aGlzLmNsb3NlZClcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgUmUoKSk7XG4gICAgY29uc3QgbiA9IFtdLCBzID0gdGhpcy5zZXJpYWxpemF0aW9uLnNlcmlhbGl6ZSh0LCB0aGlzLCBuKSwgbyA9IHplKCksIGEgPSB5KHRoaXMsIE0sIGplKS5jYWxsKHRoaXMsIG8pO1xuICAgIHJldHVybiBlKG8sIHMsIG4pLCBhO1xuICB9XG59XG5rID0gbmV3IFdlYWtNYXAoKSwgRCA9IG5ldyBXZWFrTWFwKCksIE0gPSBuZXcgV2Vha1NldCgpLCBhZSA9IGFzeW5jIGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzID0gdGhpcy5mdW5jdGlvbnMuY2FsbCA/IGF3YWl0IHRoaXMuZnVuY3Rpb25zLmNhbGwoZSwgdCwgdGhpcykgOiBhd2FpdCBlKC4uLnRoaXMuc2VyaWFsaXphdGlvbi5kZXNlcmlhbGl6ZSh0LCB0aGlzKSksIG8gPSBbXSwgYSA9IHRoaXMuc2VyaWFsaXphdGlvbi5zZXJpYWxpemUocywgdGhpcywgbyk7XG4gICAgbihhLCB2b2lkIDAsIG8pO1xuICB9IGNhdGNoIChzKSB7XG4gICAgbih2b2lkIDAsIHRoaXMuc2VyaWFsaXphdGlvbi5zZXJpYWxpemUocywgdGhpcykpO1xuICB9XG59LCBrZSA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuICguLi50KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgZSAhPSBcInN0cmluZ1wiICYmIHR5cGVvZiBlICE9IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fu4oCZdCBjYWxsIGEgc3ltYm9sIG1ldGhvZCBvbiBhIHRocmVhZDogJHtlLnRvU3RyaW5nKCl9YCk7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsKChuLCBzLCBvKSA9PiB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMuc2VuZChbdmUsIG4sIGUsIHNdLCBvKTtcbiAgICAgIH0sIHQpO1xuICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuKTtcbiAgICB9XG4gIH07XG59LCBsZSA9IGZ1bmN0aW9uKC4uLmUpIHtcbiAgY29uc3QgdCA9IGVbMF0sIG4gPSBiKHRoaXMsIEQpLmdldCh0KTtcbiAgbiAmJiAobiguLi5lKSwgYih0aGlzLCBEKS5kZWxldGUodCkpO1xufSwgamUgPSBmdW5jdGlvbihlKSB7XG4gIGNvbnN0IHQgPSBuZXcgUHJvbWlzZSgobiwgcykgPT4ge1xuICAgIGIodGhpcywgRCkuc2V0KGUsIChvLCBhLCB1KSA9PiB7XG4gICAgICB1ID09IG51bGwgPyBuKHRoaXMuc2VyaWFsaXphdGlvbi5kZXNlcmlhbGl6ZShhLCB0aGlzKSkgOiBzKHRoaXMuc2VyaWFsaXphdGlvbi5kZXNlcmlhbGl6ZSh1LCB0aGlzKSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFN5bWJvbC5hc3luY0l0ZXJhdG9yLCB7XG4gICAgYXN5bmMgKnZhbHVlKCkge1xuICAgICAgY29uc3QgbiA9IGF3YWl0IHQ7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgU3ltYm9sLmFzeW5jSXRlcmF0b3IsIHtcbiAgICAgICAgdmFsdWU6ICgpID0+IG5cbiAgICAgIH0pLCB5aWVsZCogbjtcbiAgICB9XG4gIH0pLCB0O1xufTtcbmZ1bmN0aW9uIEF0KHIsIGUpIHtcbiAgbGV0IHQ7XG4gIGlmIChlID09IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIFByb3h5ICE9IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgYW4gYXJyYXkgb2YgY2FsbGFibGUgbWV0aG9kcyBpbiBlbnZpcm9ubWVudHMgd2l0aG91dCBQcm94aWVzLlwiKTtcbiAgICBjb25zdCBuID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0ID0gbmV3IFByb3h5KHt9LCB7XG4gICAgICBnZXQocywgbykge1xuICAgICAgICBpZiAobi5oYXMobykpXG4gICAgICAgICAgcmV0dXJuIG4uZ2V0KG8pO1xuICAgICAgICBjb25zdCBhID0gcihvKTtcbiAgICAgICAgcmV0dXJuIG4uc2V0KG8sIGEpLCBhO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgZSlcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBuLCB7XG4gICAgICAgIHZhbHVlOiByKG4pLFxuICAgICAgICB3cml0YWJsZTogITEsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgIGVudW1lcmFibGU6ICEwXG4gICAgICB9KTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIE50KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgYXR0ZW1wdGVkIHRvIGNhbGwgYSBmdW5jdGlvbiB0aGF0IGlzIG5vdCBzdG9yZWQuIEl0IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZWxlYXNlZC5cIik7XG59XG5jb25zdCBJdCA9IFwicXVpbHQudGhyZWFkcy5waW5nXCIsIE1lID0gXCJxdWlsdC50aHJlYWRzLnBvbmdcIjtcbmZ1bmN0aW9uIFB0KHIsIHtcbiAgdGFyZ2V0T3JpZ2luOiBlID0gXCIqXCJcbn0gPSB7fSkge1xuICBsZXQgdCA9ICExO1xuICBjb25zdCBuID0gZnVuY3Rpb24oYSwgdSkge1xuICAgIHIucG9zdE1lc3NhZ2UoYSwgZSwgdSk7XG4gIH0sIHMgPSBuZXcgUHJvbWlzZSgobykgPT4ge1xuICAgIGNvbnN0IGEgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgZ2xvYmFsVGhpcy53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKHUpID0+IHtcbiAgICAgIHUuc291cmNlID09PSByICYmIHUuZGF0YSA9PT0gTWUgJiYgKHQgPSAhMCwgYS5hYm9ydCgpLCBvKCkpO1xuICAgIH0sIHtcbiAgICAgIHNpZ25hbDogYS5zaWduYWxcbiAgICB9KSwgYS5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IG8oKSwge1xuICAgICAgb25jZTogITBcbiAgICB9KSwgbihJdCk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHNlbmQobywgYSkge1xuICAgICAgcmV0dXJuIHQgPyBuKG8sIGEpIDogcy50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHQpIHJldHVybiBuKG8sIGEpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBsaXN0ZW4obywge1xuICAgICAgc2lnbmFsOiBhXG4gICAgfSkge1xuICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAodSkgPT4ge1xuICAgICAgICB1LnNvdXJjZSA9PT0gciAmJiB1LmRhdGEgIT09IE1lICYmIG8odS5kYXRhKTtcbiAgICAgIH0sIHtcbiAgICAgICAgc2lnbmFsOiBhXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5jbGFzcyBPdCBleHRlbmRzIE10IHtcbiAgY29uc3RydWN0b3IoZSwge1xuICAgIHRhcmdldE9yaWdpbjogdCA9IFwiKlwiLFxuICAgIC4uLm5cbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoUHQoZS5jb250ZW50V2luZG93LCB7XG4gICAgICB0YXJnZXRPcmlnaW46IHRcbiAgICB9KSwgbiksIHRoaXMuaWZyYW1lID0gZTtcbiAgfVxufVxuY29uc3QgRmUgPSByZS5mb3J3YXJkUmVmKCh7IGNvbnRlbnQ6IHIsIGNoaWxkcmVuOiBlLCAuLi50IH0sIG4pID0+IC8qIEBfX1BVUkVfXyAqLyB2KFwic3BhblwiLCB7IHJlZjogbiwgLi4udCwgY2hpbGRyZW46IHIgfHwgZSB9KSk7XG5GZS5kaXNwbGF5TmFtZSA9IFwiVUlUZXh0XCI7XG5jb25zdCBZZSA9IHJlLmZvcndhcmRSZWYoKHsgbGFiZWw6IHIsIG9uUHJlc3M6IGUsIG9uQ2xpY2s6IHQsIGNoaWxkcmVuOiBuLCAuLi5zIH0sIG8pID0+IC8qIEBfX1BVUkVfXyAqLyB2KFxuICBcImJ1dHRvblwiLFxuICB7XG4gICAgcmVmOiBvLFxuICAgIG9uQ2xpY2s6ICh1KSA9PiB7XG4gICAgICBlICYmIGUoKSwgdCAmJiB0KHUpO1xuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIHBhZGRpbmc6IFwiOHB4IDE2cHhcIixcbiAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMDA3YmZmXCIsXG4gICAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgIGJvcmRlclJhZGl1czogXCI0cHhcIixcbiAgICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgICB9LFxuICAgIC4uLnMsXG4gICAgY2hpbGRyZW46IHIgfHwgblxuICB9XG4pKTtcblllLmRpc3BsYXlOYW1lID0gXCJVSUJ1dHRvblwiO1xuY29uc3QgR2UgPSByZS5mb3J3YXJkUmVmKFxuICAoe1xuICAgIGRpcmVjdGlvbjogciA9IFwidmVydGljYWxcIixcbiAgICBzcGFjaW5nOiBlID0gXCI4XCIsXG4gICAgYWxpZ246IHQgPSBcInN0cmV0Y2hcIixcbiAgICBqdXN0aWZ5OiBuID0gXCJmbGV4LXN0YXJ0XCIsXG4gICAgY2hpbGRyZW46IHMsXG4gICAgLi4ub1xuICB9LCBhKSA9PiAvKiBAX19QVVJFX18gKi8gdihcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIHJlZjogYSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICBmbGV4RGlyZWN0aW9uOiByID09PSBcImhvcml6b250YWxcIiA/IFwicm93XCIgOiBcImNvbHVtblwiLFxuICAgICAgICBnYXA6IGAke2V9cHhgLFxuICAgICAgICBhbGlnbkl0ZW1zOiB0LFxuICAgICAgICBqdXN0aWZ5Q29udGVudDogblxuICAgICAgfSxcbiAgICAgIC4uLm8sXG4gICAgICBjaGlsZHJlbjogc1xuICAgIH1cbiAgKVxuKTtcbkdlLmRpc3BsYXlOYW1lID0gXCJVSVN0YWNrXCI7XG5jb25zdCBWZSA9IHJlLmZvcndhcmRSZWYoKHsgc3JjOiByLCBhbHQ6IGUsIHdpZHRoOiB0LCBoZWlnaHQ6IG4sIGNoaWxkcmVuOiBzLCAuLi5vIH0sIGEpID0+IC8qIEBfX1BVUkVfXyAqLyB2KFxuICBcImltZ1wiLFxuICB7XG4gICAgcmVmOiBhLFxuICAgIHNyYzogcixcbiAgICBhbHQ6IGUsXG4gICAgd2lkdGg6IHQsXG4gICAgaGVpZ2h0OiBuLFxuICAgIHN0eWxlOiB7XG4gICAgICBtYXhXaWR0aDogXCIxMDAlXCIsXG4gICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgICAgYm9yZGVyUmFkaXVzOiBcIjhweFwiLFxuICAgICAgYm94U2hhZG93OiBcIjAgMnB4IDhweCByZ2JhKDAsIDAsIDAsIDAuMSlcIlxuICAgIH0sXG4gICAgLi4ub1xuICB9XG4pKTtcblZlLmRpc3BsYXlOYW1lID0gXCJVSUltYWdlXCI7XG5jb25zdCBXZSA9IHtcbiAgbmFtZTogXCJiYXNpY1wiLFxuICBlbGVtZW50czogW1xuICAgIHtcbiAgICAgIHRhZ05hbWU6IFwidWktdGV4dFwiLFxuICAgICAgY29tcG9uZW50OiBGZSxcbiAgICAgIHByb3BNYXBwaW5nOiB7XG4gICAgICAgIGNvbnRlbnQ6IFwiY29udGVudFwiXG4gICAgICB9LFxuICAgICAgZXZlbnRNYXBwaW5nOiB7fVxuICAgIH0sXG4gICAge1xuICAgICAgdGFnTmFtZTogXCJ1aS1idXR0b25cIixcbiAgICAgIGNvbXBvbmVudDogWWUsXG4gICAgICBwcm9wTWFwcGluZzoge1xuICAgICAgICBsYWJlbDogXCJsYWJlbFwiXG4gICAgICB9LFxuICAgICAgZXZlbnRNYXBwaW5nOiB7XG4gICAgICAgIHByZXNzOiBcIm9uUHJlc3NcIlxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgdGFnTmFtZTogXCJ1aS1zdGFja1wiLFxuICAgICAgY29tcG9uZW50OiBHZSxcbiAgICAgIHByb3BNYXBwaW5nOiB7XG4gICAgICAgIGRpcmVjdGlvbjogXCJkaXJlY3Rpb25cIixcbiAgICAgICAgc3BhY2luZzogXCJzcGFjaW5nXCIsXG4gICAgICAgIGFsaWduOiBcImFsaWduXCIsXG4gICAgICAgIGp1c3RpZnk6IFwianVzdGlmeVwiXG4gICAgICB9LFxuICAgICAgZXZlbnRNYXBwaW5nOiB7fVxuICAgIH0sXG4gICAge1xuICAgICAgdGFnTmFtZTogXCJ1aS1pbWFnZVwiLFxuICAgICAgY29tcG9uZW50OiBWZSxcbiAgICAgIHByb3BNYXBwaW5nOiB7XG4gICAgICAgIHNyYzogXCJzcmNcIixcbiAgICAgICAgYWx0OiBcImFsdFwiLFxuICAgICAgICB3aWR0aDogXCJ3aWR0aFwiLFxuICAgICAgICBoZWlnaHQ6IFwiaGVpZ2h0XCJcbiAgICAgIH0sXG4gICAgICBldmVudE1hcHBpbmc6IHt9XG4gICAgfVxuICBdXG59LCBEdCA9ICh7IHJlY2VpdmVyOiByIH0pID0+IHtcbiAgY29uc3QgZSA9IEIobnVsbCk7XG4gIHJldHVybiBIKCgpID0+IHtcbiAgICBpZiAoZS5jdXJyZW50KVxuICAgICAgcmV0dXJuIHIuY29ubmVjdChlLmN1cnJlbnQpLCAoKSA9PiB7XG4gICAgICAgIHIuZGlzY29ubmVjdCgpO1xuICAgICAgfTtcbiAgfSwgW3JdKSwgLyogQF9fUFVSRV9fICovIHYoXCJkaXZcIiwgeyByZWY6IGUsIFwiZGF0YS10ZXN0aWRcIjogXCJzdGFuZGFyZC1kb20tcmVuZGVyZXItY29udGFpbmVyXCIgfSk7XG59LCBDdCA9ICh7XG4gIHJlc291cmNlOiByLFxuICBsaWJyYXJ5OiBlLFxuICByZW1vdGVFbGVtZW50czogdCA9IFtdLFxuICBvblVJQWN0aW9uOiBuXG59KSA9PiB7XG4gIGNvbnN0IHMgPSBCKG51bGwpLCBvID0gQihudWxsKSwgW2EsIHVdID0gQWUobnVsbCksIGwgPSB6KCgpID0+IChyLm1pbWVUeXBlIHx8IFwiXCIpLmluY2x1ZGVzKFwiZnJhbWV3b3JrPXJlYWN0XCIpID8gXCJyZWFjdFwiIDogXCJ3ZWJjb21wb25lbnRzXCIsIFtyLm1pbWVUeXBlXSksIGYgPSBgJHtlID09IG51bGwgPyB2b2lkIDAgOiBlLm5hbWV9LSR7bH1gLCB7IHJlY2VpdmVyOiBpLCBjb21wb25lbnRzOiBtIH0gPSB6KCgpID0+IHtcbiAgICBzd2l0Y2ggKGwpIHtcbiAgICAgIGNhc2UgXCJyZWFjdFwiOiB7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgZHQoKSwgcCA9IGUgfHwgV2UsIGggPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICByZXR1cm4gcCAmJiBwLmVsZW1lbnRzLmZvckVhY2goKEUpID0+IHtcbiAgICAgICAgICBjb25zdCBfID0gX3QoRS5jb21wb25lbnQpO1xuICAgICAgICAgIGguc2V0KEUudGFnTmFtZSwgXyk7XG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgcmVjZWl2ZXI6IGMsXG4gICAgICAgICAgY29tcG9uZW50czogaFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY2FzZSBcIndlYmNvbXBvbmVudHNcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVjZWl2ZXI6IG5ldyB1dCgpLFxuICAgICAgICAgIGNvbXBvbmVudHM6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG4gIH0sIFtyLCBlLCB0XSk7XG4gIEgoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIGMocCkge1xuICAgICAgdmFyIGg7XG4gICAgICBpZiAocy5jdXJyZW50ICYmIHAuc291cmNlID09PSBzLmN1cnJlbnQuY29udGVudFdpbmRvdykge1xuICAgICAgICBjb25zdCBFID0gcC5kYXRhO1xuICAgICAgICBpZiAoIUUpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICAoaCA9IG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4oRSkpID09IG51bGwgfHwgaC5jYXRjaCgoXykgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBoYW5kbGluZyBVSSBhY3Rpb24gcmVzdWx0IGluIFJlbW90ZURPTVJlc291cmNlUmVuZGVyZXI6XCIsIF8pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBjKSwgKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGMpO1xuICB9LCBbbl0pLCBIKCgpID0+IHtcbiAgICBjb25zdCBjID0gby5jdXJyZW50O1xuICAgIHJldHVybiBvLmN1cnJlbnQgPSBudWxsLCAoKSA9PiB7XG4gICAgICBjID09IG51bGwgfHwgYy5jbG9zZSgpO1xuICAgIH07XG4gIH0sIFtmXSk7XG4gIGNvbnN0IGQgPSAoKSA9PiB7XG4gICAgY29uc3QgYyA9IHMuY3VycmVudDtcbiAgICBpZiAoIWMgfHwgby5jdXJyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHAgPSBuZXcgT3QoYyk7XG4gICAgby5jdXJyZW50ID0gcDtcbiAgICBjb25zdCB7IGNvZGU6IGgsIGVycm9yOiBFIH0gPSB0dChyKTtcbiAgICBpZiAoRSkge1xuICAgICAgdShFKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGggJiYgKGkgIT0gbnVsbCAmJiBpLmNvbm5lY3Rpb24pKSB7XG4gICAgICBjb25zdCBfID0ge1xuICAgICAgICBjb2RlOiBoLFxuICAgICAgICByZW1vdGVFbGVtZW50czogdCxcbiAgICAgICAgdXNlUmVhY3RSZW5kZXJlcjogbCA9PT0gXCJyZWFjdFwiLFxuICAgICAgICBjb21wb25lbnRMaWJyYXJ5OiBlID09IG51bGwgPyB2b2lkIDAgOiBlLm5hbWVcbiAgICAgIH07XG4gICAgICBwLmltcG9ydHMucmVuZGVyKF8sIGkuY29ubmVjdGlvbikuY2F0Y2goKFIpID0+IGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjYWxsaW5nIHJlbW90ZSByZW5kZXI6XCIsIFIpKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBhID8gLyogQF9fUFVSRV9fICovIHYoXCJwXCIsIHsgY2xhc3NOYW1lOiBcInRleHQtcmVkLTUwMFwiLCBjaGlsZHJlbjogYSB9KSA6IC8qIEBfX1BVUkVfXyAqLyBjZSh0ZSwgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyB2KFxuICAgICAgXCJpZnJhbWVcIixcbiAgICAgIHtcbiAgICAgICAgcmVmOiBzLFxuICAgICAgICBzcmNEb2M6IHZ0LFxuICAgICAgICBzYW5kYm94OiBcImFsbG93LXNjcmlwdHNcIixcbiAgICAgICAgc3R5bGU6IHsgZGlzcGxheTogXCJub25lXCIgfSxcbiAgICAgICAgdGl0bGU6IFwiUmVtb3RlIERPTSBTYW5kYm94XCIsXG4gICAgICAgIG9uTG9hZDogZFxuICAgICAgfSxcbiAgICAgIGZcbiAgICApLFxuICAgIGwgPT09IFwicmVhY3RcIiAmJiBtID8gLyogQF9fUFVSRV9fICovIHYoYnQsIHsgcmVjZWl2ZXI6IGksIGNvbXBvbmVudHM6IG0gfSkgOiAvKiBAX19QVVJFX18gKi8gdihEdCwgeyByZWNlaXZlcjogaSB9KVxuICBdIH0pO1xufTtcbmZ1bmN0aW9uIEx0KHIpIHtcbiAgdmFyIGU7XG4gIGlmIChyLmNvbnRlbnRUeXBlKVxuICAgIHJldHVybiByLmNvbnRlbnRUeXBlO1xuICBpZiAoci5taW1lVHlwZSA9PT0gXCJ0ZXh0L2h0bWxcIilcbiAgICByZXR1cm4gXCJyYXdIdG1sXCI7XG4gIGlmIChyLm1pbWVUeXBlID09PSBcInRleHQvdXJpLWxpc3RcIilcbiAgICByZXR1cm4gXCJleHRlcm5hbFVybFwiO1xuICBpZiAoKGUgPSByLm1pbWVUeXBlKSAhPSBudWxsICYmIGUuc3RhcnRzV2l0aChcImFwcGxpY2F0aW9uL3ZuZC5tY3AtdWkucmVtb3RlLWRvbVwiKSlcbiAgICByZXR1cm4gXCJyZW1vdGVEb21cIjtcbn1cbmNvbnN0IFV0ID0gKHIpID0+IHtcbiAgY29uc3QgeyByZXNvdXJjZTogZSwgb25VSUFjdGlvbjogdCwgc3VwcG9ydGVkQ29udGVudFR5cGVzOiBuLCBodG1sUHJvcHM6IHMsIHJlbW90ZURvbVByb3BzOiBvIH0gPSByLCBhID0gTHQoZSk7XG4gIGlmIChuICYmIGEgJiYgIW4uaW5jbHVkZXMoYSkpXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjZShcInBcIiwgeyBjbGFzc05hbWU6IFwidGV4dC1yZWQtNTAwXCIsIGNoaWxkcmVuOiBbXG4gICAgICBcIlVuc3VwcG9ydGVkIGNvbnRlbnQgdHlwZTogXCIsXG4gICAgICBhLFxuICAgICAgXCIuXCJcbiAgICBdIH0pO1xuICBzd2l0Y2ggKGEpIHtcbiAgICBjYXNlIFwicmF3SHRtbFwiOlxuICAgIGNhc2UgXCJleHRlcm5hbFVybFwiOlxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB2KE5lLCB7IHJlc291cmNlOiBlLCBvblVJQWN0aW9uOiB0LCAuLi5zIH0pO1xuICAgIGNhc2UgXCJyZW1vdGVEb21cIjpcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gdihcbiAgICAgICAgQ3QsXG4gICAgICAgIHtcbiAgICAgICAgICByZXNvdXJjZTogZSxcbiAgICAgICAgICBvblVJQWN0aW9uOiB0LFxuICAgICAgICAgIGxpYnJhcnk6IChvID09IG51bGwgPyB2b2lkIDAgOiBvLmxpYnJhcnkpIHx8IFdlLFxuICAgICAgICAgIC4uLm9cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB2KFwicFwiLCB7IGNsYXNzTmFtZTogXCJ0ZXh0LXJlZC01MDBcIiwgY2hpbGRyZW46IFwiVW5zdXBwb3J0ZWQgcmVzb3VyY2UgdHlwZS5cIiB9KTtcbiAgfVxufTtcblV0LmRpc3BsYXlOYW1lID0gXCJVSVJlc291cmNlUmVuZGVyZXJcIjtcbmZ1bmN0aW9uIGp0KHIpIHtcbiAgdmFyIGUsIHQ7XG4gIHJldHVybiAoci50eXBlID09PSBcInJlc291cmNlXCIgJiYgKCh0ID0gKGUgPSByLnJlc291cmNlKSA9PSBudWxsID8gdm9pZCAwIDogZS51cmkpID09IG51bGwgPyB2b2lkIDAgOiB0LnN0YXJ0c1dpdGgoXCJ1aTovL1wiKSkpID8/ICExO1xufVxuY29uc3QgRnQgPSB7XG4gIHRhZ05hbWU6IFwidWktY2FyZFwiXG59LCBZdCA9IHtcbiAgdGFnTmFtZTogXCJ1aS1idXR0b25cIixcbiAgcmVtb3RlQXR0cmlidXRlczogW1wibGFiZWxcIl0sXG4gIHJlbW90ZUV2ZW50czogW1wiY2xpY2tcIiwgXCJwcmVzc1wiXVxufSwgR3QgPSB7XG4gIHRhZ05hbWU6IFwidWktdGV4dFwiLFxuICByZW1vdGVBdHRyaWJ1dGVzOiBbXCJjb250ZW50XCJdXG59LCBWdCA9IHtcbiAgdGFnTmFtZTogXCJ1aS1zdGFja1wiLFxuICByZW1vdGVBdHRyaWJ1dGVzOiBbXCJkaXJlY3Rpb25cIiwgXCJzcGFjaW5nXCIsIFwiYWxpZ25cIiwgXCJqdXN0aWZ5XCJdXG59LCBXdCA9IHtcbiAgdGFnTmFtZTogXCJ1aS1pbWFnZVwiLFxuICByZW1vdGVBdHRyaWJ1dGVzOiBbXCJzcmNcIiwgXCJhbHRcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiXVxufTtcbmV4cG9ydCB7XG4gIFV0IGFzIFVJUmVzb3VyY2VSZW5kZXJlcixcbiAgV2UgYXMgYmFzaWNDb21wb25lbnRMaWJyYXJ5LFxuICBydCBhcyBnZXRSZXNvdXJjZU1ldGFkYXRhLFxuICBudCBhcyBnZXRVSVJlc291cmNlTWV0YWRhdGEsXG4gIGp0IGFzIGlzVUlSZXNvdXJjZSxcbiAgWXQgYXMgcmVtb3RlQnV0dG9uRGVmaW5pdGlvbixcbiAgRnQgYXMgcmVtb3RlQ2FyZERlZmluaXRpb24sXG4gIFd0IGFzIHJlbW90ZUltYWdlRGVmaW5pdGlvbixcbiAgVnQgYXMgcmVtb3RlU3RhY2tEZWZpbml0aW9uLFxuICBHdCBhcyByZW1vdGVUZXh0RGVmaW5pdGlvblxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@mcp-ui/client/dist/index.mjs\n");

/***/ })

};
;